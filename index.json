[{"categories":["Android"],"contents":"Finding the right abstraction is hard. In this blog post, I would like to share a technique that works well for us (my android teammates and me) when dealing with String resources on android.\nAn abstraction layer for Strings? Why do we even need an abstraction to simply work with Strings on Android? Probably you don\u0026rsquo;t if your app is simple enough. But the more flexible your app needs to be regarding displaying text as content the sooner you realize that there are different kind of string resources and to deal with all of these kinds gracefully in your codebase you probably need another layer of abstraction. Let me explain what I mean with different kind of string resources:\n A simple String resource like R.string.some_text, displayed on screen via resources.getString(R.string.some_text) A formatted string which then is formatted at runtime. i.e. context.getString(R.string.some_text, “arg1”, 123) with \u0026lt;string name=”some_formatted_text”\u0026gt;Some formatted Text with args %s %i\u0026lt;/string\u0026gt;  More advanced String resources like Plurals that are loaded i.e. with resources.getQuantityString(R.plurals.number_of_items, 2): \u0026lt;plurals name=\u0026#34;number_of_items\u0026#34;\u0026gt; \u0026lt;item quantity=\u0026#34;one\u0026#34;\u0026gt;%d item\u0026lt;/item\u0026gt; \u0026lt;item quantity=\u0026#34;other\u0026#34;\u0026gt;%d items\u0026lt;/item\u0026gt; \u0026lt;/plurals\u0026gt;  A simple text that is not loaded from an android resource xml file like strings.xml but is loaded already as string type and doesn\u0026rsquo;t need any further translation (in contrast to R.string.some_text). For example, just a piece of text extracted from a json backend response.  Did you notice that to load these kinds of strings you have to invoke different methods with different parameters to actually get the string value? If we want to deal with all of them gracefully then we should consider introducting a layer of abstraction for strings. To do that we have to consider the following points:\n We don\u0026rsquo;t want to leak implementation details like which method to invoke to actually translate a resource into a string. We need to make text a first class citizen (if suitable) of our business logic layer instead of our UI layer so that the view layer can easily \u0026ldquo;render\u0026rdquo; it.  Let\u0026rsquo;s go step by step through this points by implementing a concrete example: Let\u0026rsquo;s say that we want to load a string from a backend via http and if that fails we fallback to display a fallback string that is loaded from strings.xml. Something like this:\nclass MyViewModel( private val backend : Backend, private val resources : Resources // Android resources from context.getResources() ) : ViewModel() { val textToDisplay : MutableLiveData\u0026lt;String\u0026gt; // for the sake of readability I use MutableLiveData  fun loadText(){ try { val text : String = backend.getText() textToDisplay.value = text } catch (t : Throwable) { textToDisplay.value = resources.getString(R.string.fallback_text) } } } We are leaking implementation details into MyViewModel making our ViewModel overall harder to test. Actually, to write a test for loadText() we would need to either mock Resources or to introduce an interface like StringRepository (repository pattern alike) so that we can swap it with another implementation for testing:\ninterface StringRepository{ fun getString(@StringRes id : Int) : String } class AndroidStringRepository( private val resources : Resources // Android resources from context.getResources() ) : StringRepository { override fun getString(@StringRes id : Int) : String = resources.getString(id) } class TestDoubleStringRepository{ override fun getString(@StringRes id : Int) : String = \u0026#34;some string\u0026#34; } Our ViewModel then gets a StringRepository instead of resources directly and we are good to go, right?\nclass MyViewModel( private val backend : Backend, private val stringRepo : StringRepository // hiding implementation details behind an interface ) : ViewModel() { val textToDisplay : MutableLiveData\u0026lt;String\u0026gt; fun loadText(){ try { val text : String = backend.getText() textToDisplay.value = text } catch (t : Throwable) { textToDisplay.value = stringRepo.getString(R.string.fallback_text) } } } We can unit test it like this:\n@Test fun when_backend_fails_fallback_string_is_displayed(){ val stringRepo = TestDoubleStringRepository() val backend = TestDoubleBackend() backend.failWhenLoadingText = true // makes backend.getText() throw an exception  val viewModel = MyViewModel(backend, stringRepo) viewModel.loadText() Assert.equals(\u0026#34;some string\u0026#34;, viewModel.textToDisplay.value) } With the introduction of interface StringRepository we have introduced a layer of abstraction and our problem is solved, right? Wrong. We have introduced an abstraction layer but this does not solve the real problem:\n StringRepository doesn\u0026rsquo;t address the fact that different kind of text exists (see enumeration at the beginning of this article). This is shown by the fact that our ViewModel still has code that is hard to maintain because it explicitly knows how to transform different kinds of text to String. That is the real issues we want to find a good abstraction for. Moreover, if you look at our test and the implementation of TestDoubleStringRepository, how meaningful is the test we wrote? TestDoubleStringRepository is always returning the same string. We could totally mess up our ViewModels code by passing R.string.foo instead of R.string.fallback_text to StringRepository.getString() and our test would still pass. Sure we can improve TestDoubleStringRepository by not just always return the same string, something like that: class TestDoubleStringRepository{ override fun getString(@StringRes id : Int) : String = when(id){ R.string.fallback_test -\u0026gt; \u0026#34;some string\u0026#34; R.string.foo -\u0026gt; \u0026#34;foo\u0026#34; else -\u0026gt; UnsupportedStringResourceException() } } But how maintainable is that? Do you really want to do that for all your strings in your app (if you have hundreds of strings)?\n  A better abstraction helps to solve both issues with one single abstraction.\nTextResource to the rescue We call the abstraction that we came up with TextResource and is a domain specific model to represent text. Thus, it is a first class citizen of our business logic. It looks as following:\nsealed class TextResource { companion object { // Just needed for static method factory so that we can keep concrete implementations file private  fun fromText(text : String) : TextResource = SimpleTextResource(text) fun fromStringId(@StringRes id : Int) : TextResource = IdTextResource(id) fun fromPlural(@PluralRes id: Int, pluralValue : Int) : TextResource = PluralTextResource(id, pluralValue) } } private data class SimpleTextResource( // We could also use use inline classes in the future  val text : String ) : TextResource() private data class IdTextResource( @StringRes id : Int ) : TextResource() private data class PluralTextResource( @PluralsRes val pluralId: Int, val quantity: Int ) : TextResource() // you could add more kinds of text in the future ... With TextResource our ViewModel looks as follows:\nclass MyViewModel( private val backend : Backend // Please note that we don\u0026#39;t need to pass any Resources nor StringRepository. ) : ViewModel() { val textToDisplay : MutableLiveData\u0026lt;TextResource\u0026gt; // Not of type String anymore!  fun loadText(){ try { val text : String = backend.getText() textToDisplay.value = TextResource.fromText(text) } catch (t : Throwable) { textToDisplay.value = TextResource.fromStringId(R.string.fallback_text) } } } The major difference are the following:\n textToDisplay changed from LiveData\u0026lt;String\u0026gt; to LiveData\u0026lt;TextResource\u0026gt; so ViewModel doesn\u0026rsquo;t need to know how to translate to different kind of text to String anymore but how to translate it to TextResource but that is fine as TextResource is the abstraction that solves our problems as we will see. Take a look at ViewModel\u0026rsquo;s constructor. We were able to remove the \u0026ldquo;wrong abstraction\u0026rdquo; StringRepository (nor do we need Resources). You might wonder how do we write test then? Just as simple as test against TextResource directly as this abstraction also abstracts away the android dependencies like Resources or Context (R.string.fallback_text is just an Int). So this is how our unit test look like: @Test fun when_backend_fails_fallback_string_is_displayed(){ val backend = TestDoubleBackend() backend.failWhenLoadingText = true // makes backend.getText() throw an exception  val viewModel = MyViewModel(backend) viewModel.loadText() val expectedText = TextResource.fromStringId(R.string.fallback_text) Assert.equals(expectedText, viewModel.textToDisplay.value) // data classes generate equals methods for us so we can compare them easily }   So far so good, but one piece is missing: how do we translate TextResource to String so that we can display it in a TextView for example? Well, that is a pure \u0026ldquo;android rendering\u0026rdquo; thing and we can create an extension function and keep it to our UI layer only.\n// Note: you can get resources with context.getResources() fun TextResource.asString(resources : Resources) : String = when (this) { is SimpleTextResource -\u0026gt; this.text // smart cast  is IdTextResource -\u0026gt; resources.getString(this.id) // smart cast  is PluralTextResource -\u0026gt; resources.getQuantityString(this.pluralId, this.quantity) // smart cast } Moreover, since \u0026ldquo;translating\u0026rdquo; TextResource to String is happening in the UI (or View layer) of our app\u0026rsquo;s architecture TextResource will be \u0026ldquo;retranslated\u0026rdquo; on config changes (i.e. changing system language on your smartphone) results in displaying the right localized string for any of your apps R.string.* resources.\nBonus: You can unit test TextResource.asString() easily (mocking Resources but you don\u0026rsquo;t need to mock it for every single string resource in your app as all you really want to unit test is that the when state works properly, so here it is fine to always return the same string from mocked resources.getString()). Furthermore, TextResource is highly reusable throughout our codebas and follows the open-closed principle. Thus, it is extendable for future use cases by only addig a few lines of code to our codebase (add a new data class that extends TextResource and add a new case in the when statement in TextResource.asString()).\n","permalink":"https://hannesdorfmann.com/abstraction-text-resource/","tags":["android","design-patterns"],"title":"Finding the right abstraction (when working with Strings)"},{"categories":null,"contents":"I was born and raised in the middle of the Alps in the north of Italy (Dolomites). That is the reason why the mountains and hiking are just in my DNA (as you probably have already guessed by the pictures used here in this blog). I\u0026rsquo;m really into sports. Any kind of sports. I love playing (and chatting) about football. Of course, I also like software engineering.\nFun fact: My name sounds German but I\u0026rsquo;m Italian (I know it\u0026rsquo;s confusion\u0026hellip; we can talk about that while grabbing a beer).\nI\u0026rsquo;m part of a cross-functional team (iOS, android, web and backend engineers) team at Freeletics working in the growth and monetization area. I\u0026rsquo;m supporting our team as an Engineering Manager by helping others with their personal and professional growth. I\u0026rsquo;m also leading a small second cross-functional team called \u0026ldquo;Engineering Productivity\u0026rdquo;, which is focusing on CI/CD, automation, libraries, and creating building blocks for feature development teams. Although I have multiple years of experience in leadership roles and in leading different kind of teams, still I consider myself as a lifelong student of leadership and software engineering. That is the reason why I run this blog: I would like to connect and learn from others and share my experience.\nAlthough I consider myself T-shaped and enjoy working on multiple platforms, I keep the green little robot very close to my heart. You will find a lot of technical articles related to android development.\nIf I\u0026rsquo;m not on a hike or I\u0026rsquo;m not on the football field then I\u0026rsquo;m probably recording a new episode of TheContext Podcast or I am contributing to some open source project on Github.\nI live in the beautiful city of Munich, Germany.\nAll of the content on this site is made available at no charge, for the benefit of the community. Please don’t reproduce the entire content (or very substantial portions) of any article without asking .\n","permalink":"https://hannesdorfmann.com/about/","tags":null,"title":"About"},{"categories":null,"contents":"The easiest way to get in touch with me is to just send me a message on Twitter.\nI\u0026rsquo;m @sockeqwe on Twitter.\n","permalink":"https://hannesdorfmann.com/contact/","tags":null,"title":"Contact"},{"categories":null,"contents":"Over the years I have had the very high honor and pleasure to give talks and presentations at various events and conferences:\n","permalink":"https://hannesdorfmann.com/presentations/","tags":null,"title":"Presentations"},{"categories":null,"contents":"","permalink":"https://hannesdorfmann.com/search/","tags":null,"title":"Search Result"},{"categories":["Android"],"contents":"In my previous blog post we discussed how the Coordinator pattern can be applied on Android. This time I would like to show how this can be used in Model-View-Intent.\nIf you don\u0026rsquo;t know yet what the Coordinator pattern is I highly recommend to go back and read the introdcution.\nApplying this pattern in MVI is not much different from MVVM or MVP: we pass a lambda as navigation callback into our MviBasePresenter. The interesting part is how do we trigger this callbacks in a state driven architecture? Let\u0026rsquo;s take a look at a concrete example:\nclass FooPresenter( private var navigationCallback: ( () -\u0026gt; Unit )? ) : MviBasePresenter\u0026lt;FooView\u0026gt; { lateinit var disposable : Disposable override fun bindIntents(){ val intent1 = ... val intent2 = ... val intents = Observable.merge(intent1, intent2) val state = intents.switchMap { ... } // Here stars the interesting part  val sharedState = state.share() disposable = sharedState.filter{ state -\u0026gt; state is State.Foo }.subscribe { navigationCallback!!() } subscribeViewState(sharedState, FooView::render) } override fun unbindIntents(){ disposable.dispose() // Navigation disposable  navigationCallback = null // Avoid memory leaks  } } The idea is to reuse the same state observable that we usually use to render the state in our View by using RxJava\u0026rsquo;s share() operator. This plus the combination of .filter() allows us to listen for a certain state and then trigger the navigation once we reached that state. The Coordinator Pattern then just works as described in my previous blog post.\nThis is a post in the Reactive Apps with Model-View-Intent series. Other posts in this series:\n  Reactive Apps with Model-View-Intent - Part 1: Model   Reactive Apps with Model-View-Intent - Part 2: View and Intent   Reactive Apps with Model-View-Intent - Part 3: State Reducer   Reactive Apps with Model-View-Intent - Part 4: Independent UI Components   Reactive Apps with Model-View-Intent - Part 5: Debugging with ease   Reactive Apps with Model-View-Intent - Part 6: Restoring State   Reactive Apps with Model-View-Intent - Part 7: Timing (SingleLiveEvent problem)   Reactive Apps with Model-View-Intent - Part 8: Navigation    ","permalink":"https://hannesdorfmann.com/android/mosby3-mvi-8/","tags":["android","software-architecture","design-patterns"],"title":"Reactive Apps with Model-View-Intent - Part 8: Navigation"},{"categories":["Android"],"contents":"Over the last years we have established best practices for writing android apps: clean architecture, architectural patterns like MVP, MVVM, MVI, Repository pattern and so on. But what about in-app navigation? In this blog post I would like to talk about the Coordinator pattern and how we could apply this pattern in android development to organize our in-app navigation code.\nThe Coordinator pattern is a common pattern in iOS development introduced by Soroush Khanlou to help organizing in-app navigation code, which seems to be inspired by Application Controller (part of the book patterns of Enterprise Application Architecture Martin Fowler et al.).\nThe goals of this pattern is:\n Avoiding so called Massive ViewControllers (think God-Activity) with way to much responsibilities. Give in-app navigation flow logic a home. Reuse ViewControllers (think Activity or Fragments) because they are not coupled to in-app navigation.  Before we get deeper into what the Coordinator pattern is and how it can be implemented, let\u0026rsquo;s take a look at what the current state of in-app navigation in android development is.\nNavigation logic in Activity or Fragments Since the Android SDK requires an Context to start a new Activity (or FragmentManager to put a new Fragment on the back stack) it\u0026rsquo;s quite common to put in-app navigation code directly into your Activity like this (you can find such code in the official android guides provided by Google):\nclass ShoppingCartActivity : Activity() { override fun onCreate(b : Bundle?){ super.onCreate(b) setContentView(R.layout.activity_shopping_cart) val checkoutButton = findViewById(R.id.checkoutButton) checkoutButton.setOnClickListener { val intent = Intent(this, CheckoutActivity::class.java) startActivity(intent) } } } In-app navigation logic is \u0026ldquo;hard coded\u0026rdquo; in ShoppingCartActivity which means navigation is tightly coupled to that activity. Can we test this code easily? One could argue that we could decouple that by having something like a Navigator that can be injected (dependency injection) like this:\nclass ShoppingCartActivity : Activity() { @Inject lateinit var navigator : Navigator override fun onCreate(b : Bundle?){ super.onCreate(b) setContentView(R.layout.activity_shopping_cart) val checkoutButton = findViewById(R.id.checkoutButton) checkoutButton.setOnClickListener { navigator.showCheckout(this) } } } class Navigator { fun showCheckout(activity : Activity){ val intent = Intent(activity, CheckoutActivity::class.java) activity.startActivity(intent) } } Okay slightly better but can we do it even better?\nNavigation in MVVM or MVP Let me ask you a question: if you use MVP or MVVM where do you put in-app navigation logic?\n  The layer below Presenter (let\u0026rsquo;s call it business logic)? Not a good idea because the chances are high that you are going to reuse or share parts of your business logic in other different ViewModels or Presenters.\n  In View layer? Do you like playing ping pong between View and Presenter (or ViewModel)?\n  class ShoppingCartActivity : ShoppingCartView, Activity() { @Inject lateinit var navigator : Navigator @Inject lateinit var presenter : ShoppingCartPresenter override fun onCreate(b : Bundle?){ super.onCreate(b) setContentView(R.layout.activity_shopping_cart) val checkoutButton = findViewById(R.id.checkoutButton) checkoutButton.setOnClickListener { presenter.checkoutClicked() } } override fun navigateToCheckout(){ navigator.showCheckout(this) } } class ShoppingCartPresenter : Presenter\u0026lt;ShoppingCartView\u0026gt; { ... override fun checkoutClicked(){ view?.navigateToCheckout(this) } } Or if you prefer MVVM over MVP you might use SingleLiveEvents or EventObserver\nclass ShoppingCartActivity : ShoppingCartView, Activity() { @Inject lateinit var navigator : Navigator @Inject lateinit var viewModel : ViewModel override fun onCreate(b : Bundle?){ super.onCreate(b) setContentView(R.layout.activity_shopping_cart) val checkoutButton = findViewById(R.id.checkoutButton) checkoutButton.setOnClickListener { viewModel.checkoutClicked() } viewModel.navigateToCheckout.observe(this, Observer { navigator.showCheckout(this) }) } } class ShoppingCartViewModel : ViewModel() { val navigateToCheckout = MutableLiveData\u0026lt;Event\u0026lt;Unit\u0026gt;\u0026gt; fun checkoutClicked(){ navigateToCheckout.value = Event(Unit) // Trigger the event by setting a new Event as a new value  } }  So let\u0026rsquo;s put the Navigator into our ViewModel (or Presenter) rather than using EventObserver as shown above?  class ShoppingCartViewModel @Inject constructor(val navigator : Navigator) : ViewModel() { fun checkoutClicked(){ navigator.showCheckout() } } Please note that the code snipped shown above can be translated to Presenter too (injecting Navigator as constructor parameter to Presenter). Also, we ignore the fact that Navigator could leak the Activity if it internally holds a reference to it (that is solvable somehow with a workaround).\nCoordinators So where do we put in-app navigation logic? Business Logic is not a good idea (as described above) and playing ping pong between View and ViewModel (or Presenter) might work but doesn\u0026rsquo;t seem to be a elegant solution. Moreover, View still has navigation related responsibilities even if it\u0026rsquo;s just calling navigator. Therefore, doing navigation in the ViewModel seems to be a considerable alternative but is it really the responsibility of the ViewModel (or Presenter) to care about navigation? Shouldn\u0026rsquo;t it be just the glue to present data? That\u0026rsquo;s why we introduce a Coordinator. Yet another level of abstraction? Is it really worthwhile? Maybe not for a small app but for more complex apps or apps that run A/B tests this could be useful. Even if a user can create an account and sign in you have already some major navigation logic - somewhere you have to check if the user is logged in or not and navigate to the login screen or to the main screen, right? A Coordinator can be useful in this case. Also note that Coordinators are not helping you to write less code, they help you to organize in-app navigation related code by giving it a home (and take that responsibility out of View or ViewModel).\nThe idea is simple: a Coordinator just knows to which screen to go next. For example by clicking on the checkout button the Coordinator gets notified and knows where to go next (Checkout). It\u0026rsquo;s that simple. However, in iOS development it seems to be common to use Coordinator to create ViewControllers, service locator (or dependency injection) and back stack management. That\u0026rsquo;s quite a bit for a Coordinator (single responsibility?). On Android the operating system instantiates Activities, we have Dagger for dependency injection and we can use Activity or Fragment back stack. Therefore, I would like to go back to the roots of a Coordinator: A Coordinator just knows where to go next.\nCase Study: A newspaper app using the Coordinator pattern Finally: let\u0026rsquo;s talk about concrete Coordinators. Let\u0026rsquo;s say we have to build a small application for a newspaper with a simple in-app navigation flow: As a user you see a list of news articles. Once you click on an article the app opens a new screen where you can read the full article.\nclass NewsFlowCoordinator (val navigator : Navigator) { fun start(){ navigator.showNewsList() } fun readNewsArticle(id : Int){ navigator.showNewsArticle(id) } } A Flow contains one or more screens. In our case the \u0026ldquo;news flow\u0026rdquo; consists of two screens: news list and read the full news article. That\u0026rsquo;s it. It\u0026rsquo;s so simple we don\u0026rsquo;t need a library. Whenever we start the app, we call NewsFlowCoordinator.start() to show the list of all news articles. Once the user clicks on a news article NewsFlowCoordinator.readNewsArticle(id) gets called and that news article gets displayed. We still have a Navigator (we will talk about it in a minute) where we delegate the actual \u0026ldquo;screen swapping\u0026rdquo; work to. A Coordinator is completely stateless, independent from the underlying back stack implementation and only has one responsibility principle: It handles where to go next.\nThe next question is how do we connect a Coordinator with our ViewModel? We follow the push don\u0026rsquo;t pull principle: We pass a lambda (think callback or click listener) into the ViewModel that is triggered once the user clicks on a news article in the UI like that:\nclass NewsListViewModel( newsRepository : NewsRepository, var onNewsItemClicked: ( (Int) -\u0026gt; Unit )? ) : ViewModel() { val newsArticles = MutableLiveData\u0026lt;List\u0026lt;News\u0026gt;\u0026gt; private val disposable = newsRepository.getNewsArticles().subscribe { newsArticles.value = it } fun newsArticleClicked(id : Int){ onNewsItemClicked!!(id) // call the lambda  } override fun onCleared() { disposable.dispose() onNewsItemClicked = null // to avoid memory leaks  } } onNewsItemClicked: (Int) -\u0026gt; Unit is just a lambda that takes an integer as input and returns Unit. We pass that lambda as nullable into our ViewModel, hence the surrounding ( \u0026hellip; )?. This allows us to clear the reference to that lambda to avoid memory leaks. The next question is: what is actually happening by invoking this lambda? It\u0026rsquo;s the navigation flow handler, in other words: a callback to the NewsFlowCoordinator. Whoever creates the NewsListViewModel (i.e. Dagger) has to pass in the function NewsFlowCoordinator::readNewsArticle like this:\nreturn NewsListViewModel( newsRepository = newsRepository, onNewsItemClicked = newsFlowCoordinator::readNewsArticle ) If you are not an Kotlin expert let me quickly explain you what\u0026rsquo;s going on here. Whenever the user clicks on a item in the news list viewModel.newsArticleClicked(id) gets called which then invokes onNewsItemClicked(id) which is actually the function readNewsArticle(id) of NewsFlowCoordinator. So a click on a news list item triggers eventually NewsFlowCoordinator.readNewsArticle(id).\nThe next question is: how is Navigator implemented? This is mostly left as an exercise for the reader because it depends on your concrete use case and personal preferences. In this example we use a single Activity with multiple Fragments (each screen is a Fragment with corresponding ViewModel). Hence a very naive implementation could look like this:\nclass Navigator{ var activity : FragmentActivity? = null fun showNewsList(){ activty!!.supportFragmentManager .beginTransaction() .replace(R.id.fragmentContainer, NewsListFragment()) .commit() } fun showNewsDetails(newsId: Int) { activty!!.supportFragmentManager .beginTransaction() .replace(R.id.fragmentContainer, NewsDetailFragment.newInstance(newsId)) .addToBackStack(\u0026#34;NewsDetail\u0026#34;) .commit() } } class MainActivity : AppCompatActivity() { @Inject lateinit var navigator : Navigator override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) navigator.activty = this } override fun onDestroy() { super.onDestroy() navigator.activty = null // Avoid memory leaks  } } The presented Navigator implementation is not perfect at all. The focus of this blog post is the Coordinator pattern, not the Navigator implementation. One thing to note though is that since Navigator and NewsFlowCoordinator are stateless they can be in application wide scope (think @Singleton scope in Dagger) and can be instantiated for example in Application.onCreate().\nSo let\u0026rsquo;s add user authentication functionality to our newspaper app. We define a new login screen (LoginFragment + LoginViewModel, we skip \u0026ldquo;forgot password\u0026rdquo; and \u0026ldquo;sign up\u0026rdquo; in this blog post) and a LoginFlowCoordinator.\nWhy not add this functionality to NewsFlowCoordinator? We don\u0026rsquo;t want to have a God-Coordinator, right? Also, login related screens belong to a different navigation flow (not reading news), right?\nclass LoginFlowCoordinator( val navigator: Navigator ) { fun start(){ navigator.showLogin() } fun registerNewUser(){ navigator.showRegistration() } fun forgotPassword(){ navigator.showRecoverPassword() } } class LoginViewModel( val usermanager: Usermanager, var onSignUpClicked: ( () -\u0026gt; Unit )?, var onForgotPasswordClicked: ( () -\u0026gt; Unit )? ) { fun login(username : String, password : String){ usermanager.login(username, password) ... } ... } There are two things in LoginViewModel worthwhile to discuss: First for every kind of navigation we define it\u0026rsquo;s own lambda (sign up and forgot password) that gets invoked once the user clicks on the corresponding UI widget. But why is there no \u0026ldquo;login successful\u0026rdquo; lambda? How do we trigger navigation to next screen after the user is authenticated?\nThis is yet another implementation detail (there totally could be a \u0026ldquo;login successful\u0026rdquo; lambda) I think it makes more sense to do the following: We add a new RootFlowCoordinator and observe the Usermanager (business logic) for changes. The Usermanager provides API to sign in and to subscribe (observe, i.e. RxJava) for the current user.\nclass RootFlowCoordinator( val usermanager: Usermanager, val loginFlowCoordinator: LoginFlowCoordinator, val newsFlowCoordinator: NewsFlowCoordinator, val onboardingFlowCoordinator: OnboardingFlowCoordinator ) { init { usermanager.currentUser.subscribe { user -\u0026gt; when (user){ is NotAuthenticatedUser -\u0026gt; loginFlowCoordinator.start() is AuthenticatedUser -\u0026gt; if (user.onBoardingCompleted) newsFlowCoordinator.start() else onboardingFlowCoordinator.start() } } } fun onboardingCompleted(){ newsFlowCoordinator.start() } } As the name already suggests, RootFlowCoordinator becomes our new starting point (not NewsFlowCoordinator.start() anymore). Let\u0026rsquo;s take a closer look at the RootFlowCoordinator. As already mentioned RootFlowCoordinator observes the Usermanager whether or not the current user is authenticated. If user is not authenticated, then we start the LoginFlowCoordinator. If the user is authenticated (note that if the login in LoginFragment was successful it will propagated to this piece of code, hence no \u0026ldquo;login successful\u0026rdquo; lambda in LoginViewModel) then we check if the user already did the onboarding (we will talk about it in a minute) and start the NewsFlowCoordinator, otherwise we start the OnboardingFlowCoordinator. Please note that starting a coordinator doesnt mean creating a new instance, it means calling the start() method. Let\u0026rsquo;s take a look at the Onboarding flow\nclass OnboardingFlowCoordinator( val navigator: Navigator, val onboardingFinished: () -\u0026gt; Unit // this is RootFlowCoordinator.onboardingCompleted() ) { fun start(){ navigator.showOnboardingWelcome() } fun welcomeShown(){ navigator.showOnboardingPersonalInterestChooser() } fun onboardingCompleted(){ onboardingFinished() } } Onboarding starts with OnboardingFlowCoordinator.start() which shows WelcomeFragment (WelcomeViewModel). Once the use clicks the \u0026ldquo;next button\u0026rdquo; OnboardingFlowCoordinator.welcomeShown() is invoked which then shows the next screen (PersonalInterestFragment + PersonalInterestViewModel) where the user can set categories of news he is interested in. Once categories are selected and user clicked \u0026ldquo;next button\u0026rdquo; OnboardingFlowCoordinator.onboardingCompleted() is invoked which is then actually invoking RootFlowCoordinator.onboardingCompleted() which then calls NewsFlowCoordinator.start(). This is how we solve parent-child relations with coordinators: lambdas (or callbacks) to the parent coordinator.\nI have mentioned before that Coordinators are useful for A/B tests. Let\u0026rsquo;s add a screen that asks the user to do an in app purchase extend our NewsFlowCoordinator so that either the user sees that new screen or not depending on if he is part of group B of the A/B test.\nclass NewsFlowCoordinator ( val navigator : Navigator, val abTest : AbTest ) { fun start(){ navigator.showNewsList() } fun readNewsArticle(id : Int){ navigator.showNewsArticle(id) } fun closeNews(){ if (abTest.isB){ navigator.showInAppPurchases() } else { navigator.closeNews() } } } Again, no navigation logic is in your View or ViewModel but rather the Coordinator knows how to deal with A/B tests. Do you have to add the InAppPurchaseFragment to the onboarding flow too? You can do that because the InAppPurchaseFragment nor the corresponding ViewModel is coupled to navigation related code and therefore it is possible to reuse Fragments and ViewModel in other flows. All we have to pass to the ViewModel is a different lambda as navigation callback. Is your A/B test bigger than just adding one screen, for example two different onboarding flows you want to A/B test? No problem, just create a OnboardingFlowACoordinator and OnboardingFlowBCoordinator.\nYou can find the source code on Github. If you are too lazy to compile and run the app yourself, here is a little video of the final result:\n  Pro Tip: With Kotlin you can create nice DSLs for your Coordinators. This makes your in-app navigation code even more readable because basically you are creating a navigation graph.\nnewsFlowCoordinator(navigator, abTest) { start { navigator.showNewsList() } readNewsArticle { id -\u0026gt; navigator.showNewsArticle(id) } closeNews { if (abTest.isB){ navigator.showInAppPurchases() } else { navigator.closeNews() } } } Conclusion Coordinators can help you to organize in-app navigation logic by creating loosely coupled components with single responsibility and great testability. Coordinators can be scoped similar to singleton because they are stateless and you don\u0026rsquo;t create new navigation flows at runtime, therefore you can \u0026ldquo;hard code\u0026rdquo; all your in app navigation flows with very readable Kotlin DSL\u0026rsquo;s. Are Coordinators on Android ready for prime time? As already said, this is not a library, this is just an idea and concept. Is this idea applicable in your app? I dont know, ultimately it\u0026rsquo;s your app and you know best if there is need for the Coordinator pattern and how easy it is to integrate it into your existing app architecture. Maybe it\u0026rsquo;s a good idea to create a small sample application to try this pattern out.\nFAQ  What about Model-View-Intent? Does the Coordinator pattern work well with MVI too? Sure, take a look here What about Navigation Controller from Android Jetpack? This is an implementation detail. Instead of using Navigator use Navigation Controller (or inside your Navigator implementation: rather than executing FragmentTransactions directly use Navigation Controller). What if I don\u0026rsquo;t want to use Fragments at all? How hard is it to write my own back stack that plays nice with the Coordinator pattern (i.e. just using custom ViewGroups)? Stay tuned, I\u0026rsquo;m working on a prove of concept and will share it in my blog. Hint: Finite state machines FTW. Do I have to use a single Activity? No, use whatever you want to do. You can have multiple activities with multiple fragments, whatever works best for you. These implementation details are hidden behind the Navigator class Do I have to have one giant Navigator class? Absolutely not! Create multiple Navigator classes (i.e. one for each flow) to keep them small and maintainable. What about animations like shared element transitions? Don\u0026rsquo;t put them directly into your Fragment (or Activity or ViewGroup, whatever you use in your app) because if you do so your Fragment is highly coupled to the \u0026ldquo;previous\u0026rdquo; or \u0026ldquo;next\u0026rdquo; fragment and that is exactly what we want to avoid. Put shared element transition code (or animation code in general) in your Navigator. But how dows a Navigator knows when it\u0026rsquo;s time to start the animation? Let\u0026rsquo;s assume you have to navigate from Fragment A to Fragment B and you want to show a shared element transition. Add a FragmentLifecycleCallback to Fragment so that you can listen for onFragmentViewCreated(v : View). Next do pretty the same as you would do directly in your Fragment: Add a OnPreDrawListener to wait until everything is ready and call startPostponedEnterTransition(). You can apply the same idea for Activities by using ActivityLifecycleCallbacks or ViewGroups with OnHierarchyChangeListener and others. Just be careful to unregister listeners to avoid memory leaks.  ","permalink":"https://hannesdorfmann.com/android/coordinators-android/","tags":["android","design-patterns","navigation"],"title":"In-App Navigation with Coordinators"},{"categories":["Android"],"contents":"In my previous blog post we discussed the importance of proper state management and why I think introducing a SingleLiveEvent as discussed in Google\u0026rsquo;s Architecture Components GitHub repo is not a good idea because it just hides the real underlying problem: state management. In this blog post I would like to discuss how the problem SingleLiveEvent claims to solve can be solved with Model-View-Intent and proper state management.\nA common scenario that illustrates this problem is a Snackbar that is displayed if an error has occurred. A Snackbar is not meant to be persistent but rather should just display the error message for a few seconds and then disappear. The problem is how do we model this error state and \u0026ldquo;disappearing\u0026rdquo;?\nTake a look at this video to better understand what I\u0026rsquo;m talking about:\n  This sample app displays a list of countries that are loaded from a CountriesRepository. If we click on a country we start a second Activity that just displays the \u0026ldquo;details\u0026rdquo; (just the country\u0026rsquo;s name). When we navigate back to the list of countries, we expect to see the same \u0026ldquo;state\u0026rdquo; displayed on the screen as before clicking on a country. So far so good, but what happens if we trigger a pull-to-refresh and an error occurres while loading data which eventually will display a Snackbar displaying the error message on the screen. As you see in the video above, whenever we come back to the list of countries the Snackbar is shown again but that is ususally not the behavior the user expects, right?\nThe problem is that this screen is in the \u0026ldquo;show error state\u0026rdquo;. Google\u0026rsquo;s Architecture Components Example based on ViewModel and LiveData uses a SingleLiveEvent to workaround this issue. The idea is: whenever the View resubscribes (after coming back from \u0026ldquo;details\u0026rdquo; screen) to his ViewModel, SingleLiveEvent ensures that \u0026ldquo;error state\u0026rdquo; is not emitted again. While this prevents reappearing Snackbar, does it really solves the problem?\nTiming is Everything (for Snackbars) Again, I still think that such \u0026ldquo;workarounds\u0026rdquo; are not the proper way. Can we do it better? I think that proper state management and a unidirectional data flow is a better solution. Model-View-Intent is an architectural pattern that follows these principles. So how do we solve the \u0026ldquo;Snackbar problem\u0026rdquo; in MVI? First, let\u0026rsquo;s Model state:\npublic class CountriesViewState { // True if progressbar should be displayed  boolean loading; // List of countries (country names) if loaded  List\u0026lt;String\u0026gt; countries; // true if pull to refresh indicator should be displayed  boolean pullToRefresh; // true if an error has occurred while pull to refresh -\u0026gt; Show Snackbar.  boolean pullToRefreshError; } The idea in MVI is that the View layer gets an (immutable) CountriesViewState and just displays that one. So if pullToRefreshError is true then display a Snackbar, otherwise don\u0026rsquo;t.\npublic class CountriesActivity extends MviActivity\u0026lt;CountriesView, CountriesPresenter\u0026gt; implements CountriesView { private Snackbar snackbar; private ArrayAdapter\u0026lt;String\u0026gt; adapter; @BindView(R.id.refreshLayout) SwipeRefreshLayout refreshLayout; @BindView(R.id.listView) ListView listView; @BindView(R.id.progressBar) ProgressBar progressBar; ... @Override public void render(CountriesViewState viewState) { if (viewState.isLoading()) { progressBar.setVisibility(View.VISIBLE); refreshLayout.setVisibility(View.GONE); } else { // show countries  progressBar.setVisibility(View.GONE); refreshLayout.setVisibility(View.VISIBLE); adapter.setCountries(viewState.getCountries()); refreshLayout.setRefreshing(viewState.isPullToRefresh()); if (viewState.isPullToRefreshError()) { showSnackbar(); } else { dismissSnackbar(); } } } private void dismissSnackbar() { if (snackbar != null) snackbar.dismiss(); } private void showSnackbar() { snackbar = Snackbar.make(refreshLayout, \u0026#34;An Error has occurred\u0026#34;, Snackbar.LENGTH_INDEFINITE); snackbar.show(); } } The important bit here is Snackbar.LENGTH_INDEFINITE which means Snackbar stays until we dismiss it. So we don\u0026rsquo;t let android animate the Snackbar in and out. Moreover, we don\u0026rsquo;t let android mess up with state nor let android introduce a state for UI that is different from the state of business logic. Instead of using Snackbar.LENGTH_SHORT which would display Snackbar for two seconds, we rather let the business logic take care of setting CountriesViewState.pullToRefreshError to true for two seconds and then set it to false.\nHow do we do that in RxJava? We can use Observable.timer() and startWith() operator.\npublic class CountriesPresenter extends MviBasePresenter\u0026lt;CountriesView, CountriesViewState\u0026gt; { private final CountriesRepositroy repositroy = new CountriesRepositroy(); @Override protected void bindIntents() { Observable\u0026lt;RepositoryState\u0026gt; loadingData = intent(CountriesView::loadCountriesIntent).switchMap(ignored -\u0026gt; repositroy.loadCountries()); Observable\u0026lt;RepositoryState\u0026gt; pullToRefreshData = intent(CountriesView::pullToRefreshIntent).switchMap( ignored -\u0026gt; repositroy.reload().switchMap(repoState -\u0026gt; { if (repoState instanceof PullToRefreshError) { // Let\u0026#39;s show Snackbar for 2 seconds and then dismiss it  return Observable.timer(2, TimeUnit.SECONDS) .map(ignoredTime -\u0026gt; new ShowCountries()) // Show just the list  .startWith(repoState); // repoState == PullToRefreshError  } else { return Observable.just(repoState); } })); // Show Loading as inital state  CountriesViewState initialState = CountriesViewState.showLoadingState(); Observable\u0026lt;CountriesViewState\u0026gt; viewState = Observable.merge(loadingData, pullToRefreshData) .scan(initialState, (oldState, repoState) -\u0026gt; repoState.reduce(oldState)) subscribeViewState(viewState, CountriesView::render); } } CountriesRepositroy has a method reload() that returns an Observable\u0026lt;RepoState\u0026gt;. RepoState (was named PartialViewState in previous posts in this MVI series) is just a POJO class that indicates if the repository is fetching data, has loaded data successfully or an error has occurred (source code). Then we use a State Reducer to compute the View State (scan() operator). This should be familiar if you have read the previous blog posts of my MVI series. The \u0026ldquo;new\u0026rdquo; thing is:\nrepositroy.reload().switchMap(repoState -\u0026gt; { if (repoState instanceof PullToRefreshError) { // Let\u0026#39;s show Snackbar for 2 seconds and then dismiss it  return Observable.timer(2, TimeUnit.SECONDS) .map(ignoredTime -\u0026gt; new ShowCountries()) // Show just the list  .startWith(repoState); // repoState == PullToRefreshError  } else { return Observable.just(repoState); } This piece of code does the following: If we run into an error (repoState instanceof PullToRefreshError) then we emit this error state (PullToRefreshError) which then causes the state reducer to set CountriesViewState.pullToRefreshError = true. After 2 seconds Observable.timer() emits ShowCountries state that causes the state reducer to set CountriesViewState.pullToRefreshError = false.\nEt voilà, this is how we show and hide Snackbar in MVI.\n  Please note that this is not a workaround like SingleLiveEvent. It\u0026rsquo;s proper state management and the View is just displaying or \u0026ldquo;rendering\u0026rdquo; the given state. So once the user of our app comes back from the details screen to the list of countries he doesn\u0026rsquo;t see the Snackbar anymore because the state has changed in the meantime to CountriesViewState.pullToRefreshError = false. Thus Snackbar doesn\u0026rsquo;t get displayed.\nUser dismisses Snackbar What if we want to allow the user to dismiss the Snackbar with a swipe gesture. Well, that\u0026rsquo;s pretty straight forward. Dismissing the snackbar is yet another intent to change the state. To put this into the existing code we just have to ensure that either the timer or the swipe to dismiss intent sets CountriesViewState.pullToRefreshError = false. The only thing we have to keep in mind is that if swipe to dismiss intent triggers before the timer we have to cancel the timer. That sounds complex but actually it isn\u0026rsquo;t thanks to RxJava\u0026rsquo;s great api and operators:\nObservable\u0026lt;Long\u0026gt; dismissPullToRefreshErrorIntent = intent(CountriesView::dismissPullToRefreshErrorIntent) ... repositroy.reload().switchMap(repoState -\u0026gt; { if (repoState instanceof PullToRefreshError) { // Let\u0026#39;s show Snackbar for 2 seconds and then dismiss it  return Observable.timer(2, TimeUnit.SECONDS) .mergeWith(dismissPullToRefreshErrorIntent) // merge timer and dismiss intent  .take(1) // Only take the one who triggers first (dismiss intent or timer)  .map(ignoredTime -\u0026gt; new ShowCountries()) // Show just the list  .startWith(repoState); // repoState == PullToRefreshError  } else { return Observable.just(repoState); }    With mergeWith() we combine the timer and dismiss intent into one observable and then with take(1) we take the first one that emits. If swipe to dismiss triggers before the timer then take(1) cancels the timer and vice versa: if timer triggers first, don\u0026rsquo;t react on dismiss intent.\nConclusion So let\u0026rsquo;s try to mess up our UI. Let\u0026rsquo;s do a pull to refresh, dismiss snackbar and also let the timer do it\u0026rsquo;s thing:\n  As you can see in the video above: no matter how hard we try, the View displays the UI widgets properly because of the unidirectional data flow and state driven by business logic (View layer is stateless, View gets the state from underlying layer and just displays it). For example: we never see pull to refresh indicator and snackbar at the same time (except a small overlap while animating snackbar out).\nOf course this Snackbar example is very simplistic but I think it demonstrates the power of such architectural patterns like Model-View-Intent that take state management serious. It\u0026rsquo;s not too hard to imagine how well this pattern will work out for more complex screens and use cases.\nThe source code for this demo app can be found on Github.\nThis is a post in the Reactive Apps with Model-View-Intent series. Other posts in this series:\n  Reactive Apps with Model-View-Intent - Part 1: Model   Reactive Apps with Model-View-Intent - Part 2: View and Intent   Reactive Apps with Model-View-Intent - Part 3: State Reducer   Reactive Apps with Model-View-Intent - Part 4: Independent UI Components   Reactive Apps with Model-View-Intent - Part 5: Debugging with ease   Reactive Apps with Model-View-Intent - Part 6: Restoring State   Reactive Apps with Model-View-Intent - Part 7: Timing (SingleLiveEvent problem)   Reactive Apps with Model-View-Intent - Part 8: Navigation    ","permalink":"https://hannesdorfmann.com/android/mosby3-mvi-7/","tags":["android","software-architecture","design-patterns"],"title":"Reactive Apps with Model-View-Intent - Part 7: Timing (SingleLiveEvent problem)"},{"categories":["android"],"contents":"At I/O 2017 Google surprised us with a new initiative: Architecture Components. I really appreciate this initiative. In this blog post I would like to share my thoughts about ViewModel and some pitfalls you might stumble upon when using ViewModel and LiveData by taking a look at the official Google samples.\nThe State Problem It is not a secret that I\u0026rsquo;m a big fan of Model-View-Intent (MVI). This is just a matter of personal preference one could argue and I\u0026rsquo;m not disagreeing. I like MVI because state management, unidirectional data flow and immutability is a core part of the pattern. On the other hand MVVM and MVP don\u0026rsquo;t talk about state management although it can be (and should) applied in these patterns too. For example Laimonas Turauskas from Instacart wrote a blog post how they do state management in their MVP based app. Fortunately, Google\u0026rsquo;s MVVM samples show how to do that with ViewModel and LiveData too. Take a look at this example which is an app that let\u0026rsquo;s you browse Github. It\u0026rsquo;s a very simplified Github client that uses Githubs REST API to display some data about git repositories and users.\npublic enum Status { SUCCESS, ERROR, LOADING } public class Resource\u0026lt;T\u0026gt; { public final Status status; public final String message; public final T data; public Resource(@NonNull Status status, @Nullable T data, @Nullable String message) { this.status = status; this.data = data; this.message = message; } public static \u0026lt;T\u0026gt; Resource\u0026lt;T\u0026gt; success(@Nullable T data) { return new Resource\u0026lt;\u0026gt;(SUCCESS, data, null); } public static \u0026lt;T\u0026gt; Resource\u0026lt;T\u0026gt; error(String msg, @Nullable T data) { return new Resource\u0026lt;\u0026gt;(ERROR, data, msg); } public static \u0026lt;T\u0026gt; Resource\u0026lt;T\u0026gt; loading(@Nullable T data) { return new Resource\u0026lt;\u0026gt;(LOADING, data, null); } } A Resource is used for example to wrap a http response i.e. Resource\u0026lt;ApiResponse\u0026gt; (ApiResponse holds the json parsed data returned from github.com). Btw. if you use Kotlin, you should take a look at sealed classes.\nI\u0026rsquo;m super happy to see such state management related code in official Google samples and encourage developers to build your apps with proper state management in mind. However, in the same Google example we can scroll through a infinite list of search results (uses pagination). Some interesting observation:\npublic class SearchViewModel extends ViewModel { ... public LiveData\u0026lt;Resource\u0026lt;List\u0026lt;Repo\u0026gt;\u0026gt;\u0026gt; getResults() { ... } public LiveData\u0026lt;LoadMoreState\u0026gt; getLoadMoreStatus() { ... } } getResults() is used to represent the search results whereas getLoadingMoreStatus() is used for consecutive pagingation.\nWhy not just one LiveData\u0026lt;State\u0026gt; getState()? Wouldn\u0026rsquo;t it make state management especially in a multi threaded environment more predictable and deterministic?\nI\u0026rsquo;m not a purist but it leaves a stale after-taste \u0026hellip;\nThe mantra problem LiveData seems to be a very simplified version of RxJava\u0026rsquo;s Observable. LiveData is lifecycle aware so that we as developer don\u0026rsquo;t have to unsubscribe explicitly as we have to do with RxJava\u0026rsquo;s Observable. Both implement the Observer pattern. LiveData doesn\u0026rsquo;t provide all this fancy functional programming operators as RxJava does although architecture components provides some functional concepts via Transformations helper class such as Transformations.map() and Transformations.switchMap().\nQuite often I hear developers saying how much they like functional reactive programming and pure functions without side effects but then we write code like mutableLiveData.setValue(...).\nI\u0026rsquo;m not a purist but it leaves a stale after-taste \u0026hellip;\nThe state restoration race Rebecca Franks who seems to be working on a sample app (with LiveData and Architecture Components) asked an interesting question in a public slack chat about a Google TODO app example, more specific about the screen where the user can create a new TODO Task:\n Is there a reason why the Fragment passes information back to the ViewModel when calling saveTask(title, description). The ViewModel has the title and description already, so does that need to be passed into the saveTask(title, description) method explicitly?\n The code she is referring to can be found here. At first glance the answer seems to be obvious: \u0026ldquo;No, there is no reason to pass that information back from View to the ViewModel because the ViewModel already holds this information\u0026rdquo;. Is that always true?\nWell, ViewModel is \u0026ldquo;only\u0026rdquo; kept across screen orientation changes. On the other hand UI widgets like EditText store and restore their own state. Do you see the conflict potential? Just for fun, let\u0026rsquo;s also add android data binding into this equation: the problem is that data binding will override the value of the restored UI widget (Update: this problem might be addressed in the future).\nI\u0026rsquo;m not really answering Rebecca\u0026rsquo;s question because the previous answer that has seemed to be so obvious is actually not that obvious anymore. So which one is the source of truth? Should the ViewModel\u0026rsquo;s state be persisted too (see this post by Danny Preussler and official docs)? Which one wins the state restoration race?\nI\u0026rsquo;m not a purist but it leaves a stale after-taste \u0026hellip;\nThe \u0026ldquo;SingleLiveEvent\u0026rdquo; problem Fabio Collini raised another very interesting question about the Google\u0026rsquo;s sample github client app that is powered by the new Architecture Components:\n Sometimes the ViewModel needs to invoke an action using an Activity (for example to show a snack bar or to navigate to a new activity). Using MVP it\u0026rsquo;s easy to implement it because the presenter has a reference to the Activity. The ViewModel doesn\u0026rsquo;t contain a reference to the Activity, what\u0026rsquo;s the best way to implement this feature?\n What he means is an \u0026ldquo;action\u0026rdquo; that takes place only one time like displaying a SnackBar or a Toast. If you would model this problem in MVVM you would have a LiveData\u0026lt;String\u0026gt; getSnackBarErrorMessage() in your ViewModel and the View subscribes to it. If the emitted String (error message) is null, don\u0026rsquo;t display a SnackBar, otherwise display it. The problem he is facing is that this flag must be cleared somehow otherwise the SnackBar is shown again after a screen orientation change because LiveData is emitting the latest (cached) value when the view (re)subscribes to it.\nIn the Google samples they have added a class called SingleLiveEvent extends LiveData. The idea is that once an event has been dispatched it sets the internal value to null doesn\u0026rsquo;t dispatch the value (Update: I was wrong, it doesn\u0026rsquo;t set the value internally to null, thanks Jose Alcérreca for the hint). This prevents the SnackBar to appear a second time after screen orientation change.\nWell, SingleLiveEvent seems to solve this problem, but isn\u0026rsquo;t it just hiding the real underlying problem (hint: state management)?\nAdditionally, if we introduce something like a SingeLiveEvent because of showing something only once (i.e SnackBar) wouldn\u0026rsquo;t we then leak an implementation detail from the View Layer down to underlying layers like ViewModel or business logic? What if one day we would like to change the way such a message is displayed from SnackBar to TextView, which layers would we have to change? Only the View (UI) layer? Btw. I have commented on that issue too and suggested an alternative solution\nI\u0026rsquo;m not a purist but it leaves a stale after-taste \u0026hellip;\nConclusion: I\u0026rsquo;m a purist As you see, even in such small sample apps like a Github client or a TODO app we face some tricky edge cases. From my point of view this is not related to any particular architectural pattern. It doesn\u0026rsquo;t matter if you prefer MVVM with the new Architecture Components or MVP or MVI or whatever else. This kind of problems are just the symptoms of a much deeper issue we face but maybe haven\u0026rsquo;t thought about it yet: proper state management. I guess I am a purist when it comes to state management.\nGoogle\u0026rsquo;s Architecture Components are awesome and this blog post is by no means a critique on that great library nor on the examples Google (and many other external contributors) provided us. I just think that with the introduction of Architecture Components we (including Android Developers from around the world and Google Developers) have a very unique chance to create examples that can be considered as a reference implementation. These are great starting point for any Junior Android developer. By agreeing on the importance of state management, regardless if you are a purist or not, such a reference implementation could help a lot developers avoiding pain points in the future from lessons we have already learned the hard way in the past. Let\u0026rsquo;s reflect that in official Google examples. They are open source, let\u0026rsquo;s contribute!\n","permalink":"https://hannesdorfmann.com/android/arch-components-purist/","tags":null,"title":"Architecture Components - I'm not a purist but ..."},{"categories":["Android"],"contents":"In the previous blog posts we have discussed Model-View-Intent (MVI) and the importance of unidirectional data flow. That simplifies state restoration a lot. How and why? We will discuss that in this blog post.\nThere are two scenarios we will focus on in this blog post: Restoring state \u0026ldquo;in memory\u0026rdquo; (for example during screen orientation change) and restoring a \u0026ldquo;persistent state\u0026rdquo; (for example from Bundle previously saved in Activity.onSaveInstanceState()).\nIn Memory That is the simple case. We just have to keep our RxJava stream that emits new state over time out of android components lifecylce (i.e. Activity, Fragment or even ViewGroups). For example Mosby\u0026rsquo;s MviBasePresenter establishes such a RxJava stream internally by using PublishSubject for View intents and BehaviorSubject to render the state on the view. I have already described these implementation details at the end of Part 2. The main idea is that MviBasePresenter is such a component that lives outside View\u0026rsquo;s lifecylce so that a view can be attached and detached to such a Presenter. In Mosby the Presenter gets \u0026ldquo;destroyed\u0026rdquo; (garbage collected) when the view is destroyed permanently. Again, this is just an implementation detail of Mosby. Your MVI implementation might be entirely different. The important bit is that such a component like a Presenter lives outside of View\u0026rsquo;s lifecycle because then it\u0026rsquo;s easy to deal with View attached and detached events: whenever the View gets (re)attached to the Presenter we simply call view.render(previousState) (therefore Mosby uses BehaviorSubject internally). This is just one solution of how to deal with screen orientation changes. It also works with back stack navigation, i.e. Fragments on the back stack: if we come back from back stack we simply call view.render(previousState) again and the view is displaying the correct state. Actually, state can still be updated even if no view is attached because Presenter lives outside of that lifecycle and keeps RxJava state stream alive. Imagine receiving a push notification that changes data (part of state) while no view is attached. Again, whenever view gets reattached the latest state (containing updated data from push notification) is hand over to the view to render.\nPersistent State That scenario is also much simpler with a unidirectional data flow pattern like MVI. Let\u0026rsquo;s say we want that state of our View (i.e. Activity) not only survives in memory, but also through process death. Typically in Android one would use Activity.onSaveInstanceState(Bundle) to save that state. In contrast to MVP or MVVM where you not necessarily have a Model that represents state (see Part1 in MVI your View has a render(state) method which makes it easy to keep track of the latest state. So the obvious solution is to make state Parcelable and store it into the bundle and then restore it afterwards like this:\nclass MyActivity extends Activity implements MyView { private final static KEY_STATE = \u0026#34;MyStateKey\u0026#34;; private MyViewState lastState; @Override public void render(MyState state) { lastState = state; ... // update UI widgets  } @Override public void onSaveInstanceState(Bundle out){ out.putParcelable(KEY_STATE, lastState); } @Override public void onCreate(Bundle saved){ super.onCreate(saved); MyViewState initialState = null; if (saved != null){ initialState = saved.getParcelable(KEY_STATE); } presenter = new MyPresenter( new MyStateReducer(initialState) ); // With dagger: new MyDaggerModule(initialState)  } ... I think you get the point. Please note that in onCreate() we are not calling view.render(initialState) directly but rather we let the initial state sink down to where state management takes place: the state reducer (see Part 3 where we use it with .scan(initialState, reducerFunction).\nConclusion With a unidirectional data flow and a Model that represents State a lot of state related things are much simpler to implement compared to other patterns. However, usually I don\u0026rsquo;t persist state into a bundle in my apps for two reasons: First, Bundle has a size limit, so you can\u0026rsquo;t put arbitrary large state into a bundle (alternatively you could save state into a file or an object store like Realm). Second, we only have discussed how to serialize and deserialize state but that is not necessarily the same as restoring state.\nFor Example: Let\u0026rsquo;s assume we have a LCE (Loading-Content-Error) View that displays a loading indicator while loading data and a list of items once the data (items) is loaded. So the state would be like MyViewState.LOADING. Let\u0026rsquo;s assume that loading takes some time and that the Activity process gets killed while loading (i.e. because another app has come into foreground like phone app because of an incoming call). If we just serialize MyViewState.LOADING and deserialize it after Activity has been recreated as described above, our state reducer would just call view.render(MyViewState.LOADING) which is correct so far BUT we would actually never invoke loading data again (i.e. start http request) just by using the deserialized state blindly.\nAs you can see, serializing and deserializing state is not the same as state restoration which may requires some additional steps that increases complexity (still simpler to implement with MVI than with any other architectural pattern I have used so far). Also deserialized state containing some data might be outdated when View gets recreated so that you might have to refresh (load data) anyway. In most of the apps I have worked on I found it much simpler and more user friendly to keep state in memory only and after process death start with a empty initial state as if the app would start the first time. Ideally an app has a cache and offline support so that loading data after process death is fast.\nThat ultimately leads to a common belief I have had some hard debates about with other android developers: If I use a cache or store, I already have such a component that lives outside of the android component lifecycle and I don\u0026rsquo;t have to do all that retaining components stuff and MVI nonsense at all, right? Most of the time those android devs are referring to Mike Nakhimovich post Presenters are not for persisting where he introduced NyTimes Store, a data loading and caching library. Unfortunatley, those developers don\u0026rsquo;t understand that loading data and caching is NOT state management. For example what if I have to load data from 2 stores or caches?\nFinally, does caching libraries like NyTimes Store help us to deal with process death? Obviously not because process death can happen at any time. Deal with it. The only thing we can do is to beg android operating system not to kill our apps process because we still have some work to do by using android services (which is also such a component that lives outside of other android components lifecycles) or don\u0026rsquo;t we need android services anymore these days with RxJava, do we? We will talk about android services, RxJava and MVI in the next part. Stay tuned.\nSpoiler alert: I think we do need services.\nThis is a post in the Reactive Apps with Model-View-Intent series. Other posts in this series:\n  Reactive Apps with Model-View-Intent - Part 1: Model   Reactive Apps with Model-View-Intent - Part 2: View and Intent   Reactive Apps with Model-View-Intent - Part 3: State Reducer   Reactive Apps with Model-View-Intent - Part 4: Independent UI Components   Reactive Apps with Model-View-Intent - Part 5: Debugging with ease   Reactive Apps with Model-View-Intent - Part 6: Restoring State   Reactive Apps with Model-View-Intent - Part 7: Timing (SingleLiveEvent problem)   Reactive Apps with Model-View-Intent - Part 8: Navigation    ","permalink":"https://hannesdorfmann.com/android/mosby3-mvi-6/","tags":["android","software-architecture","design-patterns"],"title":"Reactive Apps with Model-View-Intent - Part 6: Restoring State"},{"categories":["Android"],"contents":"In the previous blog posts we have discussed the Model-View-Intent (MVI) pattern and it\u0026rsquo;s characteristics. In part 1 we have talked about the importance of an unidirectional data flow and application state that is driven by the \u0026ldquo;business logic\u0026rdquo;. In this blog post we will see how this pays off when it comes to debugging to simplify the life of developers.\nHave you ever got a crash report and you were not able to reproduce the bug? Sounds familiar? For me too! After having spend many hours looking at the stacktrace and our source code I gave up and have closed such issues in our issue tracker with a little comment like \u0026ldquo;can\u0026rsquo;t reproduce it\u0026rdquo; or \u0026ldquo;must be a strange device / manufacturer specific bug\u0026rdquo;.\nConcrete example from our shopping cart app we have developed in this blog post series: On the home screen the user of our app can do a pull-to-refresh and somehow, as the crash reports states, there is a NullPointerException thrown while loading the newest data triggered by pull-to-refresh.\nSo you as developer start the app and do a pull-to-refresh on the home screen but the app is not crashing. It\u0026rsquo;s working as expected. So you take a closer look at your code but you can\u0026rsquo;t see how a NullPointerException could be thrown there. You attach a debugger, go step by step through the code of the involved components, but still: it is working properly. How the hell can this app crash on a pull-to-refresh?\nThe problem is that you can\u0026rsquo;t reproduce the state before the crash happened. Wouldn\u0026rsquo;t it be nice if the user who had the crash could give you his app state (before the crash happened) along with the stacktrace in the crash report? With unidirectional data flow and Model-View-Intent this is super easy. We simply log all intents the user triggers and the model (model reflects the app state, a.k.a. view state) that is rendered on the view. Let\u0026rsquo;s do that for the home screen by adding logs in the HomePresenter (for more details about this class see part 3 where we have discussed the advantages of a state reducer). In the following code snippets we use Crashlytics but it should be possible to do the same with any other crash reporting tool.\nclass HomePresenter extends MviBasePresenter\u0026lt;HomeView, HomeViewState\u0026gt; { private final HomeViewState initialState; // Show loading indicator  public HomePresenter(HomeViewState initialState){ this.initialState = initialState; } @Override protected void bindIntents() { Observable\u0026lt;PartialState\u0026gt; loadFirstPage = intent(HomeView::loadFirstPageIntent) .doOnNext(intent -\u0026gt; Crashlytics.log(\u0026#34;Intent: load first page\u0026#34;)) .flatmap(...); // business logic calls to load data  Observable\u0026lt;PartialState\u0026gt; pullToRefresh = intent(HomeView::pullToRefreshIntent) .doOnNext(intent -\u0026gt; Crashlytics.log(\u0026#34;Intent: pull-to-refresh\u0026#34;)) .flatmap(...); // business logic calls to load data  Observable\u0026lt;PartialState\u0026gt; nextPage = intent(HomeView::loadNextPageIntent) .doOnNext(intent -\u0026gt; Crashlytics.log(\u0026#34;Intent: load next page\u0026#34;)) .flatmap(...); // business logic calls to load data  Observable\u0026lt;PartialState\u0026gt; allIntents = Observable.merge(loadFirstPage, pullToRefresh, nextPage); Observable\u0026lt;HomeViewState\u0026gt; stateObservable = allIntents .scan(initialState, this::viewStateReducer) // call the state reducer  .doOnNext(newViewState -\u0026gt; Crashlytics.log( \u0026#34;State: \u0026#34;+gson.toJson(newViewState) )); subscribeViewState(stateObservable, HomeView::render); // display new state  } private HomeViewState viewStateReducer(HomeViewState previousState, PartialState changes){ ... } } We simply add logging with RxJava\u0026rsquo;s .doOnNext() operator for every intent and to the \u0026ldquo;result\u0026rdquo; of each intent, the view state, which then will be rendered on the view. We serialize the view state as json (we will talk about that in a minute).\nNow our crash report looks like this:\nTake a look at the logs: Not only we see the latest state before the crash happened but we see the full history how the user reached this state. For better readability I have underlined the state transitions and replaced the \u0026ldquo;data\u0026rdquo; field (the items that are displayed in the recycler view) with [\u0026hellip;] . So the user started the app - load first page intent. Then the loading indicator is displayed \u0026ldquo;loadingFirstPage\u0026rdquo;:true and then the data has been loaded (data[\u0026hellip;]). Next the user scrolled through the list of items and reached the end of the RecyclerView which triggers a load next page intent to load more data (pagination), which causes a state transition to \u0026ldquo;loadingNextPage\u0026rdquo;:true. Once the next page is loaded the data (data[\u0026hellip;]) has been updated and \u0026ldquo;loadingNextPage\u0026rdquo;:false has been set properly. The user did the same (scroll down the RecyclerView and trigger a load next page intent) for a second time. And then he started a pull-to-refresh intent and the state transitions to \u0026ldquo;loadingPullToRefresh\u0026rdquo;:true. Suddenly the app crashes (no more logs afterwards).\nSo how does that information helps us to fix that bug? Obviously, we know which intents the user triggered, so we can do that manually to reproduce the bug. Moreover, we have snapshots of our app\u0026rsquo;s state (over time) as json. We can simply take the last state, deserialize the json and take this state as our initial state to fix that bug:\nString json =\u0026#34; {\\\u0026#34;data\\\u0026#34;:[...],\\\u0026#34;loadingFirstPage\\\u0026#34;:false,\\\u0026#34;loadingNextPage\\\u0026#34;:false,\\\u0026#34;loadingPullToRefresh\\\u0026#34;:false} \u0026#34;; HomeViewState stateBeforeCrash = gson.fromJson(json, HomeViewState.class); HomePresenter homePresenter = new HomePresenter(stateBeforeCrash); Then we attach a debugger and trigger the pull-to-refresh intent. It turns out that if the user has scrolled down the page 2 times no more data is available and our app didn\u0026rsquo;t handled that fact properly, so that a following pull-to-refresh causes the crash.\nConclusion Making app\u0026rsquo;s state \u0026ldquo;snapshotable\u0026rdquo; makes the life of us developers much easier. Not only that we are able to reproduce crashes easily, furthermore, we can take the serialized state to write regression tests with almost zero extra costs. Keep in mind that this is only possible if the app\u0026rsquo;s state follows the principle of an unidirectional data flow (driven by the business logic), immutability and pure functions. Model-View-Intent pushes us into that direction so that building \u0026ldquo;snapshotable\u0026rdquo; apps is a nice and useful side effect of this architecture.\nWhat are the downsides of \u0026ldquo;snapshotable\u0026rdquo; apps? Obviously we are serializing the apps state (i.e. with Gson). This adds some extra computation time. In an average sized app of mine this takes about 30 milliseconds for the first time the state gets serialized with Gson because Gson has to scan the classes by using reflections to determine the fields that have to be serialized. Consecutive state serialization takes about 6 milliseconds on average on a Nexus 4. Since serialization runs in .doOnNext() this typically runs on a background thread, but yes, a user of my app has to wait 6 milliseconds more than without snapshotting to see the new state on the screen. From my point of view that is not noticeable by an apps user. However, an issue with snapshotting the state is that on a crash the amount of data uploaded from the users device by the crash reporting tool to his server is significant bigger. No big deal if the user is connected over wifi, but could be an issue for the users mobile data plan. Last but not least, you may leak sensitive user data when attaching the state to a crash report. Either don\u0026rsquo;t serialize sensitive data which may cause that the state attached to the crash report is not complete (and therefore almost useless) or encrypt sensitive data (which may requires some extra cpu time).\nTo sum it up: I personally see a lot of advantages in snapshotting my app, however, you may have to make some tradeoffs. Maybe you start to enable snapshotting your app for your internal builds or beta builds to see how it works out for your app.\nBonus: Time Traveling Wouldn\u0026rsquo;t it be nice to have some kind of \u0026ldquo;time traveling\u0026rdquo; option during development. Maybe embedded in a debug-drawer like the one of Jake Wharton\u0026rsquo;s u2020 demo app:\nAll we need in such a debug-drawer are two buttons \u0026ldquo;previous state\u0026rdquo; and \u0026ldquo;next state\u0026rdquo; so that we can step by step travel back in time from one state to previous (or next) state. Obviously that requires some additional setup then just snapshotting our app\u0026rsquo;s state. For example: if we have made a HTTP request as part of a state transition we certainly don\u0026rsquo;t want to make the real HTTP request again while time traveling because data on backend side might have changed in the mean time.\nTime traveling requires some kind of extra layer like a proxy at the boundary of an app so that we can \u0026ldquo;record\u0026rdquo; and \u0026ldquo;replay\u0026rdquo; things like http requests (same for sqlite database etc.). Interested in something like that? It seems that my friend Felipe is working on something like that for OkHttp. Feel free to ping him to get more details about the library he is currently working on.\nWould you find useful an Android library that can record and replay OkHttp network interaction for, say Espresso tests?\n\u0026mdash; Felipe λima (@felipecsl) February 28, 2017  This is a post in the Reactive Apps with Model-View-Intent series. Other posts in this series:\n  Reactive Apps with Model-View-Intent - Part 1: Model   Reactive Apps with Model-View-Intent - Part 2: View and Intent   Reactive Apps with Model-View-Intent - Part 3: State Reducer   Reactive Apps with Model-View-Intent - Part 4: Independent UI Components   Reactive Apps with Model-View-Intent - Part 5: Debugging with ease   Reactive Apps with Model-View-Intent - Part 6: Restoring State   Reactive Apps with Model-View-Intent - Part 7: Timing (SingleLiveEvent problem)   Reactive Apps with Model-View-Intent - Part 8: Navigation    ","permalink":"https://hannesdorfmann.com/android/mosby3-mvi-5/","tags":["android","software-architecture","design-patterns"],"title":"Reactive Apps with Model-View-Intent - Part 5: Debugging with ease"},{"categories":["Android"],"contents":"In this blog post we will discuss how to build independent UI components and clarify why Parent-Child relations are a code smell in my opinion. Furthermore, we will discuss why I think such relations are needless.\nOne question that arises from time to time with architectural design patterns such as Model-View-Intent, Model-View-Presenter or Model-View-ViewModel is how do Presenters (or ViewModels) communicate with each other? Or even more specific: How does a \u0026ldquo;Child-Presenter\u0026rdquo; communicate with its \u0026ldquo;Parent-Presenter\u0026rdquo;?\nFrom my point of view such Parent-Child relations are a code smell, because they introduce a direct coupling between both Parent and Child, which leads to code that is hard to read, hard to maintain, where changing requirement affects a lot of components (hence it\u0026rsquo;s a virtually impossible task in large systems) and last but not least introduces shared state that is hard to predict and even harder to reproduce and debug.\nSo far so good, but somehow the information must flow from Presenter A to Presenter B: How does a Presenter communicate with another Presenter? They don\u0026rsquo;t! What would a Presenter have to tell another Presenter? Event X has happened? Presenters don\u0026rsquo;t have to talk to each other, they just observe the same Model (or the same part of the business logic to be precise). That\u0026rsquo;s how they get notified about changes: from the underlying layer.\nWhenever an Event X happens (i.e. a user clicked on a button in View 1), the Presenter lets that information sink down to the business logic. Since the other Presenters are observing the same business logic, they get notified by the business logic that something has changed (model has been updated).\nWe have already discussed the importance of this principle (unidirectional data flow) in the first part.\nLet\u0026rsquo;s implement this for a real world example: In our shopping app we can put items into the shopping basket. Additionally, there is a screen where we can see the content of our basket and we can select and remove multiple items at once.\n  Wouldn\u0026rsquo;t it be cool if we could split that big screen into multiple smaller, independent and reusable UI components. Let\u0026rsquo;s say a Toolbar, that displays the number of items that are selected, and a RecyclerView that actually displays the list of items in the shopping basket.\n\u0026lt;LinearLayout\u0026gt; \u0026lt;com.hannesdorfmann.SelectedCountToolbar android:id=\u0026#34;@+id/selectedCountToolbar\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;com.hannesdorfmann.ShoppingBasketRecyclerView android:id=\u0026#34;@+id/shoppingBasketRecyclerView\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; But how do these components communicate with each other? Obviously each component has its own Presenter: SelectedCountPresenter and ShoppingBasketPresenter. Is that a Parent-Child relation? No, both are just observing the same Model (updated from the same business logic):\npublic class SelectedCountPresenter extends MviBasePresenter\u0026lt;SelectedCountView, Integer\u0026gt; { private ShoppingCart shoppingCart; public SelectedCountPresenter(ShoppingCart shoppingCart) { this.shoppingCart = shoppingCart; } @Override protected void bindIntents() { subscribeViewState(shoppingCart.getSelectedItemsObservable(), SelectedCountView::render); } } class SelectedCountToolbar extends Toolbar implements SelectedCountView { ... @Override public void render(int selectedCount) { if (selectedCount == 0) { setVisibility(View.VISIBLE); } else { setVisibility(View.INVISIBLE); } } } The code for ShoppingBasketRecyclerView looks pretty much the same and therefore we skip that here. However, if we take a closer look at SelectedCountPresenter we notice that this Presenter is coupled to ShoppingCart. We would like to use the UI component also on other screens in our app. To make that component reusable we have to remove this dependency, which is actually an easy refactoring: The presenter gets an Observable\u0026lt;Integer\u0026gt; as Model through the constructor instead of ShoppingCart:\npublic class SelectedCountPresenter extends MviBasePresenter\u0026lt;SelectedCountView, Integer\u0026gt; { private Observable\u0026lt;Integer\u0026gt; selectedCountObservable; public SelectedCountPresenter(Observable\u0026lt;Integer\u0026gt; selectedCountObservable) { this.selectedCountObservable = selectedCountObservable; } @Override protected void bindIntents() { subscribeViewState(selectedCountObservable, SelectedCountToolbarView::render); } } Et voilà, we are able to use the SelectedCountToolbar component whenever we have to display the number of items currently selected. That can be the number of items in ShoppingCart but this UI component could also be used in an entirely different context and screen in your app. Moreover, this UI component could be put into a standalone library and used in another app like a photos app to display the number of selected photos.\nObservable\u0026lt;Integer\u0026gt; selectedCount = photoManager.getPhotos() .map(photos -\u0026gt; { int selected = 0; for (Photo item : photos) { if (item.isSelected()) selected++; } return selected; }); return new SelectedCountToolbarPresnter(selectedCount); Conclusion The aim of this blog post is to demonstrate that a Parent-Child relation is usually not needed at all and can be avoided by simply observing the same part of your business logic. No EventBus, no findViewById() from a parent Activity / Fragment, no presenter.getParentPresenter() or other workarounds are required. Just the observer pattern. With the help of RxJava, which basically implements the observer pattern, we are able to build such reactive UI components easily.\nAdditional thoughts In contrast to MVP or MVVM in MVI we are forced (in a positive way) that business logic drives the state of a certain component. Hence developers with more experience in MVI could come to the following conclusion:\n What if such a view state is the model of another component? What if a view state change of one component is an intent for another component?\n Example:\nObservable\u0026lt;Integer\u0026gt; selectedItemCountObservable = shoppingBasketPresenter .getViewStateObservable() .map(items -\u0026gt; { int selected = 0; for (ShoppingCartItem item : items) { if (item.isSelected()) selected++; } return selected; }); Observable\u0026lt;Boolean\u0026gt; doSomethingBecauseOtherComponentReadyIntent = shoppingBasketPresenter .getViewStateObservable() .filter(state -\u0026gt; state.isShowingData()) .map(state -\u0026gt; true); return new SelectedCountToolbarPresenter( selectedItemCountObservable, doSomethingBecauseOtherComponentReadyIntent); At first glance this seems like a valid approach, but isn\u0026rsquo;t it a variant of a Parent-Child relation? Sure, it\u0026rsquo;s not a traditional hierarchical Parent-Child relation, it\u0026rsquo;s more like an onion (the inner one offers a state to the outer one) which seems to be better, but still, a tightly coupled relation, isn\u0026rsquo;t it? I haven\u0026rsquo;t made up my mind but I think avoiding this onion-like relation is better for now. If you have a different opinion please leave a comment below. I would love to hear your thoughts.\nThis is a post in the Reactive Apps with Model-View-Intent series. Other posts in this series:\n  Reactive Apps with Model-View-Intent - Part 1: Model   Reactive Apps with Model-View-Intent - Part 2: View and Intent   Reactive Apps with Model-View-Intent - Part 3: State Reducer   Reactive Apps with Model-View-Intent - Part 4: Independent UI Components   Reactive Apps with Model-View-Intent - Part 5: Debugging with ease   Reactive Apps with Model-View-Intent - Part 6: Restoring State   Reactive Apps with Model-View-Intent - Part 7: Timing (SingleLiveEvent problem)   Reactive Apps with Model-View-Intent - Part 8: Navigation    ","permalink":"https://hannesdorfmann.com/android/mosby3-mvi-4/","tags":["android","software-architecture","design-patterns"],"title":"Reactive Apps with Model-View-Intent - Part 4: Independent UI Components"},{"categories":["Android"],"contents":"In the previous part we have discussed how to implement a simple screen with the Model-View-Intent pattern with an unidirectional data flow. In this blog post we are going to build a more complex screen with MVI with the help of a state reducer.\nIf you haven\u0026rsquo;t read part 2 yet, you should read that before continue with this blog post, because there is described how we connect the View via Presenter with the business logic and how data flows unidirectional.\nNow let\u0026rsquo;s build a more complex screen like this:\n  As you see in the video above this screen displays a list of items (products) grouped by category. The app only displays 3 items for each category and the user can click on a \u0026ldquo;load more button\u0026rdquo; to load all items of that category (http request). Additionally, the user can do pull-to-refresh and once the user has scrolled down to the end of the list more categories are loaded (pagination). Of course all this actions can be executed simultaneously and each of them could also fail (i.e. no internet connection).\nLet\u0026rsquo;s implement this step by step. First, let\u0026rsquo;s define the View interface.\npublic interface HomeView { /** * The intent to load the first page * * @return The value of the emitted item (boolean) can be ignored. true or false has no different meaning. */ public Observable\u0026lt;Boolean\u0026gt; loadFirstPageIntent(); /** * The intent to load the next page (pagination) * * @return The value of the emitted item (boolean) can be ignored. true or false has no different meaning. */ public Observable\u0026lt;Boolean\u0026gt; loadNextPageIntent(); /** * The intent to react on pull-to-refresh * * @return The value of the emitted item (boolean) can be ignored. true or false has no different meaning. */ public Observable\u0026lt;Boolean\u0026gt; pullToRefreshIntent(); /** * The intent to load more items from a given category * * @return Observable with the name of the category */ public Observable\u0026lt;String\u0026gt; loadAllProductsFromCategoryIntent(); /** * Renders the viewState */ public void render(HomeViewState viewState); } The concrete View implementation is pretty straight forward and therefore I won\u0026rsquo;t show the code here (can be found on github). Next let\u0026rsquo;s focus on the Model. As already said in previous posts the Model should reflect the State. So let\u0026rsquo;s introduce a Model called HomeViewState:\npublic final class HomeViewState { private final boolean loadingFirstPage; // Show the loading indicator instead of recyclerView  private final Throwable firstPageError; // Show an error view if != null  private final List\u0026lt;FeedItem\u0026gt; data; // The items displayed in the recyclerview  private final boolean loadingNextPage; // Shows the loading indicator for pagination  private final Throwable nextPageError; // if != null, shows error toast that pagination failed  private final boolean loadingPullToRefresh; // Shows the pull-to-refresh indicator  private final Throwable pullToRefreshError; // if != null, shows error toast that pull-to-refresh failed  // ... constructor ...  // ... getters ... } Note that FeedItem is just a interface every item has to implement that is displayable by the RecyclerView. For example Product implements FeedItem. Also the category title displayed in the recycler SectionHeader implements FeedItem. The UI element that indicates that more items of that category can be loaded is a FeedItem and holds internally it\u0026rsquo;s own little State to indicate whether or not we are loading more Items of a certain category:\npublic class AdditionalItemsLoadable implements FeedItem { private final int moreItemsAvailableCount; private final String categoryName; private final boolean loading; // if true then loading items is in progress  private final Throwable loadingError; // indicates an error has occurred while loading  // ... constructor ...  // ... getters ... And last but not least there is a business logic component HomeFeedLoader responsible to load FeedItems:\npublic class HomeFeedLoader { // Typically triggered by pull-to-refresh  public Observable\u0026lt;List\u0026lt;FeedItem\u0026gt;\u0026gt; loadNewestPage() { ... } //Loads the first page  public Observable\u0026lt;List\u0026lt;FeedItem\u0026gt;\u0026gt; loadFirstPage() { ... } // loads the next page (pagination)  public Observable\u0026lt;List\u0026lt;FeedItem\u0026gt;\u0026gt; loadNextPage() { ... } // loads additional products of a certain category  public Observable\u0026lt;List\u0026lt;Product\u0026gt;\u0026gt; loadProductsOfCategory(String categoryName) { ... } } Now let\u0026rsquo;s connect the dots step by step in our Presenter. Please note that some code shown here as part of the Presenter should rather be moved into an Interactor in a real world application (which I didn\u0026rsquo;t for the sake of better readability). First, lets start with loading the initial data:\nclass HomePresenter extends MviBasePresenter\u0026lt;HomeView, HomeViewState\u0026gt; { private final HomeFeedLoader feedLoader; @Override protected void bindIntents() { //  // In a real app some code here should rather be moved into an Interactor  //  Observable\u0026lt;HomeViewState\u0026gt; loadFirstPage = intent(HomeView::loadFirstPageIntent) .flatMap(ignored -\u0026gt; feedLoader.loadFirstPage() .map(items -\u0026gt; new HomeViewState(items, false, null) ) .startWith(new HomeViewState(emptyList, true, null) ) .onErrorReturn(error -\u0026gt; new HomeViewState(emptyList, false, error)) subscribeViewState(loadFirstPage, HomeView::render); } } So far so good, no big difference to how we have implemented the \u0026ldquo;search screen\u0026rdquo; as described in part 2. Now let\u0026rsquo;s try to add support for pull-to-refresh.\nclass HomePresenter extends MviBasePresenter\u0026lt;HomeView, HomeViewState\u0026gt; { private final HomeFeedLoader feedLoader; @Override protected void bindIntents() { //  // In a real app some code here should rather be moved into an Interactor  //  Observable\u0026lt;HomeViewState\u0026gt; loadFirstPage = ... ; Observable\u0026lt;HomeViewState\u0026gt; pullToRefresh = intent(HomeView::pullToRefreshIntent) .flatMap(ignored -\u0026gt; feedLoader.loadNewestPage() .map( items -\u0026gt; new HomeViewState(...)) .startWith(new HomeViewState(...)) .onErrorReturn(error -\u0026gt; new HomeViewState(...))); Observable\u0026lt;HomeViewState\u0026gt; allIntents = Observable.merge(loadFirstPage, pullToRefresh); subscribeViewState(allIntents, HomeView::render); } } Use Observable.merge() to merge together multiple intents.\nBut wait: feedLoader.loadNewestPage() only returns \u0026ldquo;newer\u0026rdquo; items but what about the previous items we have already loaded? In \u0026ldquo;traditional\u0026rdquo; MVP one would call something like view.addNewItems(newItems) but we have already discussed in part 1 why this is a bad idea (\u0026ldquo;The State Problem\u0026rdquo;). The problem we are facing now is that pull-to-refresh depends on the previous HomeViewState since we want to \u0026ldquo;merge\u0026rdquo; the previous items with the items returned from pull-to-refresh.\nLadies and Gentlemen please give a warm welcome to the STATE REDUCER\nState Reducer is a concept from functional programming that takes the previous state as input and computes a new state from the previous state like this:\npublic State reduce( State previous, Foo foo ){ State newState; // ... compute the new State by taking previous state and foo into account ...  return newState; } The idea is that such a reduce() function combines the previous state with foo to compute a new state. Foo typically represents the changes we want to apply to the previous state. In our case we want to \u0026ldquo;reduce\u0026rdquo; the previous HomeViewState (originally computed from loadFirstPageIntent) with the result from pull-to-refresh. Guess what, RxJava has an operator for that called scan(). Let\u0026rsquo;s refactor our code a little bit. We have to introduce another class representing the partial change (the thing we have called Foo in the previous code snipped) that will be used to compute the new state.\nclass HomePresenter extends MviBasePresenter\u0026lt;HomeView, HomeViewState\u0026gt; { private final HomeFeedLoader feedLoader; @Override protected void bindIntents() { //  // In a real app some code here should rather be moved into an Interactor  //  Observable\u0026lt;PartialState\u0026gt; loadFirstPage = intent(HomeView::loadFirstPageIntent) .flatMap(ignored -\u0026gt; feedLoader.loadFirstPage() .map(items -\u0026gt; new PartialState.FirstPageData(items) ) .startWith(new PartialState.FirstPageLoading(true) ) .onErrorReturn(error -\u0026gt; new PartialState.FirstPageError(error)) Observable\u0026lt;PartialState\u0026gt; pullToRefresh = intent(HomeView::pullToRefreshIntent) .flatMap(ignored -\u0026gt; feedLoader.loadNewestPage() .map( items -\u0026gt; new PartialState.PullToRefreshData(items) .startWith(new PartialState.PullToRefreshLoading(true))) .onErrorReturn(error -\u0026gt; new PartialState.PullToRefreshError(error))); Observable\u0026lt;PartialState\u0026gt; allIntents = Observable.merge(loadFirstPage, pullToRefresh); HomeViewState initialState = ... ; // Show loading first page  Observable\u0026lt;HomeViewState\u0026gt; stateObservable = allIntents.scan(initialState, this::viewStateReducer) subscribeViewState(stateObservable, HomeView::render); } private HomeViewState viewStateReducer(HomeViewState previousState, PartialState changes){ ... } } So what we did here is, that each Intent now returns an Observable\u0026lt;PartialState\u0026gt; rather then directly Observable\u0026lt;HomeViewState\u0026gt;. Then we merge them all into one observable stream with Observable.merge() and finally apply the reducer function (Observable.scan()). Basically what this means is that, whenever the user starts an intent, this intent will produce PartialState objects which then will be \u0026ldquo;reduced\u0026rdquo; to a HomeViewState that then eventually will be displayed in the View (HomeView.render(HomeViewState)). The only missing part is the state reducer function itself. The HomeViewState class itself hasn\u0026rsquo;t changed (scroll up to see the class definition), but we have added a Builder (Builder pattern) so that we can create new HomeViewState objects in a convenient way. So let\u0026rsquo;s implement the state reducer function:\nprivate HomeViewState viewStateReducer(HomeViewState previousState, PartialState changes){ if (changes instanceof PartialState.FirstPageLoading) return previousState.toBuilder() // creates a new copy by taking the internal values of previousState  .firstPageLoading(true) // show ProgressBar  .firstPageError(null) // don\u0026#39;t show error view  .build() if (changes instanceof PartialState.FirstPageError) return previousState.builder() .firstPageLoading(false) // hide ProgressBar  .firstPageError(((PartialState.FirstPageError) changes).getError()) // Show error view  .build(); if (changes instanceof PartialState.FirstPageLoaded) return previousState.builder() .firstPageLoading(false) .firstPageError(null) .data(((PartialState.FirstPageLoaded) changes).getData()) .build(); if (changes instanceof PartialState.PullToRefreshLoading) return previousState.builder() .pullToRefreshLoading(true) // Show pull to refresh indicator  .nextPageError(null) .build(); if (changes instanceof PartialState.PullToRefreshError) return previousState.builder() .pullToRefreshLoading(false) // Hide pull to refresh indicator  .pullToRefreshError(((PartialState.PullToRefreshError) changes).getError()) .build(); if (changes instanceof PartialState.PullToRefreshData) { List\u0026lt;FeedItem\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); data.addAll(((PullToRefreshData) changes).getData()); // insert new data on top of the list  data.addAll(previousState.getData()); return previousState.builder() .pullToRefreshLoading(false) .pullToRefreshError(null) .data(data) .build(); } throw new IllegalStateException(\u0026#34;Don\u0026#39;t know how to reduce the partial state \u0026#34; + changes); } I know, all these instanceof checks are not super pretty but that is not the point of this blog post. Why does technical bloggers write \u0026ldquo;ugly\u0026rdquo; code like the one shown above? It\u0026rsquo;s because we want to make a point on a certain topic without requiring the reader to have a full mental model of the source code i.e. of our shopping cart app nor prior knowledge of certain design patterns. Therefore, I think it is better to avoid design patterns in blog posts which would produce nicer code but may lead to harder readable blog posts. The focus of this blog post is set on state reducer. By looking at the state reducer with instanceof checks everybody can understand what the reducer does. Should you use instanceof checks in your app? No, use design patterns or other solutions like defining PartialState as interface with a method like public HomeViewState computeNewState(previousState). In general you may find RxSealedUnions by Paco Estevez useful when building apps with MVI.\nAlright, I think you get the idea how a state reducer works. Let\u0026rsquo;s implement the remaining features as well: Pagination and the ability to load more items of a certain category:\nclass HomePresenter extends MviBasePresenter\u0026lt;HomeView, HomeViewState\u0026gt; { private final HomeFeedLoader feedLoader; @Override protected void bindIntents() { //  // In a real app some code here should rather be moved to an Interactor  //  Observable\u0026lt;PartialState\u0026gt; loadFirstPage = ... ; Observable\u0026lt;PartialState\u0026gt; pullToRefresh = ... ; Observable\u0026lt;PartialState\u0026gt; nextPage = intent(HomeView::loadNextPageIntent) .flatMap(ignored -\u0026gt; feedLoader.loadNextPage() .map(items -\u0026gt; new PartialState.NextPageLoaded(items)) .startWith(new PartialState.NextPageLoading()) .onErrorReturn(PartialState.NexPageLoadingError::new)); Observable\u0026lt;PartialState\u0026gt; loadMoreFromCategory = intent(HomeView::loadAllProductsFromCategoryIntent) .flatMap(categoryName -\u0026gt; feedLoader.loadProductsOfCategory(categoryName) .map( products -\u0026gt; new PartialState.ProductsOfCategoryLoaded(categoryName, products)) .startWith(new PartialState.ProductsOfCategoryLoading(categoryName)) .onErrorReturn(error -\u0026gt; new PartialState.ProductsOfCategoryError(categoryName, error))); Observable\u0026lt;PartialState\u0026gt; allIntents = Observable.merge(loadFirstPage, pullToRefresh, nextPage, loadMoreFromCategory); HomeViewState initialState = ... ; // Show loading first page  Observable\u0026lt;HomeViewState\u0026gt; stateObservable = allIntents.scan(initialState, this::viewStateReducer) subscribeViewState(stateObservable, HomeView::render); } private HomeViewState viewStateReducer(HomeViewState previousState, PartialState changes){ // ... PartialState handling for First Page and pull-to-refresh as shown in previous code snipped ...  if (changes instanceof PartialState.NextPageLoading) { return previousState.builder().nextPageLoading(true).nextPageError(null).build(); } if (changes instanceof PartialState.NexPageLoadingError) return previousState.builder() .nextPageLoading(false) .nextPageError(((PartialState.NexPageLoadingError) changes).getError()) .build(); if (changes instanceof PartialState.NextPageLoaded) { List\u0026lt;FeedItem\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); data.addAll(previousState.getData()); // Add new data add the end of the list  data.addAll(((PartialState.NextPageLoaded) changes).getData()); return previousState.builder().nextPageLoading(false).nextPageError(null).data(data).build(); } if (changes instanceof PartialState.ProductsOfCategoryLoading) { int indexLoadMoreItem = findAdditionalItems(categoryName, previousState.getData()); AdditionalItemsLoadable ail = (AdditionalItemsLoadable) previousState.getData().get(indexLoadMoreItem); AdditionalItemsLoadable itemsThatIndicatesError = ail.builder() // creates a copy of the ail item  .loading(true).error(null).build(); List\u0026lt;FeedItem\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); data.addAll(previousState.getData()); data.set(indexLoadMoreItem, itemsThatIndicatesError); // Will display a loading indicator  return previousState.builder().data(data).build(); } if (changes instanceof PartialState.ProductsOfCategoryLoadingError) { int indexLoadMoreItem = findAdditionalItems(categoryName, previousState.getData()); AdditionalItemsLoadable ail = (AdditionalItemsLoadable) previousState.getData().get(indexLoadMoreItem); AdditionalItemsLoadable itemsThatIndicatesError = ail.builder().loading(false).error( ((ProductsOfCategoryLoadingError)changes).getError()).build(); List\u0026lt;FeedItem\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); data.addAll(previousState.getData()); data.set(indexLoadMoreItem, itemsThatIndicatesError); // Will display an error / retry button  return previousState.builder().data(data).build(); } if (changes instanceof PartialState.ProductsOfCategoryLoaded) { String categoryName = (ProductsOfCategoryLoaded) changes.getCategoryName(); int indexLoadMoreItem = findAdditionalItems(categoryName, previousState.getData()); int indexOfSectionHeader = findSectionHeader(categoryName, previousState.getData()); List\u0026lt;FeedItem\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); data.addAll(previousState.getData()); removeItems(data, indexOfSectionHeader, indexLoadMoreItem); // Removes all items of the given category  // Adds all items of the category (includes the items previously removed)  data.addAll(indexOfSectionHeader + 1,((ProductsOfCategoryLoaded) changes).getData()); return previousState.builder().data(data).build(); } throw new IllegalStateException(\u0026#34;Don\u0026#39;t know how to reduce the partial state \u0026#34; + changes); } } Implementing pagination (loading next \u0026ldquo;page\u0026rdquo; of items) is pretty the same as pull-to-refresh except that we are adding the loaded items at the end of the list instead of the top of the list as we do with pull-to-refresh. More interesting is how we deal with loading more items of a certain category. Well, for displaying a loading indicator and an error / retry button for a given category we only have to search for the corresponding AdditionalItemsLoadable object in the list of all FeedItems. Then we change that item to either show loading indicator or error / retry button. If we have loaded all items of a certain category successfully we search for the SectionHeader and AdditionalItemsLoadable and replace all items in between with the newly loaded items. That\u0026rsquo;s it.\nConclusion The aim of this blog post was to show you how a state reducer can help us to build complex screens with very little and understandable code. Just step back and think how you would have implemented that with \u0026ldquo;traditional\u0026rdquo; MVP or MVVM without a state reducer? The key to be able to use a state reducer is obviously that we have a Model class that is reflecting the State. Therefore, it was very important to understand what a Model actually is as described in the first part of this blog post series. Also, a state reducer can only be used if we are sure that the State (or Model to be precise) comes from a single source of truth. Therefore, a unidirectional data flow is very important. I hope that now it makes more sense why we have spend part 1 and part 2 on these topics and that you now got this \u0026ldquo;aha\u0026rdquo; moment where all the dots connect together. If not, no worries, it took quite some time for me too (and a lot of practice and a lot of mistakes and retries).\nYou may be wondering why we haven\u0026rsquo;t used a state reducer for the \u0026ldquo;Search Screen\u0026rdquo; (see part 2). State Reducer make mostly sense if we are depending on the previous state somehow. In the \u0026ldquo;Search Screen\u0026rdquo; we are not depending on the previous state.\nLast but not least, I would like to point out, if you haven\u0026rsquo;t noticed that yet (without going to much into details), that all our data is immutable (we always create a new HomeViewState, we never call a setter method on any object). Therefore, also mutli-threading is super easy. The user can start pull-to-refresh at the same time as loading the next page and load more items of a certain category because the state reducer is able to produce the correct state without depending on any particular order of the http responses. Additionally, we have written our code with pure functions, no side-effects. This makes our code super testable, reproducible, simple to reason about and highly parallelizable (mutli-threading).\nOf course state reducer wasn\u0026rsquo;t invented for MVI. You find the concept of a state reducer in many other libraries, frameworks and systems across multiple programming languages. A state reducer fits perfectly into the philosophy of Model-View-Intent with an unidirectional data flow and a Model representing the State.\nIn the next part we are focusing on how to build reusable and reactive UI components with MVI.\nThis is a post in the Reactive Apps with Model-View-Intent series. Other posts in this series:\n  Reactive Apps with Model-View-Intent - Part 1: Model   Reactive Apps with Model-View-Intent - Part 2: View and Intent   Reactive Apps with Model-View-Intent - Part 3: State Reducer   Reactive Apps with Model-View-Intent - Part 4: Independent UI Components   Reactive Apps with Model-View-Intent - Part 5: Debugging with ease   Reactive Apps with Model-View-Intent - Part 6: Restoring State   Reactive Apps with Model-View-Intent - Part 7: Timing (SingleLiveEvent problem)   Reactive Apps with Model-View-Intent - Part 8: Navigation    ","permalink":"https://hannesdorfmann.com/android/mosby3-mvi-3/","tags":["android","software-architecture","design-patterns"],"title":"Reactive Apps with Model-View-Intent - Part 3: State Reducer"},{"categories":["Android"],"contents":"In the first part we have discussed what a Model actually is, the relation to State and how a well defined Model can solve some common issues in android development. In this blog post we continue our journey towards \u0026ldquo;Reactive Apps\u0026rdquo; by introducing the Model-View-Intent pattern to build Reactive Apps.\nIf you haven\u0026rsquo;t read part 1 yet, you should read that before continue with this blog post. To summarize: Rather then writing code like this (for example in \u0026ldquo;traditional\u0026rdquo; MVP)\nclass PersonsPresenter extends Presenter\u0026lt;PersonsView\u0026gt; { public void load(){ getView().showLoading(true); // Displays a ProgressBar on the screen  backend.loadPersons(new Callback(){ public void onSuccess(List\u0026lt;Person\u0026gt; persons){ getView().showPersons(persons); // Displays a list of Persons on the screen  } public void onError(Throwable error){ getView().showError(error); // Displays a error message on the screen  } }); } } we should create a \u0026ldquo;Model\u0026rdquo; that reflects the \u0026ldquo;State\u0026rdquo;:\nclass PersonsModel { // In a real application fields would be private  // and we would have getters to access them  final boolean loading; final List\u0026lt;Person\u0026gt; persons; final Throwable error; public(boolean loading, List\u0026lt;Person\u0026gt; persons, Throwable error){ this.loading = loading; this.persons = persons; this.error = error; } } And then the Presenter could be implemented like this:\nclass PersonsPresenter extends Presenter\u0026lt;PersonsView\u0026gt; { public void load(){ getView().render( new PersonsModel(true, null, null) ); // Displays a ProgressBar  backend.loadPersons(new Callback(){ public void onSuccess(List\u0026lt;Person\u0026gt; persons){ getView().render( new PersonsModel(false, persons, null) ); // Displays a list of Persons  } public void onError(Throwable error){ getView().render( new PersonsModel(false, null, error) ); // Displays a error message  } }); } } Now the View has a Model which then will be \u0026ldquo;rendered\u0026rdquo; on the screen simply by invoking render(personsModel). In the first part we also talked about the importance of an unidirectional data flow and that your business logic should drive this model. Before we start to connect the dots lets quickly discuss the main idea of MVI.\nModel-View-Intent (MVI) This pattern was specified by André Medeiros (Staltz) for a JavaScript framework he has written called cycle.js. From a theoretical (and mathematical) point of view we could describe Model-View-Intent as follows:\n intent(): This function takes the input from the user (i.e. UI events, like click events) and translate it to \u0026ldquo;something\u0026rdquo; that will be passed as parameter to model() function. This could be a simple string to set a value of the model to or more complex data structure like an Object. We could say we have the intention to change the model with an intent. model(): The model() function takes the output from intent() as input to manipulate the Model. The output of this function is a new Model (state changed). So it should not update an already existing Model. We want immutability! In the first part I gave a concrete example with a \u0026ldquo;counter app\u0026rdquo;. Again, we don\u0026rsquo;t change an already existing Model object instance. We create a new Model according to the changes described by the intent. Please note, that the model() function is the only piece of your code that is allowed to create a new Model object. Then this new immutable Model is the output of this function. Basically, the model() function calls our apps business logic (could be an Interactor, Usecase, Repository \u0026hellip; whatever pattern / terminology you use in your app) and delivers a new Model object as result. view(): This method takes the model returned from model() function and gives it as input to the view() function. Then the View simply displays this Model somehow. view() is basically the same as view.render(model).  But we want to build a \u0026ldquo;Reactive App\u0026rdquo;, don\u0026rsquo;t we? So how is MVI \u0026ldquo;reactive\u0026rdquo;? What does \u0026ldquo;reactive\u0026rdquo; actually means in this context? With \u0026ldquo;reactive\u0026rdquo; we mean apps with a UI that reacts on state changes. Since \u0026ldquo;State\u0026rdquo; is reflected by a \u0026ldquo;Model\u0026rdquo; essentially we want that our Business logic \u0026ldquo;reacts\u0026rdquo; on input events (intents) and produces a \u0026ldquo;Model\u0026rdquo; as output which then can be displayed in the View by calling view\u0026rsquo;s render(model) method.\nConnecting the dots with RxJava We want that our data flows unidirectional. Here comes RxJava into play. Do we need RxJava to build reactive apps with an unidirectional data flow or MVI based apps? No, we could also write imperative and procedural code. However, RxJava is very good for event based programming. Since UI are event based too using RxJava makes a lot of sense.\nIn this blog post we are going to build a simple app for a fictional online shop. We make http requests to a backend to load products that we display in the app. We can search for certain products and add products into a shopping basket. Overall the final app looks like this:\n  The source code can be found on github. Let\u0026rsquo;s start by implementing a simple screen: Let\u0026rsquo;s implement the search. First, we define a Model which at the end is displayed by the View as described in Part 1 of this blog post series. In this blog post series we give all our Model classes a \u0026ldquo;ViewState\u0026rdquo; suffix, i.e. our Model class for the screen to search for products in our online shop app is called SearchViewState because the Model reflects the State. Also alternative names like SearchModel sounds a little bit strange or SearchViewModel could lead to confusion with MVVM. Naming is hard.\npublic interface SearchViewState { /** * The search has not been stared yet */ final class SearchNotStartedYet implements SearchViewState { } /** * Loading: Currently waiting for search result */ final class Loading implements SearchViewState { } /** * Indicates that the search has delivered an empty result set */ final class EmptyResult implements SearchViewState { private final String searchQueryText; public EmptyResult(String searchQueryText) { this.searchQueryText = searchQueryText; } public String getSearchQueryText() { return searchQueryText; } } /** * A valid search result. Contains a list of items that have matched the searching criteria. */ final class SearchResult implements SearchViewState { private final String searchQueryText; private final List\u0026lt;Product\u0026gt; result; public SearchResult(String searchQueryText, List\u0026lt;Product\u0026gt; result) { this.searchQueryText = searchQueryText; this.result = result; } public String getSearchQueryText() { return searchQueryText; } public List\u0026lt;Product\u0026gt; getResult() { return result; } } /** * Indicates that an error has occurred while searching */ final class Error implements SearchViewState { private final String searchQueryText; private final Throwable error; public Error(String searchQueryText, Throwable error) { this.searchQueryText = searchQueryText; this.error = error; } public String getSearchQueryText() { return searchQueryText; } public Throwable getError() { return error; } } } Since Java is a strongly typed language we have chosen a type safe approach for our Model class by splitting each \u0026ldquo;sub-state\u0026rdquo; in its own class. Our business logic returns an object of type SearchViewState which could be an instance of SearchViewState.Error etc. This is just a personal preference. We could have also modeled this entirely different, for example:\nclass SearchViewState { Throwable error; // if not null, an error has occurred  boolean loading; // if true loading data is in progress  List\u0026lt;Product\u0026gt; result; // if not null this is the result of the search  boolean SearchNotStartedYet; // if true, we have the search not started yet } Again, how you model your Models is just a matter of personal preferences. If you use the kotlin programming language then sealed classes are a great choice.\nNext, let\u0026rsquo;s focus on the Business Logic. Let\u0026rsquo;s introduce a SearchInteractor which is responsible to execute the search. As already said the \u0026ldquo;output\u0026rdquo; is a SearchViewState object.\npublic class SearchInteractor { final SearchEngine searchEngine; // Makes http calls  public Observable\u0026lt;SearchViewState\u0026gt; search(String searchString) { // Empty String, so no search  if (searchString.isEmpty()) { return Observable.just(new SearchViewState.SearchNotStartedYet()); } // search for products  return searchEngine.searchFor(searchString) // Observable\u0026lt;List\u0026lt;Product\u0026gt;\u0026gt;  .map(products -\u0026gt; { if (products.isEmpty()) { return new SearchViewState.EmptyResult(searchString); } else { return new SearchViewState.SearchResult(searchString, products); } }) .startWith(new SearchViewState.Loading()) .onErrorReturn(error -\u0026gt; new SearchViewState.Error(searchString, error)); } } Let\u0026rsquo;s take a look at the method signature of SearchInteractor.search(): We have String searchString as input parameter and Observable\u0026lt;SearchViewState\u0026gt; as output. This already hints that we expect that arbitrary many instances of SearchViewState are emitted on this observable stream over time. startWith() says before we are actually starting the search query (via SearchEngine which executes the http request) we emit SearchViewState.Loading. At the end this will force the View to display a ProgressBar while executing the search.\nonErrorReturn() catches any Exceptions that may occur while executing the search and emits a SearchViewState.Error. Couldn\u0026rsquo;t we just use the onError callback when we subscribe to this Observable? This is a common misunderstanding in RxJava: the error callback is meant to be used when the whole observable stream runs into an unrecoverable error and therefore the observable stream terminates. In our case an error like no active internet connection is not an unrecoverable error. It is yet just another state represented by our Model. Furthermore, we can move to another state afterwards i.e. once the an active internet connection is available we can move to the \u0026ldquo;loading state\u0026rdquo; represented by SearchViewState.Loading . So we establish an observable stream from our business logic to our view emitting a changed Model every time the \u0026ldquo;State\u0026rdquo; changes. We certainly don\u0026rsquo;t want to terminate this observable stream on a internet connection error. Therefore, such errors are handled as a State (rather than a fatal error that terminates the stream) which is reflected by the Model and emitted to the observable stream when an error occurs. Usually in MVI the Model Observable never terminates (never reaches the subscriber\u0026rsquo;s onComplete() or onError() ).\nTo sum it up: SearchInteractor (business logic) offers an observable stream Observable\u0026lt;SearchViewState\u0026gt; and emits a new SearchViewState every time the state changes.\nNext let\u0026rsquo;s discuss how our View layer looks like. What should the View do? Well, obviously the view should display the Model. We have agreed that the View should have a function like render(model). Additionally, the view should offer a way for other layers to react on user input events. These are called intents in MVI. In our case there is only one intent: the user can search for a product by typing a String into a input field. We implement MVI in a similar way to MVP. It is good practice in MVP to define a interface for the View layer so let\u0026rsquo;s do this in MVI too.\npublic interface SearchView { /** * The search intent * * @return An observable emitting the search query text */ Observable\u0026lt;String\u0026gt; searchIntent(); /** * Renders the View * * @param viewState The current viewState state that should be displayed */ void render(SearchViewState viewState); } In this case our View only offers one intent but in general a View could offer multiple intents. In part 1 we have discussed why a single render() function is a nice approach, if it is unclear why we should prefer a single render() you should read part 1 again (or leave a comment below; see also comment section in part 1). Before we start with the concrete implementation of the View layer, let\u0026rsquo;s take a look how the final result should look like:\n  public class SearchFragment extends Fragment implements SearchView { @BindView(R.id.searchView) android.widget.SearchView searchView; @BindView(R.id.container) ViewGroup container; @BindView(R.id.loadingView) View loadingView; @BindView(R.id.errorView) TextView errorView; @BindView(R.id.recyclerView) RecyclerView recyclerView; @BindView(R.id.emptyView) View emptyView; private SearchAdapter adapter; @Override public Observable\u0026lt;String\u0026gt; searchIntent() { return RxSearchView.queryTextChanges(searchView) // Thanks Jake Wharton :)  .filter(queryString -\u0026gt; queryString.length() \u0026gt; 3 || queryString.length() == 0) .debounce(500, TimeUnit.MILLISECONDS); } @Override public void render(SearchViewState viewState) { if (viewState instanceof SearchViewState.SearchNotStartedYet) { renderSearchNotStarted(); } else if (viewState instanceof SearchViewState.Loading) { renderLoading(); } else if (viewState instanceof SearchViewState.SearchResult) { renderResult(((SearchViewState.SearchResult) viewState).getResult()); } else if (viewState instanceof SearchViewState.EmptyResult) { renderEmptyResult(); } else if (viewState instanceof SearchViewState.Error) { renderError(); } else { throw new IllegalArgumentException(\u0026#34;Don\u0026#39;t know how to render viewState \u0026#34; + viewState); } } private void renderResult(List\u0026lt;Product\u0026gt; result) { TransitionManager.beginDelayedTransition(container); recyclerView.setVisibility(View.VISIBLE); loadingView.setVisibility(View.GONE); emptyView.setVisibility(View.GONE); errorView.setVisibility(View.GONE); adapter.setProducts(result); adapter.notifyDataSetChanged(); } private void renderSearchNotStarted() { TransitionManager.beginDelayedTransition(container); recyclerView.setVisibility(View.GONE); loadingView.setVisibility(View.GONE); errorView.setVisibility(View.GONE); emptyView.setVisibility(View.GONE); } private void renderLoading() { TransitionManager.beginDelayedTransition(container); recyclerView.setVisibility(View.GONE); loadingView.setVisibility(View.VISIBLE); errorView.setVisibility(View.GONE); emptyView.setVisibility(View.GONE); } private void renderError() { TransitionManager.beginDelayedTransition(container); recyclerView.setVisibility(View.GONE); loadingView.setVisibility(View.GONE); errorView.setVisibility(View.VISIBLE); emptyView.setVisibility(View.GONE); } private void renderEmptyResult() { TransitionManager.beginDelayedTransition(container); recyclerView.setVisibility(View.GONE); loadingView.setVisibility(View.GONE); errorView.setVisibility(View.GONE); emptyView.setVisibility(View.VISIBLE); } } The render(SearchViewState) method should be self explaining. In searchIntent() we use Jake Wharton\u0026rsquo;s RxBindings library that provides RxJava bindings like Observable for Android UI widget. RxSearchView.queryText() creates an Observable\u0026lt;String\u0026gt; that emits the search string every time the user types something into the EditText UI widget. We use filter() to only start a search query if the user has typed in more than 3 characters and we don\u0026rsquo;t want hit the backend every time the user types in a new character but rather we want to wait until the user has finished typing (debounce() waits 500 milliseconds to determine if the user has finished typing).\nSo we know that the \u0026ldquo;input\u0026rdquo; for this screen is the searchIntent() and that render() is the \u0026ldquo;output\u0026rdquo;. How do we get from \u0026ldquo;input\u0026rdquo; to \u0026ldquo;output\u0026rdquo;? The following video visualizes that:\n  The remaining question is who or how do we connect the View\u0026rsquo;s intent with the business logic? If you take a closer look at the video from above you will see that there is a flatMap() operator in the middle. This already hints us that there is an additional component involved we haven\u0026rsquo;t talked about yet: a Presenter. The Presenter is responsible to connect the dots similar as we would use a presenter in MVP.\npublic class SearchPresenter extends MviBasePresenter\u0026lt;SearchView, SearchViewState\u0026gt; { private final SearchInteractor searchInteractor; @Override protected void bindIntents() { Observable\u0026lt;SearchViewState\u0026gt; search = intent(SearchView::searchIntent) .switchMap(searchInteractor::search) // I have used flatMap() in the video above, but switchMap() makes more sense here  .observeOn(AndroidSchedulers.mainThread()); subscribeViewState(search, SearchView::render); } } Please node that SearchView::searchIntent is just a Java 8 shorthand for searchView.searchIntent()\nWhat is MviBasePresenter and what are intent() and subscribeViewState()? This class is part of a library I have written called Mosby (Mosby 3.0 has a MVI module). This blog post is not about Mosby but I want briefly talk about how MviBasePresenter works to convince you that there is no black magic involved although I have to admit that at first glance it looks like that. Let\u0026rsquo;s start with lifecycle: MviBasePresenter doesn\u0026rsquo;t really have a lifecyle. There is a bindIntent() method where you bind the intents from the View to the business logic. Typically, you use flatMap() or switchMap() or concatMap() to \u0026ldquo;forward\u0026rdquo; an intent to the business logic. This method is invoked only the first time a View is attached to the Presenter. It\u0026rsquo;s not invoked again when the View gets reattached (i.e. after a screen orientation change).\nThat may sounds a bit strange and one may ask: \u0026ldquo;Does MviBasePresenter even survive screen orientation changes and if yes how does Mosby ensures that the observable stream remains without leaking the memory?\u0026rdquo; This is what intent() and subscribeViewState() are for. intent() creates a PublishSubject internally and uses that one as \u0026ldquo;gateway\u0026rdquo; to your business logic. So actually this PublishSubject is subscribing to View\u0026rsquo;s intent Observable. Calling intent(o1) actually returns a PublishSubject which is subscribed to o1.\nOn orientation change Mosby detaches the View from Presenter but only unsubscribes this internal PublishSubject temporarily from the View and resubscribes the PublishSubject to the View\u0026rsquo;s intent when the view gets reattached to the presenter.\nsubscribeViewState() does the same but the other way around (Presenter to View communication). It creates internally a BehaviorSubject as \u0026ldquo;gateway\u0026rdquo; from business logic to View. Since it\u0026rsquo;s a BehaviorSubject we can receive \u0026ldquo;model updates\u0026rdquo; from business logic even if no view is attached at the moment (i.e. View is on the back stack). BehaviorSubjects always keep the latest value it has received and replays that once the View gets reattached.\nThe rule is simple: use intent() to \u0026ldquo;wrap\u0026rdquo; any intent of the view. Use subscribeViewState() instead of Observable.subscribe(\u0026hellip;).\nThe counter part to bindIntent() is unbindIntents() which is invoked exactly one time the View is destroyed permanently. For instance putting a fragment on the back stack doesn\u0026rsquo;t destroy the View permanently, but finishing an Activity does. Since intent() and subscribeViewState() already take care of subscription management you only barely need to implement unbindIntents().\nWhat about other lifecycle events like onPause() or onResume()? I still think that Presenters don\u0026rsquo;t need lifecycle Events. However, if you really think you need them you can simply see a lifecycle event like onPause() as an intent. Your View could offer a pauseIntent() which is triggered by android lifecycle instead of a user interaction intent like clicking on a button. But both are valid intents.\nConclusion In this second part we have talked about the basics of Model-View-Intent and implemented a very simple screen by using MVI to get our feet wet. Maybe this example is too simple so that you don\u0026rsquo;t fully see yet the benefits of MVI pattern, a Model which represents State and the unidirectional data flow compared to \u0026ldquo;traditional\u0026rdquo; MVP or MVVM. There is nothing wrong with MVP or MVVM and I\u0026rsquo;m not saying that MVI is better than other architectural patterns. However, I think that MVI helps us to write elegant code for complex problems as we will see in the next part (Part 3) of this blog series when we are going to talk about state reducers.\nThis is a post in the Reactive Apps with Model-View-Intent series. Other posts in this series:\n  Reactive Apps with Model-View-Intent - Part 1: Model   Reactive Apps with Model-View-Intent - Part 2: View and Intent   Reactive Apps with Model-View-Intent - Part 3: State Reducer   Reactive Apps with Model-View-Intent - Part 4: Independent UI Components   Reactive Apps with Model-View-Intent - Part 5: Debugging with ease   Reactive Apps with Model-View-Intent - Part 6: Restoring State   Reactive Apps with Model-View-Intent - Part 7: Timing (SingleLiveEvent problem)   Reactive Apps with Model-View-Intent - Part 8: Navigation    ","permalink":"https://hannesdorfmann.com/android/mosby3-mvi-2/","tags":["android","software-architecture","design-patterns"],"title":"Reactive Apps with Model-View-Intent - Part 2: View and Intent"},{"categories":["Android"],"contents":"Once I have figured out that I have modeled my Model classes wrong all the time, a lot of issues and headache I previously had with some Android platform related topics are gone. Moreover, finally I was able to build Reactive Apps using RxJava and Model-View-Intent (MVI) as I never was able before although the apps I have built so far are reactive too but not on the same level of reactiveness as I\u0026rsquo;m going to describe in this blog post series. In the first part I would like to talk about Model and why Model matters.\nSo what do I mean with \u0026ldquo;modeled Models in a wrong way\u0026rdquo;? Well, there are a lot of architectural patterns out there to separate the \u0026ldquo;View\u0026rdquo; from your \u0026ldquo;Model\u0026rdquo;. The most popular ones, at least in Android development, are Model-View-Controller (MVC), Model-View-Presenter (MVP) and Model-View-ViewModel (MVVM). Do you notice something by just looking at the name of these patterns? They all talk about a \u0026ldquo;Model\u0026rdquo;. I realized that most of the time I didn\u0026rsquo;t have a Model at all.\nExample: Just load a list of persons from a backend. A \u0026ldquo;traditional\u0026rdquo; MVP implementation could look like this:\nclass PersonsPresenter extends Presenter\u0026lt;PersonsView\u0026gt; { public void load(){ getView().showLoading(true); // Displays a ProgressBar on the screen  backend.loadPersons(new Callback(){ public void onSuccess(List\u0026lt;Person\u0026gt; persons){ getView().showPersons(persons); // Displays a list of Persons on the screen  } public void onError(Throwable error){ getView().showError(error); // Displays a error message on the screen  } }); } } But where or what is the \u0026ldquo;Model\u0026rdquo;? Is it the backend? No, that is business logic. Is it the result List\u0026lt;Person\u0026gt;? No, that is just one thing our View displays amongst others like a loading indicator or an error message. So, what actually is the \u0026ldquo;Model\u0026rdquo;?\nFrom my point of view there should be a \u0026ldquo;Model\u0026rdquo; class like this:\nclass PersonsModel { // In a real application fields would be private  // and we would have getters to access them  final boolean loading; final List\u0026lt;Person\u0026gt; persons; final Throwable error; public(boolean loading, List\u0026lt;Person\u0026gt; persons, Throwable error){ this.loading = loading; this.persons = persons; this.error = error; } } And then the Presenter could be implemented like this:\nclass PersonsPresenter extends Presenter\u0026lt;PersonsView\u0026gt; { public void load(){ getView().render( new PersonsModel(true, null, null) ); // Displays a ProgressBar  backend.loadPersons(new Callback(){ public void onSuccess(List\u0026lt;Person\u0026gt; persons){ getView().render( new PersonsModel(false, persons, null) ); // Displays a list of Persons  } public void onError(Throwable error){ getView().render( new PersonsModel(false, null, error) ); // Displays a error message  } }); } } Now the View has a Model which then will be \u0026ldquo;rendered\u0026rdquo; on the screen. This concept is not really something new. The original MVC definition by Trygve Reenskaug from 1979 had quite a similar concept: The View observes the Model for changes. Unfortunately, the term MVC has been (mis)used to describe too many different patterns that are not really the same what Reenskaug formulated in 1979. For instance, backend developers use MVC frameworks, iOS has ViewController and what does MVC on Android actually mean? Activities are Controller? What is a ClickListener then? Nowadays the term MVC is just a big mistake, misusage and misinterpretation of what Reenskaug originally formulated. But let\u0026rsquo;s stop this discussion about MVC here, this could run out of control.\nLet\u0026rsquo;s come back to what I have claimed at the beginning. Having a \u0026ldquo;Model\u0026rdquo; solves a lot of issues we quite often struggle with in Android development:\n The State Problem Screen orientation changes Navigation on the back stack Process death Immutability and unidirectional data flow Debuggable and reproducible states Testability  Let\u0026rsquo;s discuss these points and let\u0026rsquo;s see how \u0026ldquo;traditional\u0026rdquo; implementations of MVP and MVVM deal with these problems and finally how a \u0026ldquo;Model\u0026rdquo; can help to prevent common pitfalls.\n1. The State Problem Reactive Apps - this is a buzzword, isn\u0026rsquo;t it? With that I mean are apps with a UI that react on state changes. Ah, here we have another nice word: \u0026ldquo;State\u0026rdquo;. What is \u0026ldquo;State\u0026rdquo;? Well, most of the time we describe \u0026ldquo;State\u0026rdquo; as what we see on the screen, like \u0026ldquo;loading state\u0026rdquo; when the View displays a ProgressBar. Therein lies the crux: we frontend developers tend to be focused on UI. That is not necessarily a bad thing because at the end of the day a good UI decides whether or not a User will use our app and therefore how successful an app is. But take a look at the very basic MVP code example from above (not the one using PersonsModel). Here the state of the UI is coordinated by the Presenter, since the Presenter tells the View what to display. The same is true for MVVM. In this blog post I want to distinguish between two MVVM implementations: The first one with Android\u0026rsquo;s data binding and the second option using RxJava. In MVVM with data binding the state directly sits in the ViewModel:\nclass PersonsViewModel { ObservableBoolean loading; // ... Other fields left out for better readability  public void load(){ loading.set(true); backend.loadPersons(new Callback(){ public void onSuccess(List\u0026lt;Person\u0026gt; persons){ loading.set(false); // ... other stuff like set list of persons  } public void onError(Throwable error){ loading.set(false); // ... other stuff like set error message  } }); } } In MVVM with RxJava we don\u0026rsquo;t use the data binding engine but bind Observable to UI Widgets in the View, for example:\nclass RxPersonsViewModel { private PublishSubject\u0026lt;Boolean\u0026gt; loading; private PublishSubject\u0026lt;List\u0026lt;Person\u0026gt; persons; private PublishSubject loadPersonsCommand; public RxPersonsViewModel(){ loadPersonsCommand.flatMap(ignored -\u0026gt; backend.loadPersons()) .doOnSubscribe(ignored -\u0026gt; loading.onNext(true)) .doOnTerminate(ignored -\u0026gt; loading.onNext(false)) .subscribe(persons) // Could also be implemented entirely different  } // Subscribed to in View (i.e. Activity / Fragment)  public Observable\u0026lt;Boolean\u0026gt; loading(){ return loading; } // Subscribed to in View (i.e. Activity / Fragment)  public Observable\u0026lt;List\u0026lt;Person\u0026gt;\u0026gt; persons(){ return persons; } // Whenever this action is triggered (calling onNext() ) we load persons  public PublishSubject loadPersonsCommand(){ return loadPersonsCommand; } } Of course these code snippets are not perfect and your implementation may look entirely different. The point is that usually in MVP and MVVM the state is driven by either the Presenter or the ViewModel.\nThis leads to the following observations:\n The business logic has its own state, the Presenter (or ViewModel) has its own state (and you try to sync the state of business logic and Presenter so that both have the same state) and the View may also have its own state (i.e. you set the visibility somehow directly in the View, or Android itself restores the state from bundle during recreation). A Presenter (or ViewModel) has arbitrarily many inputs (the View triggers an action handled by Presenter) which is ok, but a Presenter also has many outputs (or output channels like view.showLoading() or view.showError() in MVP or ViewModel is offering multiple Observables) which eventually leads to conflicting states of View, Presenter and business logic especially when working with multiple threads.  In the best-case scenario, this only results in visual bugs such as displaying a loading indicator (\u0026ldquo;loading state\u0026rdquo;) and error indicator (\u0026ldquo;error state\u0026rdquo;) at the same time like this:\n  In the worst-case scenario, you have a serious bug reported to you from a crash reporting tool like Crashlytics, that you are not able to reproduce and therefore making it almost impossible to fix.\nWhat if we only have one single source of truth for state passed from bottom (business logic) to the top (the View). Actually, we have already seen a similar concept at the very beginning of this blog post when we talked about \u0026ldquo;Model\u0026rdquo;.\nclass PersonsModel { // In a real world application those fields would be private  // and we would have getters to access them  final boolean loading; final List\u0026lt;Person\u0026gt; persons; final Throwable error; public(boolean loading, List\u0026lt;Person\u0026gt; persons, Throwable error){ this.loading = loading; this.persons = persons; this.error = error; } } Guess what? Model reflects the State. Once I have understood this, a lot of state related issues were solved (and prevented from the very beginning) and suddenly my Presenter has exactly one output: getView().render(PersonsModel). This reflects a simple mathematical function like f(x) = y (also possible with multiple inputs i.e. f(a,b,c), exactly one output). Math might not be everyone\u0026rsquo;s cup of tea, but a mathematician doesn\u0026rsquo;t know what a bug is. Software Engineers do.\nUnderstanding what a \u0026ldquo;Model\u0026rdquo; is and how to model it properly is important, because at the end a Model can solve the \u0026ldquo;State Problem\u0026rdquo;\n2. Screen orientation changes In Android screen orientation change is a challenging problem. The simplest way to deal with that is to ignore it. Just reload everything on each screen orientation change. This is a completely valid solution. Most of the time your app works offline too so that data comes from a local database or another local cache. Therefore, loading data is super-fast after screen orientation changes. However, I personally dislike seeing a loading indicator, even if it\u0026rsquo;s just for a few milliseconds, because in my opinion this is not a seamless user experience. So people (including myself) started to use MVP with \u0026ldquo;retaining presenter\u0026rdquo; so that a View can be detached (and destroyed) during screen orientation changes, whereas the Presenter survives in memory and then the View gets reattached to the Presenter. The same concept is possible with MVVM with RxJava, but we have to keep in mind that once a View gets unsubscribed from his ViewModel the observable stream is destroyed. You could work around this with Subjects for example. In MVVM with data binding a ViewModel is directly bound to the View by the data binding engine himself. To avoid memory leaks we have to destroy the ViewModel on screen orientation changes.\nBut the problem with retaining Presenter (or ViewModel) is: how do we bring the View\u0026rsquo;s state back to the same state as it was before the screen orientation change, so that both, View and Presenter, are in the same state again? I have written a MVP library called Mosby with a feature called ViewState which basically synchronizes the state of your business logic with the View. Moxy, another MVP library, implemented a quite interesting solution by using \u0026ldquo;commands\u0026rdquo; to reproduce the View\u0026rsquo;s state after a screen orientation change:\n  Image borrowed from https://github.com/Arello-Mobile/Moxy\n  I\u0026rsquo;m pretty sure that there are also other solutions for the View\u0026rsquo;s state problem out there. Let\u0026rsquo;s take a step back and summarize the issue those libraries try to solve: They try to solve the problem of state which we have already discussed.\nSo, again, having one \u0026ldquo;Model\u0026rdquo; which reflects the current \u0026ldquo;State\u0026rdquo; and exactly one method to \u0026ldquo;render\u0026rdquo; the \u0026ldquo;Model\u0026rdquo; solves this problem as easy as calling getView().render(PersonsModel) (with the latest Model when reattaching the View to Presenter).\n3. Navigation on the back stack Does a Presenter (or ViewModel) need to be kept when the View is not in use anymore? For instance, if the Fragment (View) has been replaced with another Fragment because the user has navigated to another screen, then there is no View attached to the Presenter. If no View is attached a Presenter obviously can\u0026rsquo;t update the View with the latest data from business logic. What if the user comes back (i.e. pressing the back button to pop the back stack)? Reload the data or reuse the existing Presenter? This is more a philosophical question. Usually once the user comes back to a previous screen (pop back stack) he would expect to continue where he left off. This is basically the \u0026ldquo;restore View\u0026rsquo;s state problem\u0026rdquo; as discussed in 2. So the solution is straightforward: With a \u0026ldquo;Model\u0026rdquo; representing the state we just call getView().render(PersonsModel) to render the View when coming back from back stack.\n4. Process death I think it is a common misunderstanding in Android development that process death is a bad thing and that we need libraries that help us to restore state (and Presenters or ViewModels) after process death. First, a process death only ever happens for a good reason: the Android operating system needs more resources for other apps or to save battery. But this will never happen when your app is in the foreground and is being actively used by your app\u0026rsquo;s user. So be a good citizen and don\u0026rsquo;t fight against the platform. If you really have some long running work to do in the background use a Service as this is the only way to signal the operating system that your app is still \u0026ldquo;actively used\u0026rdquo;. If a process death happens Android provides some callbacks like onSaveInstanceState() to save the state. Again, State. Should we save our View information into the Bundle? Does the Presenter have its own state we have to save into the bundle too? What about business logic state? We already had this dance: As described in 1. 2. and 3. we only need a Model class that is representing the whole state. Then it\u0026rsquo;s easy to save this Model into a bundle and to restore it afterwards. However, I personally think that most of the time it is better to not save the state but rather reload the whole screen just like we are doing on first app start. Think of a NewsReader app displaying a list of news articles. When our app is killed and we save the state and 6 hours later the user reopens our app and the state is restored, our app may display outdated content. Maybe not storing the Model / State and simply reloading the data is better in this scenario.\n5. Immutability and unidirectional data flow I\u0026rsquo;m not going to talk about the advantage of immutability because there are a lot of resources available about this topic. We want an immutable \u0026ldquo;Model\u0026rdquo; (which is representing the state). Why? Because we want only one single source of truth. We don\u0026rsquo;t want that other components in our app can manipulate our Model / State as we pass the Model object around. Let\u0026rsquo;s imagine we are going to write a simple \u0026ldquo;counter\u0026rdquo; Android app that has an increment and decrement button and displays the current counter value in a TextView. If our Model (which in this case is just the counter value - an integer) is immutable, how do we change the counter? I\u0026rsquo;m glad you asked. We are not manipulating the TextView directly on each button click. Some observations: First, our View should just have a view.render(\u0026hellip;). Second, our model is immutable, so no direct change of Model is possible. Third, there is only one single source of truth: the business logic. We let click events \u0026ldquo;sink down\u0026rdquo; to the business logic. The business logic knows the current Model (i.e. has a private field with the current Model) and will create a new Model with the incremented / decremented value according to the old Model.\nBy doing so we have established a unidirectional data flow with the business logic as single source of truth which creates immutable Model instances. But this seems so over engineered for just a simple counter, doesn\u0026rsquo;t it? Yes, a counter is just a simple app. Most apps start as a simple app but then the complexity grows fast. A unidirectional data flow and an immutable model is necessary from my point of view even for simple apps to ensure they stay simple (from developers point of view) when complexity grows.\n6. Debuggable and reproducible states Moreover, the unidirectional data flow ensures that our app is easy to debug. Wouldn\u0026rsquo;t it be nice next time we get a crash report from Crashlytics that we could reproduce and fix this crash easily because all required information is attached to that crash report. What is \u0026ldquo;the required information\u0026rdquo;? Well, all information we need is the current Model and the action the user wanted to perform when the crash happened (i.e. clicked decrement Button). That\u0026rsquo;s all we need to reproduce this crash and that information is super easy to log and to attach to a crash report. This would not be as easy without a unidirectional data flow (i.e. someone misuses an EventBus and fires CounterModels out into the wild) or without immutability (so that we are not sure who has actually changed the Model).\n7. Testability \u0026ldquo;Traditional\u0026rdquo; MVP or MVVM improves testability of an app. MVC is also testable: nobody ever said that we have to put all our business logic into the activity. With a Model representing State we can simplify our unit test\u0026rsquo;s code as we can simply check assertEquals(expectedModel, model). This eliminates a lot of objects we otherwise have to mock. Additionally, this removes many verification tests that a certain method has been called i.e. Mockito.verify(view, times(1)).showFoo(). Eventually, this makes our unit test\u0026rsquo;s code more readable, understandable and finally maintainable as we don\u0026rsquo;t have to deal that much with implementation details of our real code.\nConclusion In this first part of this blog post series we talked a lot about theoretical stuff. Do we really need a dedicated blog post about Model? I think it is elementary to understand that a Model is important and helps to prevent some issues we otherwise would struggle with. Model doesn\u0026rsquo;t mean business logic. It\u0026rsquo;s the business logic (i.e. an Interactor, a Usecase, a Repositor or whatever you call it in your app) that produces a Model. In the second part we will see this theoretical Model stuff in action when we finally build a reactive app with Model-View-Intent. The demo app we are going to build is a app for a fictional online shop. Here is just a short preview demo of what you can expect in part two. Stay tuned.\nThis is a post in the Reactive Apps with Model-View-Intent series. Other posts in this series:\n  Reactive Apps with Model-View-Intent - Part 1: Model   Reactive Apps with Model-View-Intent - Part 2: View and Intent   Reactive Apps with Model-View-Intent - Part 3: State Reducer   Reactive Apps with Model-View-Intent - Part 4: Independent UI Components   Reactive Apps with Model-View-Intent - Part 5: Debugging with ease   Reactive Apps with Model-View-Intent - Part 6: Restoring State   Reactive Apps with Model-View-Intent - Part 7: Timing (SingleLiveEvent problem)   Reactive Apps with Model-View-Intent - Part 8: Navigation    ","permalink":"https://hannesdorfmann.com/android/mosby3-mvi-1/","tags":["android","software-architecture","design-patterns"],"title":"Reactive Apps with Model-View-Intent - Part 1: Model"},{"categories":["android"],"contents":"Use interfaces for java development they said. It will be more flexible they said. Well, that all might be true but for library projects that doesn\u0026rsquo;t necessarily has to be true as well. In this post I will explain you why I have switched from interface to an abstract class as base class in one of my library projects called AdapterDelegates 3.0.\nTo give you some background information: AdapterDelegates is a small library I have written to create composable Adapters for Android\u0026rsquo;s RecyclerView (favor composition over inheritance). I have described the idea and the reason why we need such a library in a previous blog post: Joe\u0026rsquo;s great adapter hell escape.\nAdapterDelegates (before version 3.0) had an interface called AdapterDelegate like this:\n/** * @param \u0026lt;T\u0026gt; the type of adapters data source i.e. List\u0026lt;Foo\u0026gt; */ public interface AdapterDelegate\u0026lt;T\u0026gt; { /** * Called to determine whether this AdapterDelegate is the responsible for the given data * element. * * @param items The data source of the Adapter * @param position The position in the datasource * @return true, if this item is responsible, otherwise false */ public boolean isForViewType(T items, int position); /** * Creates the {@link RecyclerView.ViewHolder} for the given data source item * * @param parent The ViewGroup parent of the given datasource * @return The new instantiated {@link RecyclerView.ViewHolder} */ @NonNull public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent); /** * Called to bind the {@link RecyclerView.ViewHolder} to the item of the datas source set * * @param items The data source * @param position The position in the datasource * @param holder The {@link RecyclerView.ViewHolder} to bind */ public void onBindViewHolder(T items, int position, RecyclerView.ViewHolder holder); } So for every view type you want to display in a RecyclerView you had to define your own class implementing AdapterDelegate interface and then you could plug-in multiple AdapterDelegates into a RecyclerView\u0026rsquo;s Adapter to display different kind of items (view types). Moreover, you could reuse the same AdapterDelegate for multiple Adapters.\nclass vs. interface One may ask: Why have you defined interface AdapterDelegate\u0026lt;T\u0026gt; and not simply class AdapterDelegate\u0026lt;T\u0026gt;? Well, an AdapterDelegate is just a contract (or a protocol) that says this methods have to be implemented. That is exactly what interfaces are good for. Furthermore, we should program against interfaces, right? Instead of writing your classes in a way that says \u0026ldquo;I depend on this specific class to do my work\u0026rdquo; with interfaces it\u0026rsquo;s more like \u0026ldquo;I depend on any class that does this stuff to do my work\u0026rdquo;. By doing so we don\u0026rsquo;t rely on implementation details, are more flexible and loosely coupled.\ninterface vs. abstract class That is a little bit more tricky although the same arguments as in the \u0026ldquo;class vs. interface\u0026rdquo; paragraph from above are still valid. I would like to add that an abstract class let you define some behaviors and forces your subclasses to provide others (abstract methods). Unfortunately that is also a problem at the same time. Inheritance (in contrast to implementing an interface) might introduce a shared state and behavior relation between super class and subclass because the state of the overall object relies on implementation of both, the super class and the subclass. Moreover, that means that if your are extending from an abstract class and you are not implementing the abstract methods as intended by the author of the super class (which might not be you) you may break internal state and behavior of your subclass. What I\u0026rsquo;m trying to say is: if you don\u0026rsquo;t know all the implementation details of your super class, you can\u0026rsquo;t be sure that your subclass is working correctly. I\u0026rsquo;m pretty sure you have extended from abstract classes and have implemented the missing abstract methods before but have you ever checked the source code of the super class to be sure that your implementation of those abstract methods are as intended by the author of the super class? By the way, the source code of a super class could have been changed with every update. You might have to look at the source code again to verify that your subclass implementation still conforms with the intention of the super class.\nAbstract classes allow default implementations With that said, you are wondering why I have switched from interface AdapterDelegate\u0026lt;T\u0026gt; to abstract class AdapterDelegate\u0026lt;T\u0026gt; in AdapterDelegates version 3.0, aren\u0026rsquo;t you? For a library abstract classes do make sense if your libraries public API changes frequently and if you are not under full control of how and when the API will be changed.\nThat is exactly the case for my AdapterDelegates library. I depend on the RecyclerView\u0026rsquo;s Adapter API which, obviously, is not designed nor maintained by me. Concrete example: Few releases back a new method onBindViewHolder(VH holder, int position, List payloads) has been added to RecyclerView.Adapter class to support payloads. AdapterDelegates 2.0 interface only contained the method signature onBindViewHolder(VH holder, int position) (without payloads). If I want to add this method to interface AdapterDelegate\u0026lt;T\u0026gt; in version 2.1 everybody using my library would have to go into his source code and implement this method too. Otherwise his / her code wouldn\u0026rsquo;t compile.\nWhat if you decide to update your app to version 2.1 (with payload support) but a third party library of your app still depends on version 2.0 (without payload support)?\nThen your code will compile but your app will crash at runtime. Why? Because the third party library is already compiled. Hence, no compile time error will be thrown but gradle will pack version 2.1 (can\u0026rsquo;t pack both 2.1 and 2.0 in the same apk, therefore uses the newer one) into your final android APK file. When invoking onBindViewHolder(VH holder, int position, List payloads) on a third party library component a NoSuchMethodError will be thrown at runtime. The android SDK faces the same issue. LINT warns you to add a check like if (Build.VERSION.SDK_INT \u0026gt;= 21) but there is no such mechanism for libraries packed in your code.\nTo avoid such problems Jake Wharton suggested to change package name and maven group id in his blog post Java Interoperability Policy for Major Version Updates. That is a very good strategy you should follow when publishing your own library. But what is a major version update? In my case, every time RecyclerView\u0026rsquo;s Adapter API changes that would be a major version update for my AdapterDelegates library too because I may have to add new methods to the interface AdapterDelegate\u0026lt;T\u0026gt;. That wouldn\u0026rsquo;t be very convenient for the users of my library.\nTherefore, I have decided to switch to abstract class AdapterDelegate\u0026lt;T\u0026gt; because most likely the development team behind RecyclerView will add new methods to introduce new optional features. At least that was the case in the past. By using abstract class instead of an interface I can add this methods \u0026ldquo;silently\u0026rdquo; in a minor version update (not major version update) by providing a default implementation, which abstract classes allow me to do, but interfaces don\u0026rsquo;t (before java 8, available in android starting at API level 24).\nNow you may roll your eyes and ask: What about all that inheritance shared state and behavior nonsense you told me before and that I can\u0026rsquo;t be sure that by inheriting from a super class I am not breaking something without checking the source code of the super class.\nWell, that still is true. However, I as a library developer restrict myself to define abstract class AdapterDelegate\u0026lt;T\u0026gt; just like I would define an interface by using abstract methods except the fact that for newer optional features I will provide an empty default implementation:\npublic abstract class AdapterDelegate\u0026lt;T\u0026gt; { protected abstract boolean isForViewType(T items, int position); protected abstract RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent); protected abstract void onBindViewHolder(T items, int position, RecyclerView.ViewHolder holder, List\u0026lt;Object\u0026gt; payloads); protected boolean onFailedToRecycleView(RecyclerView.ViewHolder holder) { return false; } protected void onViewAttachedToWindow(@NonNull RecyclerView.ViewHolder holder) { } protected void onViewDetachedFromWindow(RecyclerView.ViewHolder holder) { } } So you, as user of this library, can checkout the source code and understand easily that there is no shared state or behavior with your own subclass.\nTL;DR: For a library project it is okay to use abstract class instead of interface, if you restrict yourself to design abstract classes like interfaces and only add empty default implementations but no default implementation that changes state or behavior of this class (and in consequence of all subclasses).\nPlease note that this is very specific to library projects and not a general advise to prefer abstract classes over interfaces. Furthermore, please note that there no one size fits all. I\u0026rsquo;m just sharing my personal experience I have faced while maintaining and developing libraries.\n","permalink":"https://hannesdorfmann.com/android/library-abstract-class/","tags":["java"],"title":"Why a library developer should use abstract class instead of interface"},{"categories":["Android"],"contents":"A listener from our podcast, The Context, that Artem Zinnatullin and I run asked me, if I can give him an example of the Repository Pattern. So I googled around and stumbled upon some blog posts and found out that the term Repository Pattern is used and described in many different ways. In this blog post I want give you a brief history of the Repository Pattern and I want to discuss why I think the Repository Pattern could lead to over abstraction and over engineering.\nBefore we get started, I wanted to say that the term Repository Pattern is used and defined in different ways in different contexts and different programming languages. Therefore, I split this post into two parts: In the first part I want to discuss why I think the \u0026ldquo;original\u0026rdquo; definition of the Repository Pattern is an over engineered abstraction you very very rarely need and in the second part I want to show a common and popular definition of the Repository Pattern that may be a better choice for the average use case.\nThe original Repository Pattern As far as I know the repository pattern was first introduced by Martin Fowler et al. in the book Patterns of Enterprise Application Architecture. This blog post by Krzychu Kosobudzki or this blog post Christian Panadero give an example of the usage of this pattern in the context of android development. In my opinion the original repository pattern is an over engineered abstraction layer you very very rarely need. Especially on Android. What do I mean with over engineered? Let\u0026rsquo;s have a look at the example from Krzychu Kosobudzki\u0026rsquo;s blog post:\ninterface Repository\u0026lt;T\u0026gt; { void add(T item); void remove(Specification specification); List\u0026lt;T\u0026gt; query(Specification specification); } What is the Specification type? Basically Specification is just an interface like this:\ninterface Specification { } interface SqlSpecification extends Specification { String toSqlQuery(); } Then we could have concrete Specification to query all list of News from SQLite database, ordered by date, like this:\nclass NewestNewsesSqlSpecification implements SqlSpecification { @Override public String toSqlQuery() { return String.format( \u0026#34;SELECT * FROM %1$s ORDER BY `%2$s` DESC;\u0026#34;, NewsTable.TABLE_NAME, NewsTable.Fields.DATE ); } } Another example of a Specification looks as follows:\npublic class NewsByIdSqlSpecification implements SqlSpecification { private int id; public NewsByIdSpecification(final int id) { this.id = id; } @Override public String toSqlQuery() { return String.format( \u0026#34;SELECT * FROM %1$s WHERE `%2$s` = %3$d\u0026#39;;\u0026#34;, NewsTable.TABLE_NAME, NewsTable.Fields.ID, id ); } } And then use that components like this:\npublic class NewsSqlRepository implements Repository\u0026lt;News\u0026gt; { @Override public List\u0026lt;News\u0026gt; query(Specification specification) { SqlSpecification sqlSpecification = (SqlSpecification) specification; SQLiteDatabase database = openHelper.getReadableDatabase(); List\u0026lt;News\u0026gt; newses = new ArrayList\u0026lt;\u0026gt;(); Cursor cursor = database.rawQuery(sqlSpecification.toSqlQuery()); for (int i = 0, size = cursor.getCount(); i \u0026lt; size; i++) { cursor.moveToPosition(i); newses.add(toNewsMapper.map(cursor)); } cursor.close(); return newses; } } Again, all code snippets shown above are borrowed from Krzychu Kosobudzki blog post.\nUsually you use NewsRepository i.e. in your Presenter (MVP) or use case / interactor if you are following the clean architecture like this: newsRepository.query(new NewestNewsesSqlSpecification()).\nSo far so good. Before we continue, I want to ask you two essential questions:\nFirst question: Why and when do we use the repository pattern? I want to link to the book Patterns of Enterprise Application Architecture by Martin Fowler et al.\n The Repository will carry out the appropriate operations behind the scenes. Conceptually, a Repository encapsulates the set of objects persisted in a data store and the operations performed over them, providing a more object-oriented view of the persistence layer. Repository also supports the objective of achieving a clean separation and one-way dependency between the domain and data mapping layers.\n Second Question: What are the benefits of abstractions like Specification?\n Single responsibility: This class is responsible to create a \u0026ldquo;criteria\u0026rdquo;. In the case of NewestNewsesSqlSpecification this criteria is translated to an SQL string. Hide implementation details: The SQL Statement is hidden in NewestNewsesSqlSpecification, so that no other class has to know about SQL at all. We can reuse Specifications: Imagine a Specification with a SQL WHERE clause. We could define such a Specification once and reuse it whenever we need a different WHERE clause based specification. Open / Closed principle: As Krzychu Kosobudzki pointed out correctly, this allows to create new specifications (and therefore new functionality) without having to touch something else in your code base.  What are the disadvantages with that extra abstraction layer? Well, now whoever calls newsRepository.query(new NewestNewsesSqlSpecification()) has to know which Specification to pass in. That is not a problem per se, but developers begin to over abstract that pattern. For example, Krzychu Kosobudzki says that with the repository pattern we can change concrete implementation as requirements changes. He gives the example of using Realm instead of SQLite database:\npublic class NewsRealmRepository implements Repository\u0026lt;News\u0026gt; { @Override public List\u0026lt;News\u0026gt; query(Specification specification) { RealmSpecification realmSpecification = (RealmSpecification) specification; Realm realm = Realm.getInstance(realmConfiguration); RealmResults\u0026lt;NewsRealm\u0026gt; realmResults = realmSpecification.toRealmResults(realm); List\u0026lt;News\u0026gt; newses = new ArrayList\u0026lt;\u0026gt;(); for (NewsRealm news : realmResults) { newses.add(toNewsMapper.map(news)); } realm.close(); return newses; } } As you see there is another subtype of Specification for Realm:\npublic interface RealmSpecification extends Specification { RealmResults\u0026lt;NewsRealm\u0026gt; toRealmResults(Realm realm); } public class NewsByIdSpecification implements RealmSpecification { private final int id; public NewsByIdSpecification(final int id) { this.id = id; } @Override public RealmResults\u0026lt;NewsRealm\u0026gt; toRealmResults(Realm realm) { return realm.where(NewsRealm.class) .equalTo(NewsRealm.Fields.ID, id) .findAll(); } } The problem is that whoever calls newsRepository.query(\u0026hellip;) has to know whether it has to pass in a NewestNewsesSqlSpecification or NewestNewsesRealmSpecification. So is it really that easy to change your implementation from SQLite to Realm? No, it\u0026rsquo;s not because you have to change the specifications everywhere from FooSqlSpecification to FooRealmSpecification. There is also one big code smell coming along with this:\n@Override public List\u0026lt;News\u0026gt; query(Specification specification) { SqlSpecification sqlSpecification = (SqlSpecification) specification; ... } @Override public List\u0026lt;News\u0026gt; query(Specification specification) { RealmSpecification realmSpecification = (RealmSpecification) specification; ... } Whenever you are programming against an interface but you have to cast an interface to a concrete class, in 95% of the time you are doing something wrong!\nMartin Fowler et al. didn\u0026rsquo;t make a statement about Repository Pattern and changing concrete implementation (i.e. SQLite to Realm). Fowler et al, described the repository pattern as\n adding this layer helps minimize duplicate query logic.\n So the original definition of the repository pattern is all about minimizing duplicate query logic and not necessarily to build an abstraction layer to change the underlying database.\nI don\u0026rsquo;t want to blame anybody. This is not a Android related problem, we also see that quite often in Java EE world, especially in spring framework powered backends.\nEvolution of the Repository Pattern term In android development the term Repository Pattern is quite often used in combination with Clean Architecture. So did Fernando Cejas in his excellent blog post Architecting Android…The clean way? (scroll down to \u0026ldquo;Data layer\u0026rdquo; section). Interesting enough, he also links to the original definition of the Repository Pattern by Martin Fowler et al. However, Fernando Cejas says:\n All data needed for the application comes from this layer through a Repository implementation (the interface is in the domain layer) that uses a Repository Pattern with a strategy that, through a factory, picks different data sources depending on certain conditions.\n  The idea behind all this is that the data origin is transparent for the client, which does not care if the data is coming from memory, disk or the cloud, the only truth is that the data will arrive and will be got.\n As you can see here, the term Repository Pattern is used to describe something slightly different. You can see it even more clear if you check out Fernando\u0026rsquo;s Clean Architecture Sample Project on Github. In his sample he uses RxJava. For my blog post I have removed RxJava in the code snippets below for better understanding if you don\u0026rsquo;t have prior RxJava knowledge. I have also simplified the code a little bit to focus on the important things. For example Fernando wants to load an User by his id:\ninterface UserRepository { User user(int userId); } The concrete implementation of that repository:\nclass UserDataRepository implements UserRepository { private UserDataStoreFactory userDataStoreFactory; @Override public User user(int userId) { UserDataStore userDataStore = userDataStoreFactory.create(userId); return userDataStore.get(userId); } } An UserDataStore is, as the name already suggests, responsible to load a User from a store like disk or a backend (cloud).\ninterface UserDataStore { User getUser(int userId); } class DiskUserDataStore implements UserDataStore { private DiskCache\u0026lt;Int, User\u0026gt; userCache; @Override public User getUser(int userId){ return userCache.get(userId); } } class CloudUserDataStore implements UserDataStore { @Override public User getUser(int userId){ // Make an HTTP request and return User.  } } UserDataStoreFactory is the component that decides which UserDataStore to use when someone calls UserRepository.getUser(userId). For example the factory could check if DiskUserDataStore has a User and if the User object is expired then the factory returns CloudUserDataStore, otherwise DiskUserDataStore. The factory could also take into account if the smartphone has an active internet connection or not. I guess you get the point.\nConclusion Fernando Cejas interpretation of the Repository Pattern is representative of other developers that nowadays interpret the Repository Pattern in a similar way. However, it has not much in common with the \u0026ldquo;original\u0026rdquo; definition of the Repository Pattern by Martin Fowler et al. Wasn\u0026rsquo;t the repository pattern meant to be used to minimizing duplicate query logic? Martin Fowler didn\u0026rsquo;t say anything about loading users from different UserDataStores. Where did the Specification class go?\nIf you compare both, the original Repository Pattern and the later one, you will see that actually they are trying to solve two different kind of problems. While the original one tries to minimize duplicate query logic (by open / closed principle) the later one tries to hide the concrete data store your app is talking to. But from my point of view you can\u0026rsquo;t really solve both problems at the same time within the same pattern as Krzychu tried in his blog post by adding another abstraction. You have to choose which problem you actually want to solve (you can chain both patterns together though).\nSo why are both patterns called Repository Pattern? This happens quite often in history. A name gets (re)used for different purpose. For example Trygve Reenskaug introduced Model-View-Controller in the 1970s but his definition has nothing in common with what we nowadays call MVC, i.e. describing Activities as Controller on android, UIController on iOS, Controller in backends and so on. The same happened to the term Repository Pattern.\nNo worries, evolution is good. We should just remember where we came from and why it has evolved to what it is used now, for better understanding where we are going. The original Repository Pattern was designed for Enterprise Applications to reduce duplication of query logic. Usually, your android app is not a enterprise application. Normally, in your android app you should follow Fernando Cejas definition of the Repository Pattern because mostly you want to hide the underlying data store implementation to be more flexible for future requirement changes and consequential refactoring.\nBut, if you take a closer look at the later interpretation of the Repository Pattern you will come to the conclusion that basically it just says: program against an interface so that you can change implementation details later and follow the single responsibility principle. That\u0026rsquo;s what all the Clean Architecture and Repository Pattern blah blah is about.\nDon\u0026rsquo;t over abstract. Don\u0026rsquo;t over engineer. For example, if you start an app from scratch, yes, you should define an interface like UserRepo and all your business logic or domain layer or whatever layer should program agains this interface. However, if you only have one backend to load data from, then your UserRepo implementation should make these http calls directly in a concrete UserRepo class implementing the UserRepo interface. No need for UserDataStore, CloudUserDataStore and UserDataStoreFactory.\nYou may ask yourself: What if one day my requirements change and I have to use Realm instead of SQLite. Then you provide UserRepoRealm implements UserRepo instead of UserRepoSql implements UserRepo. Still no need for UserDataStore and UserDataStoreFactory. My message here is: build the minimal piece of code you really need and don\u0026rsquo;t over engineer it with requirements that may or may not be needed in the future. Seriously, I\u0026rsquo;m working in this industry for quite some years now and I have never worked on a backend, not to mention an android app, that has ever changed the underlying database. Don\u0026rsquo;t build an abstraction layer like SqlSpecification with such future requirements changes in mind. If one day you have to add something like a DiskCache along your cloud backend to communicate with, then it makes sense to refactor your code to respect the single responsibility principle and add classes like UserDataStoreFactory, UserDataStore, DiskUserDataStore and CloudUserDataStore. Since all your other layers are programming agains UserRepo interface, refactoring that is no problem at all.\nUntil then, no need for all this abstractions.\n","permalink":"https://hannesdorfmann.com/android/from-prefabricated-house-to-lego-house/","tags":["android","software-architecture","design-patterns"],"title":"The evolution of the Repository Pattern - Be aware of over abstraction"},{"categories":["Android"],"contents":"Before joining my current employer I have worked for an app agency and one thing I have noticed is that we were building every app entirely new from scratch even if we were building a similar app for the same customer with similar UI. We hadn\u0026rsquo;t reusable components. In this blog post I want to share some thoughts and lessons learned while building such reusable components.\nAt my current employer, Tickaroo, we were facing the same situation three years ago. Although Tickaroo is not an app agency, it\u0026rsquo;s a startup for sport enthusiasts, we are building apps for our partners from the world of sports as well. One of this partner is the Olympia Verlag , a renowned publisher in Germany for which we have started building (and are still developing and maintaining) their native android and iOS apps for one of their magazines called kicker (football magazine, which displays football news, live updated and so on) three years ago.\nAfter having released the first versions of the kicker app successfully in 2013 the Olympia Verlag was pleased with our work and charged us with building another app called MeinVerein, also a football app where you can select your favorite football club and then the app displays news and games about your football club.\nWhile kicker app is quite a huge app that can be used for free (with advertisement), MeinVerein is a paid only app (subscription based). MeinVerein\u0026rsquo;s app functionality can be seen as some kind of subset from kicker app.\nOne thing was clear from the very beginning: since the same designer who already had designed the kicker app was going to design MeinVerein app too the UI should be quite similar for both apps. In fact, this was desired by our customer Olympia Verlag since they wanted to have a consistent design branding across all of their apps. Let\u0026rsquo;s compare the UI of the apps:\nBasically MeinVerein app displays different data in more or less the same way as kicker app does with just some other colors / theme and the main navigation of both apps are different (navigation drawer vs. ViewPager). Some screens, for example the live updates screens, are completely identical. Other screens available in kicker app are not available in MeinVerein app. Additionally, MeinVerein offers some infos and screens kicker doesn\u0026rsquo;t. Also, even if the UI seems pretty similar completely different actions and screens will be opened by for example clicking on a button. So MeinVerein should provide the same look and feel as kicker app, but you can\u0026rsquo;t say that it is a simple build flavor / variant of the kicker app.\nLet\u0026rsquo;s build a prefabricated house Before we started with the development of MeinVerein app we, the iOS team and the android team, get together and discussed how we could build that app without much effort and in little time. The leading iOS developer, which by the way is the most experienced developer in our company, suggested to put all the stuff from the kicker app into a library. Software development is much about experience. Hence, it is priceless to have an experienced developers in your team and we from the android team had zero experience on how to build such a shared code base. He suggested to build a shared library as fundament for both, kicker app and MeinVerein app. So we did. The kicker app was build by using Fragments. Basically every screen is a Fragment, NewsListFragment to display a list of news, LeagueTableFragment etc. Furthermore, we have built this app by using Mosby a Model-View-Presenter library and so we moved all Fragments (MVP View), RecyclerView Adapters, XML layouts, Presenters and Model classes from kicker app into the newly created shared library. kicker app\u0026rsquo;s git repository was quite empty afterwards. For the sack of simplicity we only will discuss things in this blog post by using NewsListFragment as representative as a screen that looks similar in both apps, but keep in mind that there are also many other Fragments in this shared library.\nThe vision was to build screens for the corresponding apps by extending from the corresponding Fragment of the shared library that has already his Presenter, his RecyclerView Adapter, his XML layouts and so on. Customization should be done by overriding some methods from shared library\u0026rsquo;s Fragment, coloring and theming in xml and if required provide a custom dagger module to inject non default app specific components via dependency injection. The iOS team did the same with their UIViewControllers etc. In a nutshell: We built a prefabricated house where we can specify the color of the walls.\nThe problems of our prefabricated house Thanks to the shared library we were able to ship MeinVerein app within a few weeks. Everything was good. But we noticed the first symptoms: We caught ourselves programming 90% of the time in the shared library project even though that the actually code we were writing was kicker app exclusively and not even used by MeinVerein. But we ignored those symptoms: We use proguard which will remove all the unused classes from shared library in MeinVerein app or kicker app respectively, right?\nAnother example: We decided to put all our model classes and http networking stuff in the library as well, because even if the backend is not the same (different url) the backend guys said to us that the json data feed structure will be the same. At least that was the case in the first version of MeinVerein but as time went by and more features had been implemented the data feeds for both backends begin to differ more and more. However, imho the real problem was that all the pitfalls and issues on kicker backend side regarding json feed structure had also been copied to MeinVerein backend instead of avoiding this issues from very beginning since MeinVerein backend was a greenfield. But you know, we had to move fast, so had the backend guys. Today I know: you don\u0026rsquo;t move fast by writing bad code.\nOverall our shared library looks like this, i.e. to load and display a list of news items (NewsListFragment):\nBasically we used NewsListFragment directly in kicker app and MVNewsListFragment extends NewsListFragment in MeinVerein app with some overridden methods to achieve our goals. Looks reasonable, doesn\u0026rsquo;t it?\nUnfortunately, the devil is in the detail. While kicker app has advertisement, MeinVerein app has not advertisement because it\u0026rsquo;s a paid app. Also some features available in kicker App are not available MeinVerein app.\nThose are just two of many UI differences between both apps that has been envoled over the time. Sure, it\u0026rsquo;s our fault because the inheritance hierarchy is incorrect: The shared library shouldn\u0026rsquo;t provide a NewsListFragment with advertisement and feature XY build in but there should be rather a AdvertismentNewsListFragment extends NewsListFragment in the kicker app only, right? A few months later we started building a new app called \u0026ldquo;Tippspiel app\u0026rdquo; also for Olympia Verlag that looks like this:\nTippspiel looks similar to kicker and MeinVerein app. Actually, is uses the same NewsListFragment. However, apart from displaying a list of news in the same way as kicker and MeinVerein this app has nothing in common with the other apps. Tippspiel app has advertisement in the NewsList but not the feature XY. So what actually should NewsListFragment provide? Clearly we should introduce a inheritance hierarchy like this:\nSo should we put NewsListFragment, AdvertisementNewsListFragment, FeatureXYNewsListFragment and AdvertismenetFeatureXYNewsListFragment into the shared library so that we can choose the right base class that matches the requirements for the app like MeinVerein MVNewsListFragment extends NewsListFragment (no advertisement, no feature XY), kicker KikNewsListFragment extends AdvertismenetFeatureXYNewsListFragment (advertisement and feature XY) and Tippspiel TPNewsListFragment extends AdvertisementNewsListFragment(advertiesment only)? You see, inheritance doesn\u0026rsquo;t solve that problem, because for each feature you would have to introduce a new class in your inheriatance hierarchy and there are so many possible combinations for advertisement support, feature A, feature B, feature XY etc. Single inheritance as in java doesn\u0026rsquo;t scale. I have written an blog post Mixins as alternative to inheritance that you may find useful in this context.\nBut wait \u0026hellip; there is more: lately we have worked on the newest member of Olympia Verlag apps called Nordbayern app (another magazine):\nSo we decided to keep one single NewsListFragment in the shared library that has advertisement support and all features already implemented. Our solution for that problem was to extend from the \u0026ldquo;super provide everything NewsListFragment\u0026rdquo; but then inject a feature XY component that does nothing (stub) via dagger if the feature XY is not supported in the app. For Example, MeinVerein App doesn\u0026rsquo;t have feature XY, so we injected a featureXY component that does nothing in MeinVerein app whereas kicker app uses the build in feature XY component that does something useful. We thought about this as some kind of workaround to \u0026ldquo;remove unused\u0026rdquo; functionality. That made our shared libraries code confusing and debugging wasn\u0026rsquo;t easy because you didn\u0026rsquo;t know if a invoked method of a feature component does something useful or is just a stub. But we hadn\u0026rsquo;t a better solution.\nBut wait \u0026hellip; there is more: When we started to build our prefabricated house (a.k.a shared library) we were under the very naive illusion that now we only have to write one unit test for the NewsListFragment from shared library once for all apps and also if we would detect a bug in NewsListFragment we would fix it once for all apps. The reality was quite the opposite. Since, every app extended from NewsListFragment but has overridden some methods in the concrete apps fragment, we couldn\u0026rsquo;t be sure that the bugfix really fixed the problem in all apps and that the fragment is working as expected. Moreover, with every change or new feature we added to shared library\u0026rsquo;s NewsListFragment we had to fear that this will break things in other apps extending from this fragment. Our daily work flow was something like this: Write some code in share library (~ 10 minutes of work), test that each app is still working properly (~ 10 minutes of work for each app thanks to gradle incredible fast build time). So we spent around 1 hour for a code change doable in 10 minutes.\nBut wait \u0026hellip; there is more: until now we only talked about UI related things. But there are some other stuff like Tracking which are tight to lifecycle, one app has multiple tracking for some strange reason, another app uses an advertisement sdk which is also lifecycle aware and you have to call some methods like advertismentView.stop() in Fragment.onDestroyView() etc. Put all those things and dependencies into NewsListFragment in shared lib? It was a nightmare.\nThe need of a Lego kit We from the android team decided to take on this problem. Things got completely out of hand and we were slowed down by our shared library which actually should help us go fast. To be fair, when we started with the shared library it wasn\u0026rsquo;t predictable that we were going to build so many apps based on this shared library in the future and that requirements and features were that completely different from app to app.\nWe started to brainstorm and we made an interesting observation: Actually, writing a Presenter is super easy and can be done within a few minutes. So let\u0026rsquo;s remove the Presenters from shared library and let every app have their own Presenters. The same is true for our http library: communicating with a backend with Retrofit just requires to define a service interface with some Retrofit annotations. That takes only a few minutes. Also the \u0026ldquo;Model\u0026rdquo; classes like NewsList were part of the shared library. Defining your own Model class for each app is not a huge deal and is also not really time intensive. Obviously, those things (Presenter, http and \u0026ldquo;model\u0026rdquo; classes) weren\u0026rsquo;t the biggest issue, but removing that from shared library pointed us towards to a general solution: Only keep that things in a shared library that are time intensive to code again and again. We came to the conclusion that the most time consuming thing for us was writing RecyclerView ViewHolders and corresponding XML layout files. Also, time intensive was to implement all the lifecycle aware stuff like tracking and so on and NOT implementing a Fragment or Activity class per se.\nOnce we realized that the solution was obvious: We don\u0026rsquo;t want to build a prefabricated house, we want to build a Lego house with only those Lego pieces we really need for that house / app. In other words: we needed a Lego kit containing ViewHolders and XML layouts and also a plugin mechanism to hook in tracking and advertisement into Fragment\u0026rsquo;s lifecycle.\nSo we decided to deprecate the shared library and build two libraries: One containing ViewHolders, one containing plugin components for lifecycle. Another thing was very clear to us:\n Favor composition over inheritance We didn\u0026rsquo;t wanted to make the same mistake again: a god alike NewsListFragment to extend from.\n First, let\u0026rsquo;s talk about how we decided to deal with ViewHolder. Well, there is a library of mine which I have build in this context called AdapterDelegates. The idea is simple: defining a delegate for each RecyclerView\u0026rsquo;s ViewType / ViewHolder which does the job of inflating xml layout and binding the data:\npublic class BigNewsItemAdapterDelegate extends AbsListItemAdapterDelegate\u0026lt;BigNewsItem, NewsViewHolder\u0026gt; { @Override public NewsViewHolder onCreateViewHolder(ViewGroup parent) { return new CatViewHolder(inflater.inflate(R.layout.item_cat, parent, false)); } @Override public void onBindViewHolder(BigNewsItem item, NewsViewHolder vh) { vh.title.setText(item.getTitle()); loadImage(vh.image, item.getImageUrl()); } } So we defined all those AdapterDelegates like BigNewsItemAdapterDelegate, VideoNewsItemDelegate, SlideshowNewsItemDelegate etc. and put them in a library.\nNow kicker\u0026rsquo;s KikNewsListFragment looks like this:\n@Override public void onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle b){ ... RecyclerView rv = ...; Adapter adapter = new DelegatingAdapter\u0026lt;NewsItem\u0026gt;(); adapter.add(new BigNewsItemAdapterDelegate()) .add(new VideoNewsItemDelegate()) .add(new SlideshowNewsItemDelegate()) .add(new AdvertisementDelegate()); rv.setAdapter(adapter); } Please note that the AdvertisementDelegate() is not part of the library, because this one is used in kicker app and but not in MeinVerein app. I guess you know how the code of Fragments of the other apps look like, right? They reuse the same AdapterDelegates, the same xml layouts etc. However, to be really independent every AdapterDelegate has a tiny companion class for holding the required data to be displayed in a ViewHolder as well, i.e. BigNewsItemAdapterDelegate has a BigNewsItem, VideoNewsItemDelegate has a VideoNewsItem and so on.\nSo at some point we have to map the data coming from backend to this companion object. This is where a MVP based App pays of. This is the responsibility of the Presenter. We transform the \u0026ldquo;model\u0026rdquo; into a \u0026ldquo;presentation model\u0026rdquo;. Overall the architecture looks like this:\nAnd for the Tracking stuff? Favor composition over inheritance!\ninterface LifecycleDelegate { void onCreate(); void onPause(); void onResume(); void onDestroy(); ... } class TrackingLifecycleDelegate implements LifecycleDelegate { private String trackingTag; public TrackingLifecycleDelegate(String trackingTag){ this.trackingTag = trackingTag; } @Override public void onResume(){ Tracking.viewAppeared(trackingTag); } ... } class KikNewsListFragment extends Fragment { List\u0026lt;LifecycleDelegate\u0026gt; lifecycleDelegates = new ArrayList\u0026lt;\u0026gt;(); { // Initializer block  lifecycleDelegates.add(new TrackingLifecycleDelegate(\u0026#34;kicker app NewsListScreen\u0026#34;)); } @Override public void onResume(){ super.onResume(); for (LifecycleDelegate l : lifecycleDelegates){ lifecycleDelegates.onResume(); } } // Same for other lifecycle methods  ... } Now we can share TrackingLifecycleDelegate with all apps. Overall it looks like this:\nThere are some libraries you can use to achieve the same thing: Soundcloud\u0026rsquo;s Lightcycle and AndroidComposite by Pascal Welsch.\nSummary In my opinion a Lego house is much more flexible and maintainable compared with a prefabricated house. Favor composition over inheritance is the key to build a Lego kit. Obviously, there is no silver bullet to solve that kind of problem. Our Lego house approach works quite good for us, but i.e. our iOS team still prefer the prefabricated house approach even though they have similar issues as we had in our android apps. Somehow that approach works for them (but don\u0026rsquo;t ask me how). I guess the important bit is that all developers working in the same team know exactly how this approach should be implemented and have committed to do that consistently the same way. Maybe we from the android team failed at this point.\nWas it an error to start with the prefabricated house approach suggested by the most experienced developer in our company? No! MeinVerein app has been build with that approach in incredible little time. I definitely would follow the experienced developers recommendation again, but not blindly. I have learned a lot, which hopefully will help me with future decisions. What really matters is to learn from the past to build a better future. I think with the Lego house approach we are moving in the right direction. But who knows, maybe in two years I will write a blog post about how bad the Lego house approach was.\n","permalink":"https://hannesdorfmann.com/android/from-prefabricated-house-to-lego-house/","tags":["android","software-architecture"],"title":"From Prefab House to Lego House"},{"categories":["Java"],"contents":"Starting in Android N Google has added some java 8 language features. One of those features is the ability to add default methods to interfaces. Surprisingly (since java 8 has already been released 2 years ago) I haven\u0026rsquo;t found good articles describing the advantage of default methods for interfaces: Mixins!\nLet\u0026rsquo;s straight jump into a simple example. Let\u0026rsquo;s say we have a class Ship. A Ship can carry Cargo. Let\u0026rsquo;s model that in Java like this:\npublic class Ship { List\u0026lt;Cargo\u0026gt; cargoes; public void addCargo(Cargo c){ cargoes.add(c); } public void removeCargo(Cargo c){ cargoes.remove(c); } } We also have an Airport where Aircrafts can land and depart:\npublic class Airport { List\u0026lt;Aircraft\u0026gt; aircrafts; public void land(Aircraft a) { aircrafts.add(a); } public void depart(Aircraft a) { aircrafts.remove(a); } } Given that, what if we want to have another class that is Airport and Ship at the same time? Unrealistic? What about an AircraftCarrier. Since java doesn\u0026rsquo;t support multiple inheritance we can\u0026rsquo;t declare a class AircraftCarrier that extends from Airport and Ship:\nclass AircraftCarrier extends Airport, Ship // doesn\u0026#39;t compile So what alternatives do we have to make AircraftCarrier be a Ship and a Airport at the same time? Well, we could use delegation (\u0026ldquo;favor composition over inheritance\u0026rdquo;) or some tricks from aspect orientated programming, but none of them are really natively supported by java programming language.\nHowever, java does support multiple inheritance on interfaces and allows classes to implement arbitrary many interfaces. So let\u0026rsquo;s convert Ship and Airport to interfaces:\npublic interface Ship { void addCargo(Cargo c); void removeCargo(Cargo c); } public interface Airport { void land(Aircraft a); void depart(Aircraft a); } class AircraftCarrier implements Ship, Airport { List\u0026lt;Aircraft\u0026gt; aircrafts; List\u0026lt;Cargo\u0026gt; cargoes; public void land(Aircraft a) { aircrafts.add(a); } public void depart(Aircraft a) { aircrafts.remove(a); } public void addCargo(Cargo c){ cargoes.add(c); } public void removeCargo(Cargo c){ cargoes.remove(c); } } But now we have to implement the methods from each interface manually. Not a big deal in this simple example because it\u0026rsquo;s basically just one line of code for each method but I guess you get the point.\nHow does Ruby programmers deal with inheritance? Experienced Ruby programmers don\u0026rsquo;t use inheritance for such things. They use Mixins:\nmodule Airport # for simplicity: module is same as class @aircrafts = Array.new # variable def land(aircraft) aircrafts.push(aircraft) end def depart(aircraft) aircraft.delete(aircraft) end end class AircraftCarrier include Ship include Airport end With Mixins we can compose AircraftCarrier by \u0026ldquo;including\u0026rdquo; (or mixing in) the functionality of Ship and Airport without inheritance. Ship definition has been omitted for better readability but I guess you can imagine how the code for module Ship will look like. Please note that this is not multiple inheritance as C++ offers (diamond problem). Mixins are a different concept. The Ruby programming language has native support for Mixins. What about other languages like Scala? Scala has support for Mixins as well. In Scala those are called Traits. Traits are Mixins just with some slightly different properties from a programming language designers point of view like Mixins require linearization while Traits are flattened and Traits traditionally don\u0026rsquo;t contain states. But that shouldn\u0026rsquo;t worry you too much. For the sake of simplicity we can say Mixins and Traits are the same.\ntrait Ship { val cargoes : ListBuffer[Cargo] def addCargo(c : Cargo){ cargoes += c } def removeCargo(c : Cargo){ cargoes -= c } } And then with Scala we can do something like this:\nclass AircraftCarrier with Ship with Airport See the thing is both, Ruby and Scala, natively have language support for Mixins. But what about java? With Java 8 and default methods for interfaces we can do pretty the same thing:\npublic interface Airport { // To be implemented in subclass  List\u0026lt;Aircraft\u0026gt; getAircrafts(); default void land(Aircraft aircraft) { getAircrafts().add(aircraft); } default void depart(Aircraft aircraft) { getAircrafts.remove(aircraft); } } We will do the same for Ship (interface with default method implementations) and then we can do something like this:\nclass AircraftCarrier implements Ship, Airport { List\u0026lt;Aircraft\u0026gt; aircrafts = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Cargo\u0026gt; cargoes = new ArrayList\u0026lt;\u0026gt;(); @Override public List\u0026lt;Aircraft\u0026gt; getAircrafts(){ return aircrafts; } @Override public List\u0026lt;Cargo\u0026gt; getCargoes(){ return cargoes; } } AircraftCarrier carrier = new AircraftCarrier(); carrier.addCargo(c); carrier.land(a); Moreover, now we can compose new classes even more easily and without traditional inheritance:\nclass Houseboat implements House, Ship { ... } class MilitaryHouseboat implements House, Ship, Airport { ... } I guess you get the point. With Java 8 and default methods for interfaces we can use Mixins instead of inheritance. kotlin also offers Mixins via interfaces with default methods:\ninterface Ship { val cargoes : List\u0026lt;Cargo\u0026gt; fun addCargo(c : Cargo){ cargoes.add(c) } fun removeCargo(c : Cargo) { cargoes.remove(c) } } class AircraftCarrier : Ship, Airport { override val cargoes = ArrayList() override val aircrafts = ArrayList() } Hopefully you see that Mixins may be a better choice than traditional inheritance. But how does that help in android development. In android we always have to extend from Activity or Fragment, which are obviously two different base classes. With Mixins, we can share code between both classes that extends from Activity and classes that extends from Fragment. Sure this is not the main use case of Mixins (delegation might be a better choice) because those methods defined in the Mixin will be used internally from the Fragment or Activity himself which are implementing the Mixin interface, but it is a valid option though. Unfortunately, interfaces with default methods on Android requires min sdk 24 (Android N) and Jack as compiler.\nSee the moral of the story is it is good to have an alternative to inheritance and I have the feeling that unfortunately Mixins via interfaces with default implementation are not used that much in the java world.\nMy general advice about inheritance:\n Inheritance doesn\u0026rsquo;t scale well! Use inheritance for inheriting properties but not for inheriting functionality! Mixins are better suited for \u0026ldquo;inheriting\u0026rdquo; functionality.\n ","permalink":"https://hannesdorfmann.com/android/java-mixins/","tags":null,"title":"Mixins as an alternative to inheritance in Java 8"},{"categories":["Android"],"contents":"I have been asked several times why Presenters in Mosby (MVP library) don\u0026rsquo;t have lifecycle callback methods like onCreate(Bundle), onResume() etc. Also the awesome guys over at SoundCloud have published a library called LightCycle that helps break logic out of Activity or Fragments into smaller containers bound to the parents Activity\u0026rsquo;s or Fragment\u0026rsquo;s lifecycle. While this library is great and helpful they also mention in their examples that this library can be used in MVP to bring lifecycle to Presenters. I, personally, think that Presenters don\u0026rsquo;t need lifecycle callback methods and in this blog post I will discuss why.\nAlright, before we get started, think of the definition and the rule of a Presenter in MVP. Here is my definition:\n The Presenter is responsible to coordinate the view, transform Model into \u0026ldquo;PresentationModel\u0026rdquo; so that the View can display data more convenient and to be the bridge to the \u0026ldquo;business logic\u0026rdquo; to retrieve data that should be displayed in the View. MVP is all about separation of concerns.\n Given that \u0026ldquo;definition\u0026rdquo; of a Presenter I don\u0026rsquo;t see a reason why the Presenter needs lifecycle callbacks like onCreate(), onPause() and onResume(). All the Presenter needs to know is whether or not a View is attached to the Presenter (because of androids screen orientation dilemma). It should be that simple. Actually, this is one of the arguments why some developers are advocating against fragments (complex lifecycle) and prefer \u0026ldquo;custom views\u0026rdquo; (i.e. extending from FrameLayout) because custom view\u0026rsquo;s only have two lifecycle events: ViewGroup.onAttachedToWindow() and ViewGroup.onDetachedFromWindow() (btw. that\u0026rsquo;s the reason why Mosby Presenters only have attachView() and detachView() methods if you want to count them as \u0026ldquo;lifecycle events\u0026rdquo;).\nFurthermore, lifecycle managing is already a complex topic. If you start to move lifecycle logic in your Presenter then you basically have just moved that spaghetti code from Activity to Presenter. Clearly the intention of LightCycle is to solve exactly this problem: LightCycle helps you to split or delegate the spaghetti code logic you usually write in your Activity\u0026rsquo;s or Fragment\u0026rsquo;s lifecycle methods into multiple smaller components that are following the single responsibility principle. However, according to LightCycle examples they promote (indirectly) to build Presenters with lifecycle methods. Don\u0026rsquo;t get me wrong: The idea of LightCycle is great and achieving that via annotation processing is pretty smart, but lifecycle management is not the Presenters responsibility and therefore the Presenter doesn\u0026rsquo;t need lifecycle callback methods. This blog post is not advocating against LightCycle (it\u0026rsquo;s awesome!). This blog post is advocating against lifecycle in Presenters in general!\nWith that said, you might understand my point of view, but you also have faced scenarios where from your point of view the Presenter indeed needs lifecycle callback methods. Okay, let\u0026rsquo;s talk about it!\nFor example let\u0026rsquo;s assume we want to build an app that displays the user\u0026rsquo;s current GPS position on a map in our app. As the screen turns off we should stop retrieving GPS position updates to safe battery life. So how would we implement this with MVP? We would have an TrackingActivity as View (TrackingView) displaying a map with the user\u0026rsquo;s current GPS position. We also need a GpsTracker class as business logic\u0026rdquo; (model in MVP) which is responsible to detect the current GPS position and notify observers (listeners) about position changes. The TrackingPresenter is such an observer. He is registered as listener to GpsTracker and will update the View when GPS position has been changed.\nSo far so good. As already said, to not drain the battery too much we want to stop GPS tracking when the display is off, in other words stop GPS Tracking in Activity.onPause() and resume when Activity.onResume(). Read this sentence carefully again. Do you get it? It\u0026rsquo;s not the Presenter who needs onPause() and onResume() lifecycle events. Rather the \u0026ldquo;business logic\u0026rdquo;, the GpsTracker, needs these lifecycle events.\nBut how do we implement that? Should we simply forward Activity.onPause() to Presenter.onPause() which then calls GpsTracker.stop()? So we do need a Presenter with lifecycle methods otherwise we couldn\u0026rsquo;t forward the pause events the way down to GpsTracker.stop(), right? I think there is a better way. As already said, is not the responsibility of the Presenter to handle lifecycle events. Actually, there is already a component that is responsible for lifecycle events: the Activity (or Fragment). So instead of forwarding Activity.onPause() and Activity.onResume() to the presenter, just do something like this:\nclass TrackingActivity extends MvpActivity implements TrackingView { private GpsTracker tracker; public onCreate(){ tracker = new GpsTracker(this); // might need a context  ... } public void onPause(){ tracker.stop(); } public void onResume(){ tracker.start(); } @Override public void createPresenter(){ // Called by Mosby  return new TrackingPresenter(tracker); } } As you see, the trick is that the GpsTracker is \u0026ldquo;bound\u0026rdquo; to the Activity\u0026rsquo;s lifecycle directly in the component that is responsible for managing lifecycle: the Activity! Then we pass the GpsTracker to the Presenter as constructor parameter. Furthermore, now TrackingPresenter fulfills the single responsibility from my previous definition: It\u0026rsquo;s only responsible to update the View.\nclass TrackingPresenter extends MvpBasePresenter\u0026lt;TrackingView\u0026gt; implements GpsUpdateListener{ GpsTracker tracker; public TrackingPresenter(GpsTracker tracker){ this.tracker = tracker; tracker.setGpsUpdateListener(this); } @Override public void onGpsLocationUpdated(GpsPosition position){ view.showCurrentPosition(position.getLat(), position.getLng()); } } That\u0026rsquo;s it. Single responsibility for all your components!\nOf course we can spice up the code shown above with dependency injection and with LightCycle:\nclass TrackingActivity extends MvpActivity implements TrackingView { @Inject @LightCycle GpsTracker tracker; @Override public TrackingPresenter createPresenter(){ return getObjectGraph.get(TrackingPresenter.class); // Dagger 1  // or  return getComponent().trackingPresenter(); // Dagger 2  } } Are you looking for more examples? Another user of Mosby (MVP library) has asked me a similar question on github for a music player app he is working on. I gave a similar answer.\nOf course this is only my personal opinion and there are exceptions and you may really need lifecycle events in your Presenters, but I think in 99% your business logic needs lifecycle events and not your Presenters. Usually (I would say 95% of the apps out there) don\u0026rsquo;t have lifecycle aware business logic. And if an app really has such lifecycle aware business logic, then 99% of the time the Presenter doesn\u0026rsquo;t have to be lifecycle aware, but rather the business logic.\nSo the moral of the story is: You should avoid lifecycle aware components as much as possible. Doesn\u0026rsquo;t matter if business logic (Model) or Presenter. It\u0026rsquo;s my general advise. Lifecycle only introduces undesired complexity. But if you really really really need components that are lifecycle aware, then most likely the business logic (Model) should be lifecycle aware and not the Presenter.\nLast but not least I want to say that the intention of this blog post is not to discredit SoundCloud\u0026rsquo;s LigthCycle! I just wanted to say that from my point of view the LightCycle examples (having Presenters with lifecycle callback methods in general) are not my cup of tea. I think this is mainly caused by the fact that my definition of a Presenter (i.e. I also don\u0026rsquo;t want to have android SDK dependencies like Bundle in my Presenters) is entirely different from SoundClouds definition of a Presenter.\nUpdate (03/25/2016) As some people pointed out correctly (see also reddit ) the code snipped shown above causes that the TrackingView (TrackingActivity) has knowledge of GpsTracker which definitely feels dangerous. What I wanted to demonstrate is that there is already a component responsible for lifecycle management in your app and it\u0026rsquo;s not the Presenter. I didn\u0026rsquo;t say that GpsTracker should be used or manipulated from TrackingView directly. That is still the job of the TrackingPresenter. However, yes, TrackingActivity has a reference to GpsTracker and could be misused. The real problem is that Activity is View and lifecycle manager at the same time. I see two solutions for that problem:\n Separate View and lifecycle responsibility: How do we do that? Well we have to move either View responsibility or lifecycle management out of Activity. Obviously we can\u0026rsquo;t remove the lifecycle management from Activity easily, but we can introduce an additional layer which then is really just a TrackingView:  class TrackingActivity extends MvpActivity\u0026lt;TrackignView, TrackingPresenter\u0026gt; { @Inject @LightCycle GpsTracker tracker; TrackingView view; public void onCreate(n){ super.onCreate(b); setContentView(R.layout.activity_tracking); view = (TrackingView) findViewById(R.id.tracking_view); } @Override // called by Mosby, same as before  public TrackingPresenter createPresenter(){ ... } @Override // called by Mosby to connect view with presenter  public TrackingView getMvpView(){ return view; } } The thing here is we introduce an extra View layer. This can be something like TrackingLayout extends FrameLayout implements TrackingView so you can use it directly in xml layout or you could build some kind of \u0026ldquo;wrapper class\u0026rdquo; that gets the root layout from Activity and internally manages UI widgets or whatever works best for you. This approach might be the cleanest solution because now we have truly single responsibility even in the Activity (lifecycle only). But this solution comes with a price: an additional layer. I don\u0026rsquo;t know about you but for me adding yet another layer is the beginning of over-engineering. And there are still some dependencies an activity has to offer to the view layer like what if you need a Bundle in View (do you really want to work with BaseSavedState)? What if the view needs a reference to the Window to set some flags like hide navigation bar, immersive mode or shared element transitions. Maybe we could use dependency injection like Dagger to solve that kind of problem? Yes, but soon or later you will be caught by dependency injection library so that we can\u0026rsquo;t do anything without dagger anymore, which sucks. So even if in theory introducing a dedicated \u0026ldquo;view\u0026rdquo; layer seems to be a good idea it\u0026rsquo;s not my recommended solution.\n Hide GpsTracker from View: This seems a like a work around, but from my experience this is the simpler and a more practical solution. What was the original problem? The problem was that TrackingActivity has a reference to GpsTracker and therefore one could access and misuse GpsTracker. How to solve this problem? Introducing an additional layer seems to me like getting the fire brigade to extinguish a candle. Why not simply \u0026ldquo;hide\u0026rdquo; GpsTracker from TrackingActivity like this:  class LifecycleController extends DefaultActivityLightCycle { private GpsTracker tracker; @Inject public LifecycleController(GpsTracker tracker){ ... } @Override public void onPause(){ tracker.stop(); } @Override public void onResume(){ tracker.start(); } } and then we treat the Activity as TrackingView as we already did before:\nclass TrackingActivity extends MvpActivity implements TrackingView { @Inject @LightCycle LifecycleController lifecycleController; @Override public void createPresenter(){ // Called by Mosby  return new TrackingPresenter(tracker); } } By doing so TrackingActivity no longer has a reference to GpsTracker that can be misused without the burden of an additional layer.\nPlease note, that in this blog post we are talking about business logic components like GpsTracker that are lifecycle aware. Obviously, I don\u0026rsquo;t want you to do that for all your business logic components even if they are not lifecycle aware at all. That is nonsense. The \u0026ldquo;traditional\u0026rdquo; MVP approach is quite good. I was just advocating against making Presenter lifecycle aware when the business logic is the component that is lifecycle aware.\n","permalink":"https://hannesdorfmann.com/android/presenters-dont-need-lifecycle/","tags":["android","software-architecture"],"title":"Presenters don't need lifecycle events"},{"categories":["Android"],"contents":"As developers we should always think outside the box. A month ago Artem Zinnatullin and I have discussed some architectural trends on android and on other platforms, like .NET and javascript, in his Podcast The Context. A few days later Christina Lee gave an awesome lightning talk Redux-ing UI Bugs during square\u0026rsquo;s The Journey of Android Engineers event. She also talked about one of my favorite js libraries: Cycle.js, which defines itself as Model-View-Intent (MVI) library. After watching Christina Lee\u0026rsquo;s inspiring talk I finally found motivation to take the time to write down my thoughts about MVI on android.\n This blog post is outdated. Please take a look at this blog post series about Model-View-Intent.\n Preface: Model-View-Intent relies heavily on reactive and functional programming (RxJava). Believe me, many people won\u0026rsquo;t understand MVI at the first time. I was in the same situation. A year ago, I definitely gave up and started again several times to understand it, but guess what: that\u0026rsquo;s completely fine! If you don\u0026rsquo;t understand this blog post at the first go, it\u0026rsquo;s ok, relax, take it easy and retry it a few days later again.\nSo what is Model-View-Intent? Yet another architecture for user interfaces? Well, I recommend you to watch the following video about cycle.js presented by the inventor André Medeiros (Staltz) at JSConf Budapest in May 2015 (at least the first 10 minutes) to get a better understanding of the motivation behind MVI:\n  I know it\u0026rsquo;s javascript but the key fundamentals are the same for all UI based platforms, incl. android (just replace DOM with android layouts, UI widgets, \u0026hellip;).\nFrom MVC to MVI MVI is inspired by some other js frameworks like redux and react, but the key principle comes from Model-View-Controller (MVC). I mean the original MVC introduced 1979 by Trygve Reenskaug to separate View from Model. Again, to clarify, I\u0026rsquo;m not talking about MVC from iOS (ViewController) or Android (Activity / Fragment) or backend frameworks which also (mis)use the word controller. I talk about MVC in his pure original form. A Model that is observed by the View and a Controller that manipulates the Model. Unlikely nowadays, in Reenskaug original idea of MVC almost every UI element has it\u0026rsquo;s own Model and Controller. Imagine a CheckBox UI widget: this one observers his own model, i.e. a boolean. The controller could be a OnCheckboxChangedListener triggered by the user\u0026rsquo;s mouse. From cycle.js docs:\n The Controller in MVC is incompatible with our reactive ideals, because it is a proactive component (implying either passive Model or passive View). However, the original idea in MVC was a method for translating information between two worlds: that of the computer’s digital realm and the user’s mental model.\n   Source: cycle.js.org\n  However, in the original MVC the controller may or may not also manipulate the view. But that is not exactly what we want, because we want an unidirectional data flow and immutability to establish predictable states, which leads to cleaner, more maintainable code and less bugs.\n  Source: cycle.js.org\n  Do you see the unidirectional flow? The cycle? The next question is how do we establish such a circle? Well, as you have seen above, the computer takes an input and converts it to an output (display / view). The human, sees the output from computer and takes it as Input and produces Output (UI widgets events like a click on a button) which then will be again the input for the computer. So the concept of taking a input and have an output seems to be familiar, doesn\u0026rsquo;t it? Yes, it\u0026rsquo;s a (mathematical) function.\nSo what we basically want to have is a chain of functions like this:\n intent(): This function takes the input from the user (i.e. UI events, like click events) and translate it to \u0026ldquo;something\u0026rdquo; that will be passed as parameter to model() function. This could be a simple string to set a value of the model to or more complex data structure like an Actions or Commands. Here in this blog post we will stick with the word Action. model(): The model function takes the output from intent() as input to manipulate the model. The output of this function is a new model (state changed). So it should not update an already existing model. We want immutability! We don\u0026rsquo;t change an already existing one. We copy the existing one and change the state (and afterwards it can not be changed anymore). This function is the only piece of your code that is allowed to change a Model object. Then this new immutable Model is the output of this function. view(): This method takes the model returned from model() function and gives it as input to the view() function. Then the view simply displays this model somehow.  But what about the cycle, one might ask? This is where reactive programming (RxJava, observer pattern) comes in.\nSo the view will generate \u0026ldquo;events\u0026rdquo; (observer pattern) that are passed to the intent() function again.\nSounds quite complex, I know, but once you are into it it\u0026rsquo;s not that hard anymore. Let\u0026rsquo;s say we want to build a simple android app to search github (rest api) for repositories matching a certain name. Something like this:\n  Let\u0026rsquo;s have a look at a very naive implementation (kotlin). We will use Jake Whartons RxBinding library to get RxJava Observables from SearchView widget. Our data model class looks like this:\ndata class SearchModel(val searchTerm: String, val results: List\u0026lt;GithubRepo\u0026gt;) And our main Actvitiy:\nclass SearchActivity : AppCompatActivity() { val githubBackend : GitHubBackend = ... ; // Retrofit for Github Rest API  val editSearch: android.widget.SearchView by bindView(R.id.searchView) val recyclerView: RecyclerView by bindView(R.id.recyclerView) val loadingView: View by bindView(R.id.loadingView) var adapter: SearchResultAdapter override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_search) setSupportActionBar(toolbar) adapter = SearchResultAdapter(layoutInflater) recyclerView.adapter = adapter recyclerView.layoutManager = LinearLayoutManager(this) // MVI: please note that the following code is chained togehter  // the comments and empty lines are just for legibility  // \u0026#34;intent()\u0026#34; maps UI event to \u0026#34;action\u0026#34; (a search string)  Observable\u0026lt;String\u0026gt; = RxSearchView.queryTextChangeEvents(editSearch) .filter { it.queryText().count() \u0026gt;= 3 } .debounce(500, TimeUnit.MILLISECONDS) // here: Observable\u0026lt;String\u0026gt;  // \u0026#34;model()\u0026#34; loads data from model  .startWith(\u0026#34;\u0026#34;) // If starting the first time we emit empty string as Model  .flatMap { queryString -\u0026gt; if (queryString.isEmpty()) Observable.just( SearchModel(\u0026#34;\u0026#34;, emptyList)) // returns Observable\u0026lt;SearchModel\u0026gt;  else githubBackend.search(queryString) // Retrofit; here: Observable\u0026lt;GithubResponse\u0026gt;  .map { response -\u0026gt; SearchModel(queryString, response.items) } // here: Observable\u0026lt;SearchModel\u0026gt;  } // end flatMap; here: Observable\u0026lt;SearchModel\u0026gt;  // \u0026#34;view()\u0026#34; method is just subscribing and updating UI  .observeOn(AndroidSchedulers.mainThread()) .subscribe({ result -\u0026gt; // SearchModel ; onNext()  adapter.items = result.items adapter.notifyDataSetChanged() }, { error -\u0026gt; // onError()  Toast.makeText(...); } ) } } That\u0026rsquo;s a lot of code isn\u0026rsquo;t it. I hope you could follow that code and find my comments helpful. In a nutshell: intent() function basically listens to SearchView Text changes and gives the query string (kind of action to tell the model to search for that string) to the model() function. The model() function is responsible to manage the \u0026ldquo;model\u0026rdquo;. With startWith() we ensure that the first time we subscribe to an \u0026ldquo;empty\u0026rdquo; search result gets forwarded (in other words, we setup the initial state). Otherwise we use retrofit to load a GithubResponse that we than have to transform to a SearchModel. Last the view() gets the SearchModel as result (RxJava Observer) and is responsible to \u0026ldquo;render\u0026rdquo; and display the SearchModel.\nGreat, we have a unidirectional data flow. Even better, we have immutability and pure functions (none of this function has side effects or stores or changes the state somehow, except retrofit). So are we done?\nThe Big Picture What about all the other things we have learned from other architectural design patterns like MVP? What about concepts they offer like separation of concerns, decoupled \u0026amp; maintainable code, testability, reusability, single responsibility and so on?\nYou get it, this code is basically a common android developer beginner mistake: Put everything in one huge Activity (God object). Well, it has a structure thanks to MVI \u0026amp; RxJava, but is it good code? It\u0026rsquo;s not spaghetti code (maybe reacitve spaghetti code, that\u0026rsquo;s a matter of opinion), but is it good code?\nNevertheless, we can do it better. So let\u0026rsquo;s refactor this code. As you might already know I\u0026rsquo;m a fan of MVP. So lets combine the best of both, MVP and MVI. In this sample we will use Mosby, a MVP library. Before we start, let\u0026rsquo;s talk about separation of concerns a little bit. What is the responsibility of the View in MVP? Right, just display the data, and doing what the Presenter \u0026ldquo;commands\u0026rdquo; to display. In MVI what should the GUI do? Exactly, the GUI triggers UI events and the intent() function will translate that to \u0026ldquo;actions\u0026rdquo; to manipulate the model afterwards.\nSo the MVP View Interface will offer a intent() function, in our case we call this method searchIntent() function:\ninterface SearchView : MvpView { fun searchIntent(): Observable\u0026lt;String\u0026gt; // intent() function } Next our Activity will become a MVP View (implements SearchView). That means, everything that is not related to updating the UI or generate UI events will be removed.\nclass SearchActivity : SearchView, MvpActivity\u0026lt;SearchView, SearchPresenter\u0026gt;() { val editSearch: android.widget.SearchView by bindView(R.id.searchView) val recyclerView: RecyclerView by bindView(R.id.recyclerView) val loadingView: View by bindView(R.id.loadingView) var adapter: SearchResultAdapter override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_search) setSupportActionBar(toolbar) adapter = SearchResultAdapter(layoutInflater) recyclerView.adapter = adapter recyclerView.layoutManager = LinearLayoutManager(this) } // Provide a intent() function  override fun searchIntent(): Observable\u0026lt;String\u0026gt; { return RxSearchView.queryTextChangeEvents(editSearch) .filter { it.queryText().count() \u0026gt;= 3 } .debounce(500, TimeUnit.MILLISECONDS) } // dependency injection via dagger  override fun createPresenter(): SearchPresenter = App.getComponent(this).searchPresenter() } Ah, looks much better now, doesn\u0026rsquo;t it? Let\u0026rsquo;s continue with the Presenter. The Presenters responsibility is to coordinate the view and to be the \u0026ldquo;bridge\u0026rdquo; to the business logic. In Mosby, a Presenter has two methods, attachView() (called from activity.onCreate() ) and detachView() (called from activity.onDestroy()).\nclass SearchPresenter : MvpBasePresenter\u0026lt;SearchView\u0026gt;() { lateinit var subscription: Subscription override fun attachView(view: SearchView) { super.attachView(view) subscription = view.getSearchIntent() // intent()  .startWith(\u0026#34;\u0026#34;) // model() function, same as before  .flatMap { queryString -\u0026gt; if (queryString.isEmpty()) Observable.just( SearchModel(\u0026#34;\u0026#34;, emptyList)) // returns Observable\u0026lt;SearchModel\u0026gt;  else githubBackend.search(queryString) // Retrofit; here: Observable\u0026lt;GithubResponse\u0026gt;  .map { response -\u0026gt; SearchModel(queryString, response.items) } // here: Observable\u0026lt;SearchModel\u0026gt;  } // end flatMap; here: Observable\u0026lt;SearchModel\u0026gt;  .observeOn(AndroidSchedulers.mainThread()) .subscribe(view.showData(), view.showError()) } override fun detachView(retainInstance: Boolean) { super.detachView(retainInstance) subscription.unsubscribe() } } Alright, so now the Presenter uses the View\u0026rsquo;s serachIntent() method and connects it to the model. Are we done? No, the presenter contains the \u0026ldquo;business logic\u0026rdquo; code (model() function). So there is one separation of concern still missing. We will refactor that in a minute. Let\u0026rsquo;s continue with this little statement: .subscribe(view.showData(), view.showError()). Basically this is our view() function. In MVP the Presenter tells the view what to display (\u0026ldquo;renders\u0026rdquo; the View). So what are this two methods? This methods are part of the SearchView interface that I have omitted before:\ninterface SearchView : MvpView { fun searchIntent(): Observable\u0026lt;String\u0026gt; // intent() function  fun showData(): (SearchModel) -\u0026gt; Unit // RxJava Action1  fun showError(): (Throwable) -\u0026gt; Unit // RxJava Action1 } class SearchActivity : SearchView, MvpActivity\u0026lt;SearchView, SearchPresenter\u0026gt;() { ... override fun showData(): (SearchModel) -\u0026gt; Unit = { adapter.items = it.results adapter.notifyDataSetChanged() } override fun showError(): (Throwable) -\u0026gt; Unit = { loadingView.visibility = View.GONE Toast.makeText(this, \u0026#34;An Error has occurred\u0026#34;, Toast.LENGTH_SHORT).show() it.printStackTrace() } } So what we now have and what we didn\u0026rsquo;t had before doing the refactoring is a entirely decoupled View. All the View has to provide is an Observable as intent() function. Today the output of searchIntent() comes from an EditText widget and use debounce() operator. Tomorrow it could be something entirely different (i.e. a dropdown menu with a list of strings to chose from) and you don\u0026rsquo;t have to touch (and therefore can\u0026rsquo;t break) anything else of your existing source code except the View (SearchActivity). The same is valid for the way how the view is \u0026ldquo;rendered\u0026rdquo; / displayed. All that view related code lives in SearchActivity. Today it uses a RecyclerView to display the \u0026ldquo;model\u0026rdquo;, but tomorrow it could be another custom UI widget or a ListView. I guess you get the point.\nBack to our Presenter\u0026rsquo;s source code: as already said, currently the Presenter contains all the business logic. One of the main pitfalls with that is that presenter is not testable (how to mock parts of our business logic) and we can\u0026rsquo;t reuse that business logic for other Presenter because it\u0026rsquo;s hard coded. Let\u0026rsquo;s refactor that code. First we introduce a SearchEngine:\nclass SearchEngine(private val githubBackend: GithubBackend) { fun search(query: String): Observable\u0026lt;SearchModel\u0026gt; = if (query.isEmpty()) { Observable.just(SearchModel(\u0026#34;\u0026#34;, emptyList())) } else { githubBackend.getRepositories(query).map { SearchModel(query, it.items) } } } SearchEngine gets a GithubBackend and offers a search(String) : Observable for the outside. SearchEngine is our business logic, just functional by providing a search() function with one input (search string) and an output (Observable). In our model() function then we call search engine\u0026rsquo;s function, who is responsible to change the \u0026ldquo;model\u0026rdquo;. The model is basically the search result (initial state is empty list as search result). However, we don\u0026rsquo;t want to hardcode that again in our Presenter.\n What if instead of objects we injection functions?\n So we use dependency injection (Dagger) to provide and inject a modelFunc() to other components, in this case to the SearchPresenter:\n@Module class ApplicationModule { @Provides @Singleton fun providesSearchEngine(): SearchEngine { val retrofit = Retrofit.Builder() .baseUrl(\u0026#34;https://api.github.com\u0026#34;) .addConverterFactory(MoshiConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build() return SearchEngine(retrofit.create(GithubBackend::class.java)) } @Provides @Singleton fun providesModelFunc( searchEngine: SearchEngine): Function1\u0026lt;Observable\u0026lt;String\u0026gt;, Observable\u0026lt;SearchModel\u0026gt;\u0026gt; = { stringObservable -\u0026gt; stringObservable.startWith(\u0026#34;\u0026#34;).flatMap { queryString -\u0026gt; searchEngine.search(queryString) } } } The important bit here is providesModelFunc() which offers a Lambda Observable-\u0026gt; Observable. Since lambdas are just anonymous functions (kind of) we take this lambda and inject it into SearchPresenter:\nclass SearchPresenter @Inject constructor( val modelFunc: (Observable\u0026lt;String\u0026gt;) -\u0026gt; Observable\u0026lt;SearchModel\u0026gt; ) : MvpBasePresenter\u0026lt;SearchView\u0026gt;() { lateinit var subscription: Subscription override fun attachView(view: SearchView) { super.attachView(view) subscription = modelFunc( // model()  view.searchIntent() // intent()  ) .observeOn(AndroidSchedulers.mainThread()) .subscribe( // view()  view.showData(), view.showError() ) } override fun detachView(retainInstance: Boolean) { super.detachView(retainInstance) subscription.unsubscribe() } } That\u0026rsquo;s it. we still have view( model( intent() ) ), but this time the view, presenter and \u0026ldquo;business logic\u0026rdquo; are super slim, decoupled, reusable, testable and maintainable.\nThe problem with side effects Are we done now? Almost. We haven\u0026rsquo;t discussed yet who is responsible to display and hide the ProgressBar while loading in background data. In MVP it would be the responsibility from Presenter to coordinate the view\u0026rsquo;s state \u0026hellip; ah, the View\u0026rsquo;s state \u0026hellip; do you hear the alarm bells ringing?\nLet\u0026rsquo;s see, how could we do that in MVP? We would simply add a method to the MVP View interface like this:\ninterface SearchView : MvpView { ... fun showLoading(): (Any) -\u0026gt; Unit // RxJava Action1 } class SearchActivity : SearchView, MvpActivity\u0026lt;SearchView, SearchPresenter\u0026gt;() { ... override fun showData(): (SearchModel) -\u0026gt; Unit = { adapter.items = it.results adapter.notifyDataSetChanged() loadingView.visibility = View.GONE } override fun showLoading(): (Any) -\u0026gt; Unit = { loadingView.visibility = View.VISIBLE } } Then the presenter could do something like this:\nclass SearchPresenter @Inject constructor( val modelFunc: (Observable\u0026lt;String\u0026gt;) -\u0026gt; Observable\u0026lt;SearchModel\u0026gt; ) : MvpBasePresenter\u0026lt;SearchView\u0026gt;() { lateinit var subscription: Subscription override fun attachView(view: SearchView) { super.attachView(view) subscription = modelFunc( // model()  view.searchIntent() // intent()  .doOnNext(view.showLoading()) // Show loading  ) .observeOn(AndroidSchedulers.mainThread()) .subscribe( // view()  view.showData(), view.showError() ) } override fun detachView(retainInstance: Boolean) { super.detachView(retainInstance) subscription.unsubscribe() } } What\u0026rsquo;s wrong with that code? I mean we do that in MVP all the time, right? The problem is that now our whole system has two states: The view\u0026rsquo;s state and the state of the model itself. Moreover, the view\u0026rsquo;s state is caused by a side effect. Do you remember the definition of model() function? Only the model() function is allowed to change the internal application state (with side effects). But the code shown above contradicts with that principle.\nSo how to solve that? From my point of view there are two options:\nThe first option is to create a MVI flow just for LoadingView (ProgressBar as View). We talked about MVC\u0026rsquo;s original definition by Reenskaug. Do you remember? Every GUI widget has it\u0026rsquo;s own Controller. But who says that every controller has to have his own model? We could share the Model (or observe just a certain part of a model). Guess what, sharing an Observable is pretty easy in RxJava, because there is an operator for that called .share(). So we could have our own MVI / MVP flow with just the ProgressBar as View. In general: we should stop thinking that the whole screen is one huge View with one Controller / Presenter / ViewModel and one underlying Model.\nThe second option and in my opinion the better option is to have one Model that also propagates his state changes, i.e. before loading data from github the model() function would change the model to it\u0026rsquo;s internal state \u0026ldquo;loading\u0026rdquo;:\ndata class SearchModel( val isLoading: Boolean, // true while loading data, false when done  val searchTerm: String, val results: List\u0026lt;GithubRepo\u0026gt;) Now SearchEngine would first change the model to SearchModel (true, \u0026hellip;) before starting to load the data (and propagate this state change as usual via observable chain which will update the view and finally display the ProgressBar) and then set it to SearchModel (false, \u0026hellip;) after having retrieved the new data from github backend.\nScreen Orientation Changes Sir Tony Hoare introduced null references in ALGOL W back in 1965. Retrospective he call this his \u0026ldquo;Billion Dollar Mistake\u0026rdquo; (NullpointerException). I think android\u0026rsquo;s \u0026ldquo;Billion Dollar Mistake\u0026rdquo; is to destroy the whole Activity on screen orientation changes. Dealing with screen orientation changes that way it is today in android is really painful. Furthermore, it makes software architecture on android much harder then it has to be.\nMVI makes no difference here. On screen orientation changes everything will get lost. So that means that our Model which is representative for the state of a MVI powered app will be lost. We could put that in a retaining Fragment somehow and put it back in right place after screen orientation change. But that only solves half of the problem, because whenever the activity gets destroyed we also have to unsubscribe our observable chain otherwise we will run into memory leaks (we use view.searchIntent()). So what if we start a async background task and want to ensure that it doesn\u0026rsquo;t get canceled in our model() function? Well we could use .cache() operator or Subjects like ReplaySubject or keep a static map as cache for background tasks. In a nutshell, yes there are ways (I would rather call them workarounds) but I\u0026rsquo;m not very happy with those solutions. We also have to take into account that our model() function may have to distinguish between initial empty state (.startWith(\u0026quot;\u0026quot;)) and state after screen orientation changes and process deaths (do we have to make our model Parcelable to save it persistently in a Bundle?). You see, it\u0026rsquo;s getting out of hand very quickly and introduces more complexity than it has to be.\nTL;DR: There might be \u0026ldquo;workarounds\u0026rdquo; for screen orientation changes, but I can\u0026rsquo;t recommend a clean solution for dealing with screen orientation changes on android.\nSummary Model-View-Intent is a very clean way to deal with application states and UI changes. An unidirectional data flow (cycle), predictable states and immutability are the exciting thing about MVI. Composing functions leads to clean and reusable code. I think we can mix MVI with MVP as we did in this example, because I still think that MVP helps to separate your concerns. Furthermore, I can\u0026rsquo;t highlight enough the importance of a Presentation Model and transforming the Model into a Presentation Model is quite easy with RxJava (just add a .map()) but improves your code a lot and reduces complexity of your View layer.\nSee the thing with MVI is like with any other software architecture: MVI gives you an idea, but there is still space for personal preferences and interpretation. One can add as many layers as needed. For example, the model() function could internally be composed by multiple functions (one might call them use cases or interactors, just functional). One could add Action data structures to decouple things between intent() and model() even more. But keep in mind: don\u0026rsquo;t over-engineering things! Software architecture is a continuous evolution:\n Stay hungry, stay foolish, think outside the box!\n The source code for the sample app shown in this blog post can be found on Github\n","permalink":"https://hannesdorfmann.com/android/model-view-intent/","tags":["android","software-architecture"],"title":"Model-View-Intent on Android"},{"categories":["Android"],"contents":"The usage of Fragments in Android apps is highly controversial. While some developers love them, others hate them. In this blog post I will give you a short introduction of how to use Mosby 3.0 to build MVP base screens and square\u0026rsquo;s Flow library as navigation stack replacement.\nPreface: Usually I use Fragments in my apps and 99% of the time they work well. However, I do understand developers who are advocating against Fragments. We want build the best apps we are able to and if Fragments are a source for errors then this 1% is probably to much.\nIn this blog post I will show you how to write a little atlas app entirely without Fragments by using Mosby and Flow. Our app has just two screens: A list of countries and a details screen where information about a certain country is displayed. Let\u0026rsquo;s have a look at a short demo video (please note that this demo app is able to deal with screen orientation changes):\n  Flow for navigation The app itself will be a single Activity. As already said, there are basically two screens the user can navigate to:\n CountriesListLayout: Displays a list of countries. The user can click on a country to display details about this country. CountryDetailsLayout: Displays details about a certain country like population, currency and some photos.  Dispatcher and Keys To integrate flow in your activity you have to do the following (kotlin programming language):\nclass MainActivity : AppCompatActivity() { override fun attachBaseContext(baseContext: Context) { val flowContextWrapper = Flow.configure(baseContext, this) .dispatcher(AtlasAppDispatcher(this)) .defaultKey(CountriesScreen()) .keyParceler(AtlasAppKeyParceler()) .install() super.attachBaseContext(flowContextWrapper) } override fun onBackPressed() { if (!Flow.get(this).goBack()) { super.onBackPressed(); } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } } Let\u0026rsquo;s start with an easy thing to spot: We override onBackPressed() to forward the press of android\u0026rsquo;s back button to Flow.\nJust for completeness, R.layout.activity_main is just a FrameLayout \u0026ldquo;container\u0026rdquo;:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;FrameLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/container\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; /\u0026gt; Next, we will focus on how to configure Flow. To install Flow in our Activity we have to override attachBaseContext(). Why? Well, internally Flow will create a ContextWrapper and we have to use that special context wrapper returned by Flow for our Activity by calling super.attachBaseContext(flowContextWrapper).\nFlow is highly customizable which on one hand is great and allows you to be very flexible. On the other hand that means that you have to write some \u0026ldquo;boilerplate\u0026rdquo; code. To tell Flow how to navigate in our app we have to define a Dispatcher. The Dispatcher is responsible to \u0026ldquo;dispatch\u0026rdquo; changes on Flow\u0026rsquo;s navigation (history) stack.\nclass AtlasAppDispatcher(private val activity: Activity) : Dispatcher { override fun dispatch(traversal: Traversal, callback: TraversalCallback) { val destination = traversal.destination.top\u0026lt;Any\u0026gt;() // destination key  val layoutRes = when (destination) { is CountriesScreen -\u0026gt; R.layout.screen_countries is CountryDetailsScreen -\u0026gt; R.layout.screen_countrydetails else -\u0026gt; throw IllegalStateException(\u0026#34;Unknown screen $destination\u0026#34;) } val newView = LayoutInflater.from(traversal.createContext(destination, activity)) .inflate(layoutRes, container, false) // Update container: remove oldView, insert newView  val container = activity.findViewById(R.id.container) as ViewGroup // Remove current screen from container  if (traversal.origin != null \u0026amp;\u0026amp; container.childCount \u0026gt; 0) { val currentScreen = container.getChildAt(0); // Save the state manually  traversal.getState((traversal.origin as History).top()).save(currentScreen) container.removeAllViews() // remove oldView  } // Restore state before adding view (i.e. caused by onBackPressed)  traversal.getState(traversal.destination.top()).restore(newView) // add new screen  container.addView(newView) callback.onTraversalCompleted() // Tell Flow that we are done  } } Alright, let\u0026rsquo;s discuss some key aspects of the code shown above: As you see we have to implement Flow\u0026rsquo;s interface Dispatcher with the method dispatch(). This method will be invoked whenever we use Flow to navigate through the app and we have to specify (manually) how to apply the navigation changes to your view. In the Atlas app we have a \u0026ldquo;container\u0026rdquo; (FrameLayout) and whenever we navigate from screen to the next screen (or back to previous screen) we simply remove the current screen from the container and add the new screen. Flow gives us a Traversal object as parameter which contains all the information we need to apply navigation stack changes. We get a \u0026ldquo;key\u0026rdquo; destination = traversal.destination.top() from Flow. Every \u0026ldquo;screen\u0026rdquo; is identified by a key and you have to make a mapping from key to a android.view.View like we do here:\nval layoutRes = when (destination) { is CountriesScreen -\u0026gt; R.layout.screen_countries is CountryDetailsScreen -\u0026gt; R.layout.screen_countrydetails else -\u0026gt; throw IllegalStateException(\u0026#34;Unknown screen $destination\u0026#34;) } You may ask yourself \u0026ldquo;what is a key\u0026rdquo;? Basically everything (java.lang.Object) can be used as a key for a screen in Flow. It seems to be good practice that \u0026ldquo;keys\u0026rdquo; are named with \u0026ldquo;Screen\u0026rdquo; suffix. In our atlas app we have two \u0026ldquo;screens\u0026rdquo; we can navigate to. Hence we have two \u0026ldquo;key\u0026rdquo; classes named CountriesScreen and CountryDetailsScreen. This \u0026ldquo;key\u0026rdquo; classes have two responsibilities: First, as already discussed a key maps to an android view, and second the key contains all the required data the screen needs to display. I think that can be compared to fragment arguments. For example the CountryDetailsScreen contains an id (country id) which then is used in the corresponding view to load the data for the given country id.\nclass CountryDetailsScreen(val countryId: Int) : Parcelable { private constructor(p: Parcel) : this(p.readInt()) override fun writeToParcel(parcel: Parcel, p1: Int) { parcel.writeInt(countryId) } override fun describeContents(): Int = 0 companion object { val CREATOR = object : Parcelable.Creator\u0026lt;CountryDetailsScreen\u0026gt; { override fun createFromParcel(p: Parcel): CountryDetailsScreen = CountryDetailsScreen(p) override fun newArray(size: Int): Array\u0026lt;out CountryDetailsScreen\u0026gt;? = Array(size, { CountryDetailsScreen(-1) }) } } } I guess I know your next question: \u0026ldquo;Why do we need to implement the parcelable interface?\u0026rdquo;. I have said earlier that \u0026ldquo;everything\u0026rdquo; can be a key and that\u0026rsquo;s still true. However, at some point (during process death, i.e. activity gets destroyed while in background) Flow has to save your keys persistently in a Bundle (as Parcelable) to be able to restore the navigation stack history after your activity gets restarted (i.e. activity comes in the foreground again). Therefore, we have to provide a KeyParceler to Flow which is responsible to write and read a \u0026ldquo;key\u0026rdquo; as parcelable. The easiest way to do so is to make the \u0026ldquo;key\u0026rdquo; like CountryDetailsScreen itself parcelable because then our KeyParceler implementation is basically just casting the \u0026ldquo;key\u0026rdquo; object like we do in our atlas app:\nclass AtlasAppKeyParceler : KeyParceler { override fun toParcelable(key: Any?): Parcelable = key as Parcelable override fun toKey(parcelable: Parcelable) : Any = parcelable } To sum it up, to use Flow in our Activity we have to do:\nclass MainActivity : AppCompatActivity() { override fun attachBaseContext(baseContext: Context) { val newBase = Flow.configure(baseContext, this) .dispatcher(AtlasAppDispatcher(this)) .defaultKey(CountriesScreen()) .keyParceler(AtlasAppKeyParceler()) .install() super.attachBaseContext(newBase) } ... } With .defaultKey(CountriesScreen()) we specify what is our start key / screen:\nclass CountriesScreen : Parcelable // Doesn\u0026#39;t have any data, it\u0026#39;s just an empty object MVP with Mosby Alright, so far we have talked about how to setup Flow as navigation stack replacement. We haven\u0026rsquo;t discussed yet how to build the UI without Fragments. We simply write custom Views by extending from ViewGroups like FrameLayout etc. Furthermore, we want to have a separation of concerns (separation from UI and business logic). This is the point where Mosby comes in.\nMosby is a Model-View-Presenter (MVP) library for Android. For our atlas app we will use Mosby 3.0, which is not released at the time of writing this blog post. However, 3.0.0-SNAPSHOT is available and changes until the final 3.0 release will mainly be \u0026ldquo;under the hood\u0026rdquo;. In other words, the API is mostly stable (and compatible to Mosby 2.0).\nScreen orientation changes One of the most loved features of Mosby is that Presenters can survive screen orientation changes. Additionally, Mosby has a tiny companion object to the Presenter and View called ViewState. Typically, in MVP (passive view) the Presenter coordinates the View. So the Presenter tells the View to display a ProgressBar like view.showLoading() while loading data and then the RecyclerView view.showContent() once the data has been loaded. Mosby\u0026rsquo;s ViewState is some kind of hook sitting between Presenter and View and keeps track of all the methods the presenter has invoked on the view. The idea is that after a screen orientation change we can \u0026ldquo;apply\u0026rdquo; the ViewState and invoke the same methods on the View to get back to the UI state as before the screen orientation change.\nIf you have used Mosby 2.0 before this is nothing new to you. This feature was already available for Activities and Fragments. With Mosby 3.0 this feature is now fully supported for subclasses of android.view.ViewGroup like FrameLayout, RelativeLayout and so on (there was already partial support for that in Mosby 2.0).\nLet\u0026rsquo;s have a look how we have implemented the screen that displays a list of countries:\nclass CountriesListLayout(c: Context, atts: AttributeSet) : CountriesView, MvpViewStateFrameLayout\u0026lt;CountriesView, CountriesPresenter\u0026gt;( c, atts) { private val recyclerView: RecyclerView by bindView(R.id.recyclerView) private val swipeRefreshLayout: SwipeRefreshLayout by bindView(R.id.swipeRefreshLayout) private val errorView: View by bindView(R.id.errorView) private val loadingView: View by bindView(R.id.loadingView) private val adapter = CountriesAdapter( { // OnClickListener, navigates to details screen  country -\u0026gt; Flow.get(this).set(CountryDetailsScreen(country.id)) }) init { // inflates the layout containing a SwipeRefreshLayout, RecyclerView, ProgressBar etc.  LayoutInflater.from(context).inflate(R.layout.recycler_swiperefresh_view, this, true) recyclerView.adapter = adapter recyclerView.layoutManager = LinearLayoutManager(context) errorView.setOnClickListener { loadData(false) } swipeRefreshLayout.setOnRefreshListener { loadData(true) } } fun loadData(pullToRefresh: Boolean) = presenter.loadCountries(pullToRefresh) override fun createPresenter(): CountriesPresenter = AtlasApplication.getComponent(context).countriesPresenter() // We use dagger 2  override fun createViewState(): ViewState\u0026lt;CountriesView\u0026gt; = RetainingLceViewState\u0026lt;List\u0026lt;Country\u0026gt;, CountriesView\u0026gt;() override fun showLoading(pullToRefresh: Boolean) { loadingView.visibility = VISIBLE errorView.visibility = GONE swipeRefreshLayout.visibility = GONE } override fun showContent() { loadingView.visibility = GONE errorView.visibility = GONE swipeRefreshLayout.visibility = VISIBILE swipeRefreshLayout.isRefreshing = false } override fun showError(e: Throwable?, pullToRefresh: Boolean) { swipeRefreshLayout.visibility = GONE loadingView.visibility = GONE errorView.visibility = VISIBLE swipeRefreshLayout.isRefreshing = false } override fun setData(data: List\u0026lt;Country\u0026gt;) { adapter.items = data adapter.notifyDataSetChanged() } } For more details about Mosby you should read Mosby\u0026rsquo;s documentation. As you might have already noticed we extend from MvpViewStateFrameLayout which is provided by Mosby. Since Mosby follows the delegation principle is quite easy to make every ViewGroup work Mosby. All you have to do is to implement ViewGroupViewStateDelegateCallback in your custom ViewGroup class and forward \u0026ldquo;lifecycle events\u0026rdquo; like onAttachedToWindow() and onDetachedFromWindow() to Mosby\u0026rsquo;s ViewGroupMvpDelegate. This sounds more complex than it actually is. Let\u0026rsquo;s have a look at MvpViewStateFrameLayouts source code:\npublic abstract class MvpViewStateFrameLayout\u0026lt;V, P\u0026gt; extends FrameLayout implements ViewGroupViewStateDelegateCallback\u0026lt;V, P\u0026gt; { private ViewGroupMvpDelegate mvpDelegate = new ViewGroupMvpViewStateDelegateImpl\u0026lt;V, P\u0026gt;(this); @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); mvpDelegate.onAttachedToWindow(); } @Override protected void onDetachedFromWindow() { super.onDetachedFromWindow(); mvpDelegate.onDetachedFromWindow(); } // Implement in subclass  abstract ViewState\u0026lt;V\u0026gt; createViewState(); abstract P createPresenter(); } The CountriesPresenter loads a Listfrom Atlas (business logic, injected by dagger 2) and we use RxJava to connect the dots:\nclass CountriesPresenter @Inject constructor(val atlas: Atlas) : MvpBasePresenter\u0026lt;CountriesView\u0026gt;() { var subscription: Subscription? = null fun loadCountries(pullToRefresh: Boolean) { view?.showLoading(pullToRefresh) subscription = atlas.getCountries() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe( { view?.setData(it) }, { view?.showError(it, pullToRefresh) }, { view?.showContent() } ) } override fun detachView(retainInstance: Boolean) { super.detachView(retainInstance) if (!retainInstance) { subscription?.unsubscribe() } } } As already said, in Mosby the Presenter survives screen orientation changes and the view gets simply attached and detached from the presenter. Mosby is smart enough to detect when the user has been navigated to another screen so that the Presenter will be destroyed permanently. The screen displaying a country details is basically the same and therefore not worth posting the code here again. You can checkout the whole sample code on github.\nSummary The aim of this blog post was to demonstrate that we can build an app without Fragments by using Flow for navigation and Mosby for MVP. Both, Flow and Mosby can deal with process deaths (Activity destroyed in background), however, Mosby requires to make the ViewState parcelable (that means that the loaded data, i.e. list of country, has to implement parcelable as well, see documentation). I, personally, think that 95% of app developers just want that their app survive screen orientation changes painlessly and therefore a \u0026ldquo;simple view state\u0026rdquo; (not implementing parcelable) is enough (if process death occurs then data will be reloaded entirely).\nDepending on your app, Flow may requires you to write a lot of code (especially for Dispatcher). Nevertheless, Flow is really powerful (still in 1.0-alpha) and we haven\u0026rsquo;t discussed all features of Flow in detail like complex dispatchers with views on top of each other like dialogs or cases where you don\u0026rsquo;t have a single \u0026ldquo;container\u0026rdquo; to display a view but rather something similar as child-fragments (Fragment\u0026rsquo;s in Fragments) with back button support or Flow services or how does Flow save the instance state (you have to save and restore that manually, see AtlasAppDispatcher). Also \u0026ldquo;keys\u0026rdquo; have to override equals() and hashCode() properly. In a nutshell: Flow is not designed for android dev beginners, but the benefit of Flow is huge (if you hate fragments)!\nIf you are looking for something more simple then Flow you might find Pancakes interesting which is also a navigation stack library but not as powerful as Flow. With Pancakes you would provide a ViewFactory for each \u0026ldquo;screen\u0026rdquo; like this:\nclass CountriesListLayoutFactory implements ViewFactory { @Override public View createView(Context context, ViewGroup container) { return LayoutInflater.from(context).inflate(R.layout.screen_countries, container, false); } } Mosby should work with Pancakes (and any other navigation stack library) as great as with Flow.\nOne last thing: people asked me why Mosby doesn\u0026rsquo;t provide it\u0026rsquo;s own navigation stack implementation? The reason is that Mosby should and will ever be that tiny little MVP library. Take Mosby as a base scaffold to build your app on top of it with that development stack you like the most (like Flow or Pancakes for navigation or even with Fragments). See the thing is, since Mosby is a library (and not a framework) you can use as much or as little as you want from Mosby\u0026rsquo;s functionality. Furthermore, implementing a clean navigation stack library is not that easy as it seems or why do you think that the brilliant guys over at square took quite a long time to design and implement Flow?\n","permalink":"https://hannesdorfmann.com/android/let-mosby-flow/","tags":["android"],"title":"Let Mosby Flow - An alternative to Fragments"},{"categories":["Android"],"contents":"Last week I was honored to be guest at Artem Zinnatullin\u0026rsquo;s podcast The Context where we talked about software architecture on android. In this episode I have highlighted how important a presentation model in MVP is by giving an example how to deal with RecyclerView Adapters dataset changes. Afterwards people asked me how exactly do I apply animated dataset changes and why a presentation model is helpful in this case.\nBefore we dive into the presentation model part, here are the good news: I have put all those things together and bundled it into a library called AdapterCommands.\nSo what is this library all about? Well, RecyclerView has this nice component called ItemAnimator which is responsible to animate items of RecyclerView. There is already build in support for animations when using adapter.setHasStableId(true). However, if you don\u0026rsquo;t have stable id\u0026rsquo;s then calling notifyDatasetChanged() will not run any animation. For example, let\u0026rsquo;s say we are displaying a list of items in a RecyclerView. When adding a new item we can call adapter.notifyItemInserted(position) rather than just adapter.notifyDatasetChanged() to specify what exactly has been changed (we have inserted an item). Now ItemAnimator kicks in and animates the item in.\nAdapterCommands basically implements the command pattern in which a Command object is used to encapsulate all information needed to perform an action. So instead of calling adapter.notifyItemInserted(position) directly this library provides a ItemInsertedCommand which looks like this:\npublic class ItemInsertedCommand implements AdapterCommand { private final int position; public ItemInsertedCommand(int position) { this.position = position; } @Override public void execute(RecyclerView.Adapter\u0026lt;?\u0026gt; adapter) { adapter.notifyItemInserted(position); } } As you see this class implements the interface AdapterCommand which has a execute(adapter) method. This library offers such commands for all this actions like ItemRemovedCommand, ItemChangedCommand, ItemRemovedCommand and so on. This library also provides a class AdapterCommandProcessor that takes a List\u0026lt;AdapterCommand\u0026gt; and executes each command:\npublic class AdapterCommandProcessor { private final RecyclerView.Adapter\u0026lt;?\u0026gt; adapter; public AdapterCommandProcessor(RecyclerView.Adapter\u0026lt;?\u0026gt; adapter) { this.adapter = adapter; } public void execute(List\u0026lt;AdapterCommand\u0026gt; commands) { for (int i = 0; i \u0026lt; commands.size(); i++) { commands.get(i).execute(adapter); } } } I know, it\u0026rsquo;s not that impressive at first glance. So what is the advantage of this pattern? Quite often an app displays a list of items in a RecyclerView and the underlying dataset gets changed, for instance in combination with SwipeRefreshLayout the user can reload an updated list of items (i.e. load items from backend). What do we do with the new list? Just call adapter.notifyDatasetChanged() to inform that the new list of items should be displayed? But what about the ItemAnimator? The AdapterCommands library offers DiffCommandsCalculator class. This class calculates the difference of the old list and the new list and returns a List\u0026lt;AdapterCommand\u0026gt; that then can be executed by an AdapterCommandProcessor. Let\u0026rsquo;s have a look at the demo:\n  As you see in the demo video above, whenever we click on the add or remove button item changes are animated. The implementation looks like this:\npublic class MainActivity extends AppCompatActivity implements SwipeRefreshLayout.OnRefreshListener { @Bind(R.id.recyclerView) RecyclerView recyclerView; List\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;Item\u0026gt;(); Random random = new Random(); ItemAdapter adapter; // RecyclerView adapter  AdapterCommandProcessor commandProcessor; DiffCommandsCalculator\u0026lt;Item\u0026gt; commandsCalculator = new DiffCommandsCalculator\u0026lt;Item\u0026gt;(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); refreshLayout.setOnRefreshListener(this); adapter = new ItemAdapter(this, items); recyclerView.setAdapter(adapter); recyclerView.setLayoutManager(new GridLayoutManager(this, 4)); commandProcessor = new AdapterCommandProcessor(adapter); } @OnClick(R.id.add) public void addClicked() { int addCount = random.nextInt(3) + 1; for (int i = 0; i \u0026lt; addCount; i++) { int position = random.nextInt(items.size()); Item item = new Item(id(), randomColor()); items.add(position, item); } updateAdapter(); } @OnClick(R.id.remove) public void removeClicked() { int removeCount = random.nextInt(3) + 1; for (int i = 0; i \u0026lt; removeCount; i++) { int position = random.nextInt(items.size()); Item item = items.remove(position); } updateAdapter(); } private void updateAdapter() { // calculate the difference to previous items  List\u0026lt;AdapterCommand\u0026gt; commands = commandsCalculator.diff(items); commandProcessor.execute(commands); } } Presentation Model I guess you get the point, but how is this related to the presentation model and MVP? In MVP the Presenter generates (optional) a PresentationModel which is yet another data model optimized for the view containing all the information the view needs to know so that the view can simply take this presentation model and can display it directly without having to calculate things. More information can be found here.\nSo lets assume we are building an app for a newspaper by applying MVP, Retrofit to load a list of NewsItems and use RxJava to connect the dots. Instead of passing a List\u0026lt;NewsItem\u0026gt; directly from Presenter to View we introduce a NewsItemsPresentationModel that looks like this:\nclass NewsItemsPresentationModel { List\u0026lt;NewsItem\u0026gt; newsItems; List\u0026lt;AdapterCommand\u0026gt; adapterComamnds; } With RxJava it\u0026rsquo;s quite easy to transform the List\u0026lt;NewsItem\u0026gt; to a NewsItemsPresentationModel by defining a Func1 like this:\nclass PresentationModelTransformer extends Func1\u0026lt; List\u0026lt;NewsItem\u0026gt;, NewsItemsPresentationModel\u0026gt; { private DiffCommandsCalculator\u0026lt;NewsItem\u0026gt; diffCalculator = new DiffCommandsCalculator\u0026lt;\u0026gt;(); @Override public NewsItemsPresentationModel call(List\u0026lt;NewsItem\u0026gt; items){ List\u0026lt;AdapterCommand\u0026gt; commands = diffCalculator.diff(items); return new PresentationModelTransformer(items, commands); } } The Presenter looks like this:\nclass NewsItemsPresenter extends MvpBasePresenter\u0026lt;NewsItemView\u0026gt; { private BackendApi backendApi; // Retrofit service to load news items  private PresentationModelTransformer pmTransformer = new PresentationModelTransformer() public void loadItems(){ view.showLoading(); backendApi.getNewsItems() .map(pmTransformer) // Creates NewsItemsPresentationModel  .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber() { public void onNext(NewsItemsPresentationModel pm){ view.setNewsItems(pm); view.showContent(); } public void onError(Throwable t){ view.showError(t); } }); } } As you see with RxJava we can use map() operator to transform the model into a presentation model. Another nice thing to note is that this transformation and the calculation of the difference runs on the background thread (Schedulers.io()).\nThe View is now very stupid simple and doesn\u0026rsquo;t contain such complex calculations like where to insert new items from the list and so on. The View gets the NewsItemsPresentationModel from presenter and has everything the View needs to display the new list (with animations):\nclass NewsItemsActivity extends Activity implements NewsItemView, OnRefreshListener { @Bind(R.id.recyclerView) RecyclerView recyclerView; NewsItemsPresenter presenter; AdapterCommandProcessor commandProcessor; @Override protected void onCreate(Bundle b){ super.onCreate(b); setContentView(R.layout.activity_newsitems); presenter = new NewsItemsPresenter(); Adapter adapter = new NewsItemsAdapter(); commandProcessor = new AdapterCommandProcessor(adapter); recyclerView.setAdapter(adapter); presenter.loadItems(); } @Override public void onRefresh(){ presenter.loadItems(); } @Override public void setNewsItems(NewsItemsPresentationModel pm) { adapter.setItems(pm.newsItems); commandProcessor.execute(pm.commands); } ... } Hopefully, you see now that the View is pretty dumb, decoupled, easier to maintain and to test.\nBehind the scenes You might think that you don\u0026rsquo;t need a third party library to do that. Indeed, this is true for simple use cases where you know that lists are chronological ordered and items from the new list will be always added on top (or at the end) of the old list. In that case you simply would write diff = newList - oldList and then call adapter.notifyItemRangeInserted(0, diff.size()), right? Also in this use case you could use this library simply to not write command classes and command processor again by yourself. But what if you implement such a newspaper app as described above and a news item\u0026rsquo;s title that already was in the old list has been changed compared to the new list, so that adapter.notifyItemChanged(position) must be called? Or what if lists are not always sorted the same way? What if an item has been removed?\nIn that case DiffCommandsCalculator is the drop in solution. But how does it actually works? Let\u0026rsquo;s compare two lists:\noldList newList A A B B C B2 D C E F F G G E H We have inserted B2, removed D and moved E and inserted H at the end of the list. Let\u0026rsquo;s compute the difference:\n\u0026gt; B2 2 \u0026lt; D 3 \u0026lt; E 4 \u0026gt; E 6 \u0026gt; H 7 The first column indicates whether it was an insertion \u0026gt; or a deletion \u0026lt;. The second column is the affected item and the last column is the index of the list item (beginning by zero). This schema seems familiar, doesn\u0026rsquo;t it? You see something like this almost everyday if you use git and diff (command line tool, GUIs also available) to detect and resolve merge conflicts. DiffCommandsCalculator implements the same algorithm as diff. This kind of problem is called longest common subsequence problem. On arbitrary number of input data solving this problem is NP-hard. Fortunately, we have fixed size of list and items count. Therefore, we can implement an algorithm that uses the concept of dynamic programming that solves this problem in polynomial time O(n*m) (where n is the number of elements in oldList and m the number of elements in newList). That sounds really theoretically, right? Actually, it is easier to implement than you might think. I found this youtube video helpful.\nSummary This little library called AdapterCommands is available on maven central and the source code can be found on Github. This library is the little brother of AdapterDelegates (favor composition over inheritance) and helps you to animate dataset changes (if you don\u0026rsquo;t have stable ids) in your RecyclerView by implementing the command pattern. The main difference between this library and adapter.setHasStableId(true) is that the later one relies on unique and stable ids for each item in the dataset, whereas AdapterCommands uses java\u0026rsquo;s equals() method for each item to determine dataset changes. Moreover, this works quite nice with MVP and PresentationModel as shown here in this blog post. Keep in mind that the runtime of comparing each element of oldList with newList is O(n*m) and therefore you should consider run DiffCommandsCalculator on a background thread if you have many items in your dataset. RxJava offers a nice threading model and plays very nice into MVP and presentation model as shown above and is therefore my recommendation of how to connect all the things together.\nN.B. In Artem Zinnatullin\u0026rsquo;s podcast \u0026ldquo;The Context\u0026rdquo; I have said that I don\u0026rsquo;t do a lot of functional UI testing, because I don\u0026rsquo;t see the need to do so. My argument was that I implement my apps according MVP and my Views are pretty dumb, so there can\u0026rsquo;t go much wrong in View layer. Using AdapterCommands emphasizes this thesis because I do test my Presenters and PresentationModel. Furthermore, since the AdapterCommands library itself is already tested I can relay on that and have one less test to write in my app. However, that doesn\u0026rsquo;t mean that you should not write functional UI Tests! I would write functional UI Tests (i.e. with Espresso) if compiling and executing this tests wouldn\u0026rsquo;t take minutes. It wouldn\u0026rsquo;t hurt to test the view layer too, even if the View is dumb and there can\u0026rsquo;t go much wrong. I believe in TDD. However, when a test takes more than 10 seconds to execute, the whole TDD workflow and productivity gets destroyed. Hence I ensure that from Presenter downwards everything is tested and that the dumb View gets an optimized presentation model so that there can\u0026rsquo;t go much wrong.\n","permalink":"https://hannesdorfmann.com/android/adapter-commands/","tags":["android","algorithms","design-patterns"],"title":"AdapterCommands"},{"categories":["Android"],"contents":"This is the second part of how we could refactor the Plaid app open sourced by Nick Butcher. In this part we are going to enhance the MVP architecture described in the first part to become truly reactive.\nPreface: I started the refactoring with the strong belief that I can refactor the whole app. Surprisingly (ironic), it turns out that I was a very naive man. I simply have underestimated the complexity of the app and the number of features. Therefore, I have started writing this blog post even if not everything described here is implemented (refactored). I just want to give some ideas how this could be implemented. My refactored code can be found on github as well.\nRecap from first part This is the second part of a blog series about refactoring plaid app. In the first part we have applied Model-View-Presenter and have introduced an ItemsLoader for loading items from different backend endpoints by invoking RouteCallers. Please read the first part for more details.\nPeople also aksed me if there is a need for yet another MVP blog post as there are already many of them availabale. Well, my intention is not write about MVP. Rather I want to discuss how to build a \u0026ldquo;truly reactive\u0026rdquo; app (with MVP on top). Let\u0026rsquo;s continue where we left off.\nSource - Filter In the app\u0026rsquo;s home screen you can open a drawer on the right side of the screen (or by clicking on the filter icon in the Toolbar) to enable/disable different backend endpoints we load items from. We call a backend endpoint Source. So we have sources like \u0026ldquo;Dribbble Popular\u0026rdquo;, \u0026ldquo;Dribbble Recent\u0026rdquo;, \u0026ldquo;Designer News Popular\u0026rdquo; and so on.\nPlease raise your hand if you have used SharedPreferences to save bunch of data and not only \u0026ldquo;user preferences\u0026rdquo;. I\u0026rsquo;m definitely guilty of having uses SharedPreferences for that kind of stuff, so did Nick Butcher for storing Sources. The problem is that the user can add (we will talk about this in a minute), update (enable / disable) and remove Sources. Sounds that a database suits better, right?\nDatabase Let\u0026rsquo;s refactor that and replace SharedPreferences with a SQLiteDatabase. Databases are hard. So we could either write pure sql statements or choose the right library to deal with databases. There are many libraries out there, some are better than the others. Since we use RxJava we certainly want to use a library with first class RxJava support. In my opinion ORM are not the right way to go. Why? Because usually ORMs have to be designed to work well on the average use case. But almost every app has a special use case. For example writing an efficient query which resolves relations to other objects (SQL joins?) is already hard enough in native SQL. But how do you do that when using a certain ORM library? You have to spend a lot of time to learn how the ORM library works to write efficient queries. Whenever you change ORM library you have to learn the new ORM library again and again. Therefore, I prefer to work without ORM libraries and to write raw SQL queries and the only thing I have to know is SQL.\nHence, we will use SQLBrite from Square which is a lightweight wrapper around SQLiteOpenHelper with support for RxJava. We don\u0026rsquo;t want to deal with Cursors and ContentValues. Therefore, we use SQLBrite-DAO which provides some abstractions like DAO (Data Access Object) and an annotation processor based tiny object mapper (Cursor to object, not ORM) and ContentValues generator. If you are looking for a more high level solution with similar functionality you should have a look at StorIO, but I\u0026rsquo;m more a low level guy so we will use SQLBrite + SQLBrite-DAO.\nWe define a class Source like this:\n@ObjectMappable class Source() { // Unfortunately data class are not supported yet by sqlbrite-dao  object ID { // ID\u0026#39;s for predefined Sources  const val UNKNOWN_ID = -1L const val DESIGNER_NEWS_POPULAR = -2L const val DESIGNER_NEWS_RECENT = -3L const val DRIBBBLE_POPULAR = -4L const val DRIBBBLE_FOLLOWING = -5L const val DRIBBLE_MY_SHOTS = -6L const val DRIBBLE_MY_LIKES = -7L const val DRIBBLE_RECENT = -8L const val DRIBBLE_DEBUTS = -9L const val DRIBBLE_ANIMATED = -10L const val DRIBBLE_MATERIAL = -11L const val PRODUCT_HUNT = -12L } @Column(SourceDao.COL.ID) var id: Long = ID.UNKNOWN_ID @Column(SourceDao.COL.ORDER) var order: Int = 0 @Column(SourceDao.COL.ENABLED) var enabled: Boolean = false @Column(SourceDao.COL.AUTH_REQUIRED) var authenticationRequired = false @Column(SourceDao.COL.BACKEND_ID) var backendId: Int = -1 @Column(SourceDao.COL.NAME) var name: String? = null @Column(SourceDao.COL.NAME_RES) var nameRes: Int = -1 } @ObjectMappable and @Column are annotations from the SQLBrite-DAO\u0026rsquo;s annotation processor. Next we define a DAO to manipulate and query Source from database like this:\nclass SourceDao : Dao() { object COL { const val ID = \u0026#34;id\u0026#34; const val ORDER = \u0026#34;orderPosition\u0026#34; const val ENABLED = \u0026#34;enabled\u0026#34; const val AUTH_REQUIRED = \u0026#34;authRequired\u0026#34; const val BACKEND_ID = \u0026#34;backendId\u0026#34; const val NAME = \u0026#34;name\u0026#34; const val NAME_RES = \u0026#34;nameRes\u0026#34; } private val TABLE = \u0026#34;Source\u0026#34; override fun createTable(database: SQLiteDatabase) { CREATE_TABLE( TABLE, \u0026#34;${COL.ID} INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL\u0026#34;, \u0026#34;${COL.ENABLED} BOOLEAN\u0026#34;, \u0026#34;${COL.AUTH_REQUIRED} BOOLEAN\u0026#34;, \u0026#34;${COL.ORDER} INTEGER\u0026#34;, \u0026#34;${COL.BACKEND_ID} INTEGER NOT NULL\u0026#34;, \u0026#34;${COL.NAME} TEXT\u0026#34;, \u0026#34;${COL.NAME_RES} INTEGER\u0026#34;) .execute(database) } fun getAllSources(): Observable\u0026lt;List\u0026lt;Source\u0026gt;\u0026gt; { return defer { query( SELECT(COL.ID, COL.ENABLED, COL.ORDER, COL.BACKEND_ID, COL.NAME, COL.NAME_RES) .FROM(TABLE) .ORDER_BY(COL.ORDER) ).run() .mapToList(SourceMapper.MAPPER) // annotation processor generates that  } } fun getSourcesForBackend(backendId: Int): Observable\u0026lt;List\u0026lt;Source\u0026gt;\u0026gt; { return defer { query( SELECT(COL.ID, COL.ENABLED, COL.ORDER, COL.BACKEND_ID, COL.NAME, COL.NAME_RES) .FROM(TABLE) .WHERE(\u0026#34;${COL.BACKEND_ID} = ?\u0026#34;) ).args(backendId.toString()) .run() .mapToList(SourceMapper.MAPPER) } } fun insert(source: Source): Observable\u0026lt;Long\u0026gt; { val builder = SourceMapper.contentValues(). .id(source.id) .enabled(source.enabled) .name(source.name) .nameRes(source.nameRes) .order(source.order) .authenticationRequired(source.authenticationRequired) .backendId(source.backendId) .build() return defer { insert(TABLE, cv) } fun enableSource(sourceId: Long, enabled: Boolean): Observable\u0026lt;Int\u0026gt; { val cv = SourceMapper.contentValues() .enabled(enabled) .build() return defer { update(TABLE, cv, \u0026#34;${COL.ID} = ?\u0026#34;, sourceId.toString()) } } } SQLBrite-DAO provides a simple SQL syntax so auto completion in your IDE works and the annotation processor generates a class SourceMapper to deal with Cursor and ContetnValues and SQLBrite wraps that all into RxJava so we can work with Observable.\nSourceFilterFragment in MVP In the current implementation the right drawer with list of sources is integrated in HomeActivity. We will refactor that and apply MVP here as well. We implement SourceFilterFragment implmenets SourceFilterView and SourceFilterPresenter that subscribes to SourceDao like this:\nclass SourceFilterPresenter(val sourceDao: SourceDao, val presentationModelMapper: (List\u0026lt;Source\u0026gt;) -\u0026gt; List\u0026lt;SourceFilterPresentationModel\u0026gt;) : RxPresenter\u0026lt;SourceFilterView, List\u0026lt;SourceFilterPresentationModel\u0026gt;\u0026gt;() { fun loadSources() { view?.showLoading(false) subscribe( sourceDao.getAllSources().map(presentationModelMapper), // onError  { view?.showError(it, false) }, // onNext  { view?.setData(it) view?.showContent() } ) } fun changeEnabled(source: SourceFilterPresentationModel) { val observable = sourceDao.enableSource(source.sourceId, !source.enabled) subscribe(observable, { // On Error  view?.showError(it, true) }) // OnNext not needed  } } The original intention of MVP was that the Presenter transforms the Model into a PresentationModel which will be displayed in the View. We don\u0026rsquo;t display List in SourceFilerView but rather SourceFilterPresentationModel. This presentation model is optimized for the view. Do we always need a PresentationModel in MVP? It depends. If your Model is just a POJO than it should be fine to display the Model directly in the View, but please don\u0026rsquo;t \u0026ldquo;leak\u0026rdquo; application layer models into the view. Soon or later you will call a method of the application layer model from the View. By having a PresentationModel the view has absolutely no knowledge of the application layer models. However, we use a SourceFilterPresentationModel because we have the problem that our Source is simply not ready to be displayed in a RecyclerView. The Source class can either have a int nameRes (which is R.string.something) in case that it is a predefined Source or a String name if the Source has been added by the user of the app (more about that later). Furthermore, Source class only contains a backendId but we want to display a cell with an icon and title like this:\nTo display such an item we have to \u0026ldquo;map\u0026rdquo; the backendId to an icon and for the title \u0026ldquo;map\u0026rdquo; nameRes to a String or use name as the title. Of course you can do that in RecyclerView\u0026rsquo;s adapter in onBindViewHolder() but then the complexity of the adapter increases. Furthermore, if you do that in adapters onBindViewHolder() method this \u0026ldquo;mapping\u0026rdquo; will be done on androids main ui thread and will be executed during scrolling. That might not be an issue in our use case, but if you have to do some more complex things like sorting elements or compute some properties to be displayed, then you can run into trouble. So we pass a function presentationModelMapper: (List\u0026lt;Source\u0026gt;) -\u0026gt; List\u0026lt;SourceFilterPresentationModel\u0026gt; as constructor parameter of SourceFilterPresenter and then use RxJava\u0026rsquo;s map() operator to map List\u0026lt;Source\u0026gt; to List\u0026lt;SourceFilterPresentationModel\u0026gt;. Another nice thing about RxJava is it\u0026rsquo;s threading model. Actually, we are doing this mapping async on the background thread that is querying the database and then give the view the resulting PresentationModel on the main ui thread. This mapping function looks like this:\nclass BackendManager { object ID { const val DRIBBBLE = 0 const val DESIGNER_NEWS = 1 const val PRODUCT_HUNT = 2 } val getBackendIconRes = fun(backendId: Int) = when (backendId) { ID.DRIBBBLE -\u0026gt; R.drawable.ic_dribbble ID.DESIGNER_NEWS -\u0026gt; R.drawable.ic_designer_news ID.PRODUCT_HUNT -\u0026gt; R.drawable.ic_product_hunt else -\u0026gt; throw IllegalArgumentException(\u0026#34;Unknown Backend for id = ${backendId}\u0026#34;) } } // We pass BackendManager.getBackendIconRes() as backendToIconMap function class SourceToPresentationModelMapper(private val context: Context, private val backendToIconMap: (Int) -\u0026gt; Int) : (List\u0026lt;Source\u0026gt;) -\u0026gt; List\u0026lt;SourceFilterPresentationModel\u0026gt; { override fun invoke(sources: List\u0026lt;Source\u0026gt;): List\u0026lt;SourceFilterPresentationModel\u0026gt; { val presentationModels = ArrayList\u0026lt;SourceFilterPresentationModel\u0026gt;() sources.forEach { source -\u0026gt; val name = if (source.name == null) { context.resources.getString(source.nameRes) } else { source.name!! } presentationModels.add(SourceFilterPresentationModel(source.id, backendToIconMap(source.backendId), name, source.enabled)) } return presentationModels } } This is yet another way to define a function (as an class) in kotlin. I just wanted to play around a little bit with kotlin.\nLet\u0026rsquo;s get reactive Many developers are excited about Rx programming, because Rx programming offers functional alike operators like flatMap() etc. Many of them don\u0026rsquo;t understand that by using RxJava they are observing data. Therefore, they don\u0026rsquo;t understand Rx programming at all. It is not only about transforming data. Rx implements the observer pattern. You are subscribing to an observable to get updates. That may be a one time consumable data stream like a http response, but the real power of the observer pattern and RxJava can be seen and used by making a data source observable that can emit items more than once.\nObservable Database We haven\u0026rsquo;t talked much about SQLBrite yet, but the biggest advantage of SQLBrite is that whenever we change a database table\u0026rsquo;s dataset (insert, update or delete row) we get notified through SQLBrite and RxJava. SourceFilterPresenter.loadSources() subscribes to sourceDao.getAllSources() which returns an Observable\u0026lt;List\u0026lt;Source\u0026gt;\u0026gt;. But that is not just a \u0026ldquo;single onetime\u0026rdquo; observable to run the query and complete once the query result has been emitted. No, this Observable will remain subscribed (until unsubscribed) and SQLBrite will recognize table changes and simply rerun the sql query and calls onNext() with the new query result set.\nWe also haven\u0026rsquo;t discussed yet how SourceFilterPresenter actually works when subscribing to the SourceDao:\n When SourceFilterFragment starts the SourceFilterPresenter get\u0026rsquo;s instantiated and SourceFilterPresenter.loadSources() gets called. This calls SourceDao.getAllSources() which basically runs SELECT * FROM Source and returns an Observable. The Presenter subscribes himself on this observable and onNext() gets called with the sql query result. The presenter then tells the view to displays the Sources (PresentationModel) i.e. in a RecyclerView. When the user clicks on a \u0026ldquo;source item\u0026rdquo; in the RecyclerView to enable or disable this source then the view calls presenter.changeEnabled(). This will basically do an update on the database like UPDATE Source SET enabled = ? WHERE id = ? SQLBrite will recognize that the dataset of table \u0026ldquo;Source\u0026rdquo; has been updated (step 2). Therefore, SQLBrite checks if there are Observable with Subscribers on the same Table and detect that the Observable from step 1 (SELECT * FROM Source) is still \u0026ldquo;alive\u0026rdquo;. Hence, SQLBrite will rerun this sql query and emit the new query result (with the updated source). The presenter receives the new result in subscribers onNext() and then updates the view.  An important thing to note is that by clicking in the RecyclerView on an item to enable / disable a Source, the Source object itself in the adapter will not be updated. As discussed above, the query will rerun and emit an entirely new List\u0026lt;Source\u0026gt; which then will be mapped to an entirely new List\u0026lt;SourceFilterPresentationModel\u0026gt; which then will be displayed in the RecyclerView (replaces the previous List). This is by design! By doing so this is the first step to ensure to have immutable objects.\nImmutability prevents that someone else is touching your object. You can think of it as watching a baseball game in a stadium. You are sitting somewhere in the middle of the tribune. As the game goes on you get hungry. Luckily there is a vendor nearby selling hot dogs, but he stands some seats away from you. Nevertheless, you order a hot dog. The vendor will give your hot dog to the first person in the row you are sitting and he will pass it to his neighbor, that person will pass your hot dog to his next neighbor and so on until you finally get your hot dog. I\u0026rsquo;m pretty sure you don\u0026rsquo;t want that someone else has eaten a piece of your hot dog during the way from vendor to you. You want an immutable hot dog! Same is valid for our data objects. We don\u0026rsquo;t want that other components (especially other threads) can change our data objects. You might have already noticed that this means that our Source class shouldn\u0026rsquo;t have setters, but actually has. This is my fault in combination with SQLBrite-DAO which not fully supports kotlin yet and requires a public setter method for his annotation processor. If you work on a real app I recommend to use Google\u0026rsquo;s auto-value to create immutable objects.\nAdding a Source If you open the search you can \u0026ldquo;save\u0026rdquo; this search (click on the fab). That means we create a \u0026ldquo;Source\u0026rdquo; with the search string as name (hence a Source can have either nameRes=R.string.foo or name =\u0026quot;Hello\u0026rdquo;):\n  What actually happens under the hood with SQLBrite + RxJava is pretty the same as described before ( enabling / disabling a Source):\nReactive Routing As already said: this is the second part of a blog series about refactoring plaid app. In the first part we have applied Model-View-Presenter and have introduced an ItemsLoader for loading items from different backend endpoints by invoking RouteCallers. Please read the first part if you haven\u0026rsquo;t yet for more details. Summarizing, the home screen is build like this:\nPlease note that we have established an observable unidirectional bottom-up dataflow by using RxJava. We already have discussed that we store Sources in a database and that the user can enable and disable sources dynamically. Whenever the user enables / disables a Source in SourceFilterView we have to reload the items in the HomeView, right? We have seen that the HomePresenter is responsible to load data items by using an ItemsLoader. So how do we notify the HomePresenter that a Source has been enabled / disabled? Using an EventBus in such a scenario is a common solution.\nBut there is a better way, a truly reactive way: We don\u0026rsquo;t have to tell the HomePresenter about changes at all. How? Well, the HomePresenter is already observing ItemsLoader. So the HomePresenter doesn\u0026rsquo;t really care about \u0026ldquo;source changes\u0026rdquo;. All the HomePresenter is interested in is receiving items from his onNext() subscriber-callback and display them via HomeView. So when a Source is changed new items to display will be emitted. Easy (in theory), right? But what does it actually takes to build something like that? Good news: We already have almost everything we need. The RouteCallerFatory.getAllBackendCallers() already returns an Observable\u0026lt;List\u0026lt;RouteCaller\u0026gt;\u0026gt; (please note that this is an Observable). The Router passes this Observable to the ItemsLoader and the HomePresenter subscribes on it. So as already said, to bring new items to the HomePresenter\u0026rsquo;s onNext() callback we have to emit new items. Which kind of items? New List\u0026lt;RouteCaller\u0026amp;rt; because each RouteCaller will be executed by ItemsLoader (Page) to load Items from backend endpoints and finally emit the loaded items to HomePresenter. In other words: To make the Routing \u0026ldquo;reactive\u0026rdquo; we have to make our RouteCallerFatory \u0026ldquo;reactive\u0026rdquo; by observing the database (SQLBrite) and emitting the updated RouteCaller when a Source has been enabled or disabled:\nclass HomeDribbbleCallerFactory(private val backend: DribbbleService, sourceDao: SourceDao) : RouteCallerFactory\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt; { private val backendCalls = ArrayMap\u0026lt;Long, RouteCaller\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt;\u0026gt;() private val sources: Observable\u0026lt;List\u0026lt;Source\u0026gt;\u0026gt; init { // Observable for the Database  sources = defer { sourceDao.getSourcesForBackend(BackendManager.ID.DRIBBBLE).share() } } private fun createCaller(source: Source): RouteCaller\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt; { return RouteCaller(0, ITEMS_PER_PAGE, getBackendMethodToInvoke(source)) } // Find the method to invoke (retrofit backend endpoint call) for a given Source  private fun getBackendMethodToInvoke(source: Source): (pageOffset: Int, itemsPerPage: Int) -\u0026gt; Observable\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt; = when (source.id) { // Predefined Sources  Source.ID.DRIBBBLE_POPULAR -\u0026gt; getPopular Source.ID.DRIBBBLE_FOLLOWING -\u0026gt; getFollowing Source.ID.DRIBBLE_ANIMATED -\u0026gt; getAnimated Source.ID.DRIBBLE_DEBUTS -\u0026gt; getDebuts Source.ID.DRIBBLE_RECENT -\u0026gt; getRecent Source.ID.DRIBBLE_MY_LIKES -\u0026gt; getMyLikes Source.ID.DRIBBLE_MY_SHOTS -\u0026gt; getUserShots // Custom Source created by user by searching.  else -\u0026gt; SearchFunc(source.name!!) } override fun getAllBackendCallers(): Observable\u0026lt;List\u0026lt;RouteCaller\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt;\u0026gt;\u0026gt; { return sources.map(mapSourcesToBackendCalls) } // Map Sources from Database to corresponding RouteCaller  val mapSourcesToBackendCalls = fun(sources: List\u0026lt;Source\u0026gt;): List\u0026lt;RouteCaller\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt;\u0026gt; { val calls = ArrayList\u0026lt;RouteCaller\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt;\u0026gt;() sources.forEach { source -\u0026gt; val call = backendCalls[source.id] if (call == null) { // New source added  if (source.enabled) { val newCall = createCaller(source) backendCalls.put(source.id, newCall) calls.add(newCall) } } else { // Already existing source  if (!source.enabled) { // Source has been disabled  backendCalls.remove(source.id) } else { calls.add(call) } } } return calls } //  // Backend endpoint calls  //  val getPopular = fun(pageOffset: Int, itemsPerPage: Int): Observable\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt; { return backend.getPopular(pageOffset, itemsPerPage) } val getFollowing = fun(pageOffset: Int, itemsPerPage: Int): Observable\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt; { return backend.getFollowing(pageOffset, itemsPerPage) } val getAnimated = fun(pageOffset: Int, itemsPerPage: Int): Observable\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt; { return backend.getAnimated(pageOffset, itemsPerPage) } val getDebuts = fun(pageOffset: Int, itemsPerPage: Int): Observable\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt; { return backend.getDebuts(pageOffset, itemsPerPage) } val getRecent = fun(pageOffset: Int, itemsPerPage: Int): Observable\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt; { return backend.getRecent(pageOffset, itemsPerPage) } val getMyLikes = fun(pageOffset: Int, itemsPerPage: Int): Observable\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt; { return backend.getUserLikes(pageOffset, itemsPerPage) } val getUserShots = fun(pageOffset: Int, itemsPerPage: Int): Observable\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt; { return backend.getUserShots(pageOffset, itemsPerPage) } private class SearchFunc(val queryString: String) : (Int, Int) -\u0026gt; Observable\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt; { override fun invoke(pageOffset: Int, pageLimit: Int): Observable\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt; { return Observable.defer\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt; { try { // Dribbble API doesn\u0026#39;t provide a search endpoint.  // Therefore, parse HTML search result manually  Observable.just(DribbbleSearch.search(queryString, DribbbleSearch.SORT_RECENT, pageOffset)) } catch(e: Exception) { Observable.error(e) } } } } } As you see, our HomeDribbbleCallerFactory is observing our database (sourceDao.getSourcesForBackend()) and whenever the database has been changed because the user has enabled/disabled a Source or have added a new one (custom search) sources.map(mapSourcesToBackendCalls) will be called again and emits a new List\u0026lt;RouteCaller\u0026gt; with the updated routes to call. Next the ItemsLoader (via Router and FirstPage) will reacting on the new emitted List\u0026lt;RouteCaller\u0026gt; and load new Items which finally triggers HomePresenter\u0026rsquo;s onNext() callback with the new loaded items. It sounds more complicated than it actually is. Have a look at the following graphically representation:\n  The yellow circle represents the data flow. You see that SQLBrite will rerun all queries and inform the subscribers. Since HomeDribbbleCallerFactory is an subscriber to the database this component gets notified when a Source has been enabled/dispable and automatically adjust the Router. Thanks to RxJava and SQLBrite we can build a truly reactive application where the app reacts on changes and at the end updates the UI \u0026ldquo;magically\u0026rdquo; by still having an unidirectional data flow (unlikely using an EventBus).\nPosting items to DesignerNews If you haven\u0026rsquo;t noticed yet: You can submit news to DesignerNews site directly from Plaid app (Floating-Action-Button on home screen). Nick Butcher uses an IntentService to execute the http call and a LocalBroadcastReceiver (kind of EventBus) to notify the HomeActivity whether the story has been submitted successfully or not:\nUsing an android Service is definitely the way to go to ensure that the story will be posted independent from activities lifecycle. However, there is a small issue with the current implementation: If the user submits a post PostStoryService gets started, but this Service will only inform HomeActivity after having uploaded successfully and then HomeActivity displays the uploaded item in the RecyclerView with the other uploaded. The problem is that if you have a slow internet connection (i.e. executing the http call to submit the post to DesignerNews takes 10 seconds) the user has no clue or visual feedback whats going on. A good idea would be to display the item immediately in HomeActivity\u0026rsquo;s RecyclerView with a ProgressBar in the items layout (ViewHolder) and simply hide that ProgressBar once the post has been submitted successfully (http call successful). In case of error it would be nice if the failed item in HomeActivity\u0026rsquo;s RecyclerView will be highlighted with an error icon and a retry button. Even better would be to add offline support (no network connection). Sounds very complex, doesn\u0026rsquo;t it? How do you implement that? Using an EventBus?\nDon\u0026rsquo;t worry, we can implement that in a \u0026ldquo;truly reactive\u0026rdquo; way without additional work to integrate it into our already refactored code. Let\u0026rsquo;s do it step by step. First we have to implement offline support, so we have to save the story we will post on Designer News somehow locally on our device: We use a SQLite database for that and SQLBrite + SQLBrite-DAO again. Let\u0026rsquo;s define a simple data class NewDesignerNewsStory that represents a story that we will post on Designer News afterwards:\n@ObjectMappable class NewDesignerNewsStory : PlaidItem { object State { // ID\u0026#39;s for predefined Sources  const val NOT_SUBMITTED = 0 const val IN_PROGRESS = 1 const val FAILED = 2 } @Column(StoryDao.COL.ID) var id : Long @Column(StoryDao.COL.TITLE) var title: String @Column(StoryDao.COL.COMMENT) var comment: String @Column(StoryDao.COL.URL) var url: String @Column(StoryDao.COL.STATE) var state = State.NOT_SUBMITTED } Furthermore, we implement StoryDao which is responsible to insert a NewDesignerNewsStory, update the state of a NewDesignerNewsStory. I\u0026rsquo;m not going to show the code for that because I guess you know how this SQL statements will look like. Next we will refactor PostStoryService to use StoryDao to query the local database for not submitted Posts and post them:\nclass PostStoryService : IntentService (\u0026#34;PostStoryService\u0026#34;) { @Inject lateinit var storyDao : StoryDao @Inject lateinit var backend : DesignerNewsService fun onHandleIntent(i : Intent) { val toSubmit = storyDao.getAllNotInProgress() // List\u0026lt;StoryDao\u0026gt; of NOT_SUBMITTED and FAILED  toSubmit.forEach(submit) } private val submit = fun(story : NewDesignerNewsStory){ try { storyDao.setUploadInProgress(story.id) // Mark Story as in progress  backend.postNewStory(story) // Blocking retrofit call  storyDao.remove(story.id) // successfully so remove this from database  } catch (e : IOException){ storyDao.setFailed(story.id) } } } Nick Butcher has already implemented a PostNewDesignerNewsStoryActivity to have a UI to submit a story. We will refactor this as well and apply MVP as already done with other components before. So at the end there will be a PostNewDesignerNewsStoryActivity (View), a PostNewDesignerNewsStoryPresenter that will be save a NewDesignerNewsStory into the local database by using StoryDao. The idea is to store every new story the user of the plaid app wants to submit into database rather then executing the http call directly and then afterwards start PostStoryService to execute the http call. As you see in the code snipped above we will update the state (IN_PROGRESS / FAILED) while trying to submit the story and save that persistently into database. In a nutshell:\nAll right, but you might ask yourself now: How the hack do we display that items from database in our HomeActivity? Well, it\u0026rsquo;s easier than you might have thought. We already have implemented a very flexible routing mechanism which we are already using in HomeActivity. So we will simply add another route to our Router: But rather then making http calls to a backend we add a route to our local (offline) database. All it takes is to define a RouteCallerFactory:\nclass OfflineStoryCallerFactory (private val storyDao : StoryDao) : RouteCallerFactory\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt;{ private val callers = arrayListOf(RouteCaller(0, 100, callFunc)) private val callFunc = fun (pageOffset : Int, limit : Int) : Observable\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt; { return storyDao.getAll() } override fun getAllBackendCallers(): Observable\u0026lt;List\u0026lt;RouteCaller\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt;\u0026gt;\u0026gt; { return callers } } Easy right? Let\u0026rsquo;s add the OfflineStoryCallerFactory to the Router used for the home screen. In part 1 we have already discussed that we can do that configuration in the corresponding dagger module:\n@Module( injects = { HomePresenter.class }, addsTo = ApplicationModule.class // contains Retrofit interfaces ) public class HomeModule { @Provides @Singleton HomePresenter provideSearchPresenter(SourceDao sourceDao, StoryDao storyDao, DribbbleService dribbbleBackend, DesignerNewsService designerNewsBackend, ProductHuntService productHuntBackend ) { // Create the router  List\u0026lt;RouteCallerFactory\u0026lt;List\u0026lt;? extends PlaidItem\u0026gt;\u0026gt;\u0026gt; routeCallerFactories = new ArrayList\u0026lt;\u0026gt;(3); routeCallerFactories.add(new HomeDribbbleCallerFactory(dribbbleBackend, sourceDao)); routeCallerFactories.add(new HomeDesingerNewsCallerFactory(designerNewsBackend, sourceDao)); routeCallerFactories.add(new HomeProductHuntCallerFactory(productHuntBackend, sourceDao)); // Add the new route to local database  routeCallerFactories.add(new OfflineStoryCallerFactory(storyDao)); Router\u0026lt;List\u0026lt;? extends PlaidItem\u0026gt;\u0026gt; router = new Router\u0026lt;\u0026gt;(routeCallerFactories); ItemsLoader\u0026lt;List\u0026lt;? extends PlaidItem\u0026gt;\u0026gt; itemsLoader = new ItemsLoader\u0026lt;\u0026gt;(router); return new HomePresenterImpl(itemsLoader); } } So at the end we have a HomePresenter that gets items from an ItemsLoader which Router enables him to load and displays items from Dribbble (HomeDribbbleCallerFactory), Designer News (HomeDesingerNewsCallerFactory), Product Hunt (HomeProductHuntCallerFactory) and from the users local (offline) database via OfflineStoryCallerFactory. Since PostStoryService, PostNewDesignerNewsStoryPresenter and OfflineStoryCallerFactory use StoryDao which is build on top of SQLBrite + RxJava the whole thing is reactive. That means, whenever we add a new Story to our local database by using StoryDao, the HomePresenter will automatically be notified as well. It\u0026rsquo;s the same principle as described before when enabling / disabling sources.\nNote also that PostStoryService is changing the the state of a NewDesignerNewsStory which will result in updating the UI of HomeView (show / hide a ProgressBar on the item that will be uploaded). We also get error handling for free: i.e. when an NewDesignerNewsStory couldn\u0026rsquo;t be submitted to Designer News backend we can show a retry button on this item displayed in HomeActivity\u0026rsquo;s RecyclerView. By clicking on the retry button we can simply start PostStoryService again which will try to upload that item again. Please note also that we still have an unidirectional data flow. We can improve that even more by starting PostStoryService with an exponential back off in case of bad network connection or use JobSchedulers or GcmNetworkManager to start PostStoryService only when it makes sense (save battery).\nConclusion of Part 2 In this part we have shown that RxJava (or Rx programming in general) is more than just concatenating Retrofit http calls and transforming data. The observer pattern is nothing new, but that is what makes RxJava so beautiful. Establishing an unidirectional data flow is the key for having clean and easy to debug and maintain architecture. That might be the biggest difference between using RxJava base Observable (once again: OBSERVER PATTERN) and an EventBus, which could do the job as well but you might not have an unidirectional data flow. We could also apply the reactive pattern to authentication which I haven\u0026rsquo;t covered at all.\nPlease note that the source code is far away from being perfect and I\u0026rsquo;m pretty sure you will find bugs. So please don\u0026rsquo;t copy \u0026amp; paste blindly this code into your app. I simply hadn\u0026rsquo;t time to cover all cases and refactor all things. I had to publish that blog post to stop myself to spend more days and weeks on the refactoring of this app. You can see the ideas and code posted in this blog as some kind of \u0026ldquo;prove of concept\u0026rdquo; of a \u0026ldquo;truly reactive\u0026rdquo; app. Once again I want to point out the importance of immutable objects and pure functions. Unluckily my source code is not as immutable as it should be. As already said, the focus was set on writing a \u0026ldquo;reactive\u0026rdquo; app.\nNevertheless, I\u0026rsquo;m willing to clean up my code and to make a pull request to Nick Butcher\u0026rsquo;s original repository. However, I don\u0026rsquo;t expect that this \u0026ldquo;Reactive MVP approach\u0026rdquo; will be merged into the Plaid apps source code. I do understand that my approach is for advanced developers. Furthermore, I use some third party libraries and kotlin, which may not everybody has knowledge of. Therefore my code is not ideal for all kind of developers, which without any doubt Nick Butcher as a Google employee wants to reach with his awesome app. It\u0026rsquo;s good and important to have such an open source app with an inspiring UI / UX understandable for both android beginners and experts.\nI also wanna catch the opportunity to talk about an idea I have in mind for almost two years: It would be very nice to have an app (Plaid alike) with different sources of android development bundled into one app. For example the app could display some tweets and Google+ posts from android dev super stars like Jesse Wilson, Jake Wharton, Matthias Käppler, Piwai, Dan Lew, Corey Latislaw, Cyril Mottier, Lisa Wray, Artem Zinnatullin and others (forgive me if I have forget to mention your name here) but also some other sources like Reddit /r/androiddev, Stackoverflow, YouTube channels, podcasts etc. bundled into one nice app with an outstanding UI / UX as Plaid. I don\u0026rsquo;t think that this is something a single developer can develop in his spare time (and the experience from refactoring the plaid app gives me right). But if we could find a handful developers interessted in such an app developed by the community for the community I\u0026rsquo;m definetly willing to contribute as well.\nThis is a post in the Refactoring Plaid App series. Other posts in this series:\n  Refactoring Plaid App - A reactive MVP Approach (Part 1)   Refactoring Plaid App - A reactive MVP Approach (Part 2)    ","permalink":"https://hannesdorfmann.com/android/plaid-refactored-2/","tags":["android","software-architecture"],"title":"Refactoring Plaid App - A reactive MVP Approach (Part 2)"},{"categories":["Android"],"contents":"Nick Butcher has open sourced on github an awesome app called Plaid. The app is pretty cool and has an outstanding UI / UX. Whenever source code of such awesome apps are available developers start to copy code and best practice tips from it. So I did the same and decided to dive into the code of Plaid. As always, you will find some parts of the code that you think could be implemented or be written in another way. So instead of just talking about code I have decided to spend some of my spare time to refactor some parts of Plaid\u0026rsquo;s source code. This blog post is the first part of a series of 3 posts of how I would refactor the Plaid app and to share my thoughts.\nPreface: I started the refactoring with the strong belief that I can refactor the whole app. Surprisingly (ironic), it turns out that I was a very naive man. I simply have underestimated the complexity of the app and the number of features. I discovered some features only after having spent some hours with Nick Buchter\u0026rsquo;s code, which were not \u0026ldquo;visible\u0026rdquo; to me just by using the app. In short: I realized that I don\u0026rsquo;t have the time to put all my thoughts into action. Hence my \u0026ldquo;refactoring\u0026rdquo; is focused on the apps \u0026ldquo;homepage\u0026rdquo; and the \u0026ldquo;search screen\u0026rdquo;, which I have refactored mostly. Nevertheless, I want discuss (in theory) some more things that could be refactored, but I didn\u0026rsquo;t because of time constraints. My refactored code can be found on github as well.\nFirst look The overall user experience and user interface is pretty awesome. I can\u0026rsquo;t describe it better than this tweet:\nIf you think Material Design is all about cards and shadows, take a look at Plaid and think again https://t.co/IYO3QnxkFu\n\u0026mdash; Luis G. Valle (@lgvalle) November 3, 2015  It\u0026rsquo;s a joy to use the app. The UI / UX is truly an inspiration for every developer and designer. However, after playing around a little bit more with the app I faced some visual bugs:\n  Displaying a loading indicator and error message at the same time:     In the app you can apply some \u0026ldquo;filters\u0026rdquo; or in other words: You can specify which \u0026ldquo;sources\u0026rdquo; of Dribbble, Designer News and Product Hunt you want to display. If you deselect such sources while loading an http request is currently running you can run into the state where the app displays items, but shouldn\u0026rsquo;t since no sources are selected:     Also the app doesn\u0026rsquo;t handle screen orientation changes properly. It simply rebuilds the entire screen so that after each orientation change you see the loading indicator again, and re-execute the http calls:     Typically such \u0026ldquo;issues\u0026rdquo; are a first indicator for spaghetti code and a moderate software architecture. So let\u0026rsquo;s take a look under the hood and check out the source code and the components for displaying a list of items: The HomeActivity (about 750 lines of code) handles the visibility of UI elements like displaying the RecylcerView or the ProgressBar. This activity also decides when to display the Source-Filters-Drawer (on the right side). Furthermore, in it\u0026rsquo;s onActivityResults() it does a lot of things inclusive posting new post to designers news. Last but not least it also loads the data for the selected filters by using a DataManager. You see, the HomeActivity has many responsibilities, probably too many. The DataManager basically uses a combination of Retrofit and AsyncTasks to execute http calls to load the data. The tricky thing here is pagination. Whenever the end of the RecyclerView has been reached, more (older) items are loaded. DataManager uses internally a HashMap to track the current page each source (backend endpoint like \u0026ldquo;Dribbble Popular\u0026rdquo; or \u0026ldquo;Dribbble Recent\u0026rdquo; or \u0026ldquo;Designer News Popular\u0026rdquo;) is currently displaying. The items are displayed in a RecyclerView by using FeedAdapter. The SearchActivity is working quite similar as HomeActivity: It uses a DataManager and a FeedAdapter as well.\nThe architecture From my point of view there is no clear architecture in the current implementation. HomeActivity is some kind of god object that manages many things. Another \u0026ldquo;issue\u0026rdquo; is that HomeActivity changes the UI state by calling the same (internal) methods from different other methods and different events, i.e. the method checkEmptyState() get\u0026rsquo;s called from 4 different point\u0026rsquo;s in HomeActivity source code.\nWe will refactor that by applying a Model-View-Presenter with a passive view. The passive view will only be display that things that the presenter tells to do. I\u0026rsquo;m a fan of MVP with a passive view. People ask me from time to time why I recommend to use passive view and not supervising controller or other MVP derivations. Well, if you use MVP without passive view, you basically are splitting the spaghetti code formerly sitting in the view to half presenter and half view.\nHomeActivity in MVP So with MVP + passive view we split the responsibilities into two classes: HomeActivity implements HomeView is now considered as View (passive view) and implements this interface:\ninterface HomeView : MvpView { fun showLoading() fun showContent() fun showError() fun showLoadingMore(showing: Boolean) fun showLoadingMoreError(t: Throwable) fun addOlderItems(items: List\u0026lt;PlaidItem\u0026gt;) } From now on the job of HomeActivity is to manage the UI elements (visibility, coordinate animations, etc.) but only after the presenter told to do so. So the state of the View is managed by the HomePresenter. The HomePresenter looks like this:\nclass HomePresenter(private val itemsLoader: ItemsLoader\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt;) : RxPresenter\u0026lt;HomeView, List\u0026lt;PlaidItem\u0026gt;\u0026gt;() { fun loadItems() { view?.showLoading() subscribe( itemsLoader.firstPage(), { // onError  view?.showError() }, { // onNext  view?.addOlderItems(it) view?.showContent() } ) } fun loadMore() { view?.showLoadingMore(true) subscribe( itemsLoader.olderPages(), { // onError  view?.showLoadingMoreError(it) }, { // onNext  view.addOlderItems(it) view.showLoadingMore(false) } ) } } If you haven\u0026rsquo;t noticed yet: We use kotlin as programming language, mainly because I like the language and to have the chance to see how development with kotlin works in a \u0026ldquo;real world\u0026rdquo; application. Thanks to the kotlin\u0026rsquo;s interoperability I can easily reuse Nick Butcher\u0026rsquo;s java source code, mainly for UI / View things.\nFor implementing MVP we use Mosby, a MVP library, which also allows us to keep the presenters during screen orientation changes. So we don\u0026rsquo;t have to restart with loading data and we don\u0026rsquo;t see the ProgressBar after screen orientation changes. Mosby allows us to keep the views state as before the orientation change.\nLast but not least I have decided to use RxJava for my \u0026ldquo;Model\u0026rdquo; (hence the subscribe() method in the presenter). So the ItemsLoader is my refactored and reactive version Nick Butcher\u0026rsquo;s DataManager. I will explain the ItemsLoader in a minute.\nSearchActivity in MVP As already said, running a search is very similar to HomeActivity. It displays a list (grid) of items and adds pagination to load more items when the end of the RecyclerView has been reached. So applying MVP to SearchActivity is pretty the same as shown before:\npublic interface SearchView extends MvpView { void showLoading(); void showContent(); void showError(Throwable t); void showLoadingMore(boolean showing); void showLoadingMoreError(Throwable t); void addOlderItems(List\u0026lt;PlaidItem\u0026gt; items); void showSearchNotStarted(); } class SearchPresenter(private val itemsLoaderFactory: SearchItemsLoaderFactory) : RxPresenter\u0026lt;SearchView, List\u0026lt;PlaidItem\u0026gt;\u0026gt;() { private var itemsLoader: ItemsLoader\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt;? = null fun search(query: String) { // Create items loader for the given query string  itemsLoader = itemsLoaderFactory.create(query) view?.showLoading() subscribe(itemsLoader!!.firstPage(), { // Error handling  view?.showError(it) }, { // onNext  view?.addOlderItems(it) }, { view?.showContent() }) } fun searchMore(query: String) { view?.showLoadingMore(true) subscribe(itemsLoader!!.olderPages(), { // Error handling  view?.showLoadingMore(false) view?.showLoadingMoreError(it) }, { // onNext  view?.addOlderItems(it) }, { // onComplete  view?.showLoadingMore(false) }) } fun clearSearch() { // Unsubscribe any previous search subscriptions  unsubscribe() view.showSearchNotStarted() } } The only different compared to HomePresenter is that SearchPresenter takes a SearchItemsLoaderFactory as constructor parameter and creates a ItemsLoader dynamically for each search query. We will see how this works in a minute.\nItemsLoader and Pagination So far we have covered View and Presenter. Now lets discuss how we could refactor the \u0026ldquo;Model\u0026rdquo; or use case / interactor if you want to compare it with uncle Bob\u0026rsquo;s clean architecture.\nBefore we start: There is a class called PlaidItem (holds properties like title and image url). This class is the base class to represent a single item:\n Shot extends PlaidItem for an item loaded from Dribbble Story extends PlaidItem for an item loaded from Designer News Post extends PlaidItem for an item loaded from Product Hunt  So now let\u0026rsquo;s discuss how we rewrite DataManager more efficiently by using RxJava. I don\u0026rsquo;t use RxJava because I think it\u0026rsquo;s cool and all the cool kids have to use RxJava nowadays. You will (hopefully) see the benefits of using RxJava afterwards (especially in the second part of this blog post series).\nThe hard part of loading items is that we support pagination and loading items from different backends. So let\u0026rsquo;s build the ItemsLoader from \u0026ldquo;bottom-up\u0026rdquo;. At the \u0026ldquo;bottom\u0026rdquo; we will find a Retrofit interface for executing the http call. Right now in Plaid you can search DesignerNews and Dribbble. The pagination problem: Dribbble loads 100 items and requires such a call loadItems(0, 100) and the next page will be loadItems(100, 200) while DesignerNews increments his page by 1 loadItems(0, 1) and next page will be loadItems(1, 2). We need a common API for both. Since we use kotlin we can pass \u0026ldquo;method references\u0026rdquo; (function poitners) or lambdas. So what we need is a component that takes such a function, executes this function and returns an Observable where we get the result of the actual http call. So basically we need something like this: backendMethodToCall: (Int, Int) -\u0026gt; Observable\u0026lt;T\u0026gt;, where the first int parameter is the page offset, the second int parameter the limit (how many items should be loaded per page) and T is the generic type of the result (in fact we are always loading List\u0026lt;PlaidItem\u0026gt;).\nWe call that component RouteCaller:\nclass RouteCaller\u0026lt;T\u0026gt;(private val startPage: Int = 0, private val itemsPerPage: Int, private val backendMethodToCall: (Int, Int) -\u0026gt; Observable\u0026lt;T\u0026gt;) { /** * Offset for loading more */ private val olderPageOffset = AtomicInteger(startPage) /** * A queue that is used to retry \u0026#34;older\u0026#34; * pages if they have failed before continue with even more older */ private val olderFailedButRetryLater: Queue\u0026lt;Int\u0026gt; = LinkedBlockingQueue\u0026lt;Int\u0026gt;() /** * Get an observable to load older data from backend. */ fun getOlderWithRetry(): Observable\u0026lt;T\u0026gt; { val pageOffset = if ( olderFailedButRetryLater.isEmpty()) { olderPageOffset.addAndGet(itemsPerPage) } else { olderFailedButRetryLater.poll() } return backendMethodToCall(pageOffset, itemsPerPage) .doOnError { olderFailedButRetryLater.add(pageOffset) } } /** * Get an observable to load the newest data from backend. * This method should be invoked on pull to refresh */ fun getFirst(): Observable\u0026lt;T\u0026gt; { return backendMethodToCall(startPage, itemsPerPage) } } RouteCaller takes such a method (Int, Int) -\u0026gt; Observable\u0026lt;T\u0026gt; as constructor parameter and will call this method internally with the correct parameters:\n getFirst() loads the first page getOlderWithRetry(): This method is responsible to load older items. We keep track of the current page in the field olderPageOffset and we will increment this one when we start loading more items (or in other words: load an older page). Additionally, we use .doOnError() to retry to load the failed page when loading the next page.  So the responsibility of RouteCaller is to fill out the parameters (page offset and page limit) needed for the real http backend endpoint call. So what we have is something like this:\nFor executing a search we have two backends to query DesignerNewsService and DribbleService. That means that we have two RouteCallers (one for each backend search method to invoke):\nThe next question is: How do we instantiate a RouteCaller? We define a RouteCallerFactory for each backend, which basically offers a method getAllBackendCallers() where we get an Observable List\u0026lt;RouteCaller\u0026gt; we should execute to load items.\ninterface RouteCallerFactory\u0026lt;T\u0026gt; { /** * Get all available backend route callers */ fun getAllBackendCallers(): Observable\u0026lt;List\u0026lt;RouteCaller\u0026lt;T\u0026gt;\u0026gt;\u0026gt; } For executing a search we have DesignerNewsSearchCallerFactory and DribbbleSearchCallerFactory: The DesignerNewsSearchCallerFactory looks like this:\nclass DesignerNewsSearchCallerFactory(private val searchQuery: String, private val backend: DesignerNewsService) : RouteCallerFactory\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt; { val extractPlaidItemsFromStory = fun(story: StoriesResponse): List\u0026lt;PlaidItem\u0026gt; { return story.stories } // The method to execute from RouteCaller  val searchCall = fun(pageOffset: Int, itemsPerPage: Int): Observable\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt; { return backend.search(searchQuery, pageOffset).map(extractPlaidItemsFromStory) } // Create a list with one single RouteCaller() with \u0026#34;searchCall\u0026#34; as method reference  private val callers = arrayListOf(RouteCaller(0, 100, searchCall)) override fun getAllBackendCallers(): Observable\u0026lt;List\u0026lt;RouteCaller\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt;\u0026gt;\u0026gt; { return Observable.just(callers) } } At first glance DesignerNewsSearchCallerFactory looks a little bit strange if you are new to kotlin because we don\u0026rsquo;t use lambdas but instead we create a property searchCall which actually is a function (Int, Int) -\u0026gt; Observable\u0026lt;List\u0026lt;PlaidItem\u0026gt;\u0026gt;.\nThe reason why we do this is testability: Recently I have watched the fireside chat of Android Dev Summit 2015 where the guys from the Android Team has been asked when they will add Java 8 support. Then Reto Meier, from the Android Team, answered that many developers are mainly interessted in lambdas and asked the audience if they could raise the hand if they want lambdas for android development: Almost the whole audience has raised the hand. I think that there is a general misunderstanding with lambdas: the real power of programming language that offer lambdas are not lambdas itself, is higher order functions and the ability to passing method references. Lambdas are just kind of anonymous functions. Actually, lambdas are not testable, because they are hardcoded. For example if I would have implemented something like this:\nRouteCaller(0, 100, { pageOffset, limit -\u0026gt; backend.search(searchQuery, pageOffset) }) How do we write a unit test for that lambda? It\u0026rsquo;s not possible to write a unit test for that lambda since the lambda is \u0026ldquo;hardcoded\u0026rdquo;, whereas if we pass a function reference we can easily unit test a function. In java 8 we can pass a method reference by writing this::searchCall. Unfortunately, this syntax is not supported yet in kotlin (right now :: only supports static methods). Therefore this \u0026ldquo;workaround\u0026rdquo; by defining a function as property. More about my experience with kotlin in the last part of this series of blog post.\nAll right, so for executing a Search we have something like this:\nPlease note that for the search getAllBackendCallers() returns a list containing just one RouteCaller, but the idea is that a RouteCallerFactory creates all RouteCallers to all available endpoints of a certain backend. As we will see later, the HomeDribbbleCallerFactory returns a list of RouteCallers for each Dribbble endpoint to load items like popular items, recent, animated etc. So we have something like that:\nNext we introduce a Router which is responsible to combine all RouteCaller from different RouteCallerFactories to one single Observable list:\nclass Router\u0026lt;T\u0026gt;(private val routeFactories: List\u0026lt;RouteCallerFactory\u0026lt;T\u0026gt;\u0026gt;) { fun getAllRoutes(): Observable\u0026lt;List\u0026lt;RouteCaller\u0026lt;T\u0026gt;\u0026gt;\u0026gt; { val callers = ArrayList\u0026lt;Observable\u0026lt;List\u0026lt;RouteCaller\u0026lt;T\u0026gt;\u0026gt;\u0026gt;\u0026gt;() routeFactories.forEach { callers.add(it.getAllBackendCallers()) } return Observable.combineLatest(callers, { calls -\u0026gt; val items = ArrayList\u0026lt;RouteCaller\u0026lt;T\u0026gt;\u0026gt;(calls.size) calls.forEach { items.addAll(it as List\u0026lt;RouteCaller\u0026lt;T\u0026gt;\u0026gt;) } items // return items  }) } } As you see the Router takes a list of RouteCallerFactory, in other words: a Router can be configured via constructor. So to complete the \u0026ldquo;routing picture\u0026rdquo;:\nOk, so far we have covered the \u0026ldquo;routing part\u0026rdquo;. So at the end the Router offers an Observable\u0026lt;List\u0026lt;RouteCaller\u0026lt;T\u0026gt;\u0026gt;\u0026gt;. But when do we finally load items to display them in the RecyclerView. This is the responsibility of ItemsLoader. As the name already suggests this component loads items:\nclass ItemsLoader\u0026lt;T\u0026gt;(protected val router: Router\u0026lt;T\u0026gt;) { fun firstPage(): Observable\u0026lt;T\u0026gt; { return FirstPage\u0026lt;T\u0026gt;(router.getAllRoutes()).asObservable() } fun olderPages(): Observable\u0026lt;T\u0026gt; { return OlderPage\u0026lt;T\u0026gt;(router.getAllRoutes()).asObservable() } } The ItemsLoader takes a Router as constructor parameter and offers two methods:\n firstPage(): Returns an Observable representing the first page. olderPages(): Returns an Observable to load older pages.  A Page represents a page of items displayed in the RecyclerView. If we scroll to the end of the RecyclerView we load the next page containing older items. Let\u0026rsquo;s have a look at the FirstPage extends Page and OlderPage extends Page classes:\nabstract class Page\u0026lt;T\u0026gt;(val routeCalls: Observable\u0026lt;List\u0026lt;RouteCaller\u0026lt;T\u0026gt;\u0026gt;\u0026gt;) { private var failed = AtomicInteger() private var backendCallsCount: Int = 0 /** * Return an observable for this page */ fun asObservable(): Observable\u0026lt;T?\u0026gt; { return routeCalls.flatMap { routeCalls -\u0026gt; backendCallsCount = routeCalls.size val observables = arrayListOf\u0026lt;Observable\u0026lt;T\u0026gt;\u0026gt;() routeCalls.forEach { call -\u0026gt; val observable = getRouteCall(call).onErrorResumeNext { error -\u0026gt; // Suppress errors as long as not all fail  error.printStackTrace() val fails = failed.incrementAndGet() if (fails == backendCallsCount) { Observable.error(error) // All failed so emmit error  } else { Observable.empty() // Not all failed, so ignore this error and emit nothing  } } observables.add(observable); } // return the created Observable  Observable.merge(observables) } } protected abstract fun getRouteCall(caller: RouteCaller\u0026lt;T\u0026gt;): Observable\u0026lt;T\u0026gt; } class FirstPage\u0026lt;T\u0026gt;(routeCalls: Observable\u0026lt;List\u0026lt;RouteCaller\u0026lt;T\u0026gt;\u0026gt;\u0026gt;) : Page\u0026lt;T\u0026gt;(routeCalls) { override fun getRouteCall(caller: RouteCaller\u0026lt;T\u0026gt;): Observable\u0026lt;T\u0026gt; { return caller.getFirst(); } } class OlderPage\u0026lt;T\u0026gt;(routeCalls: Observable\u0026lt;List\u0026lt;RouteCaller\u0026lt;T\u0026gt;\u0026gt;\u0026gt;) : Page\u0026lt;T\u0026gt;(routeCalls) { override fun getRouteCall(caller: RouteCaller\u0026lt;T\u0026gt;): Observable\u0026lt;T\u0026gt; { return caller.getOlderWithRetry(); } } Page is responsible for finally executing the http call by invoking RouteCaller\u0026rsquo;s method. We also don\u0026rsquo;t want that one entire page fails just because one backend call has fails. Therefore we use onErrorResumeNext() to \u0026ldquo;intercept\u0026rdquo; errors and only return an error if all http calls have failed.\nThen the Presenter subscribes to the \u0026ldquo;page\u0026rdquo; observable via ItemsLoader.\nDependency Injection You might have already noticed that almost all components described so far takes other components as constructor parameter. This is by design. Now, we use Dagger (I used Dagger1) to compose such element as needed:\n@Module( injects = { HomePresenter.class }, addsTo = ApplicationModule.class // contains Retrofit interfaces ) public class HomeModule { @Provides @Singleton HomePresenter provideSearchPresenter(SourceDao sourceDao, DribbbleService dribbbleBackend, DesignerNewsService designerNewsBackend, ProductHuntService productHuntBackend ) { // Create the router  List\u0026lt;RouteCallerFactory\u0026lt;List\u0026lt;? extends PlaidItem\u0026gt;\u0026gt;\u0026gt; routeCallerFactories = new ArrayList\u0026lt;\u0026gt;(3); routeCallerFactories.add(new HomeDribbbleCallerFactory(dribbbleBackend, sourceDao)); routeCallerFactories.add(new HomeDesingerNewsCallerFactory(designerNewsBackend, sourceDao)); routeCallerFactories.add(new HomeProductHuntCallerFactory(productHuntBackend, sourceDao)); Router\u0026lt;List\u0026lt;? extends PlaidItem\u0026gt;\u0026gt; router = new Router\u0026lt;\u0026gt;(routeCallerFactories); ItemsLoader\u0026lt;List\u0026lt;? extends PlaidItem\u0026gt;\u0026gt; itemsLoader = new ItemsLoader\u0026lt;\u0026gt;(router); return new HomePresenterImpl(itemsLoader); } } As you see, we can use Dagger to configure our Router and ItemsLoader. For the SearchPresenter we configure an ItemsLoader and Router in SearchModule. The advantage is that if we one day would like to add another \u0026ldquo;source\u0026rdquo;, like reddit, to display items from reddit, the only thing we have to do is to define a RedditService (Retrofit), a RedditCallerFactoy and add this CallerFactory to the Router. We can do that in the concrete dagger module without having to touch another already existing component\u0026rsquo;s source code (Open-Closed principle). In other words: we have built a \u0026ldquo;plugin system\u0026rdquo; configureable through dependency injection.\nYou might have noticed the SourceDao class in the code shown above. We will talk about that in the second part of this blog series when we are going \u0026ldquo;truly reactive\u0026rdquo;.\nConclusion of Part 1 This is the first part of a series of blog post. In this first part we have built the fundament by applying Model-View-Presenter and have refactored the way how the app loads data from the backend endpoints. The main idea is to cut this huge and complex task down into several smaller and reusable components like ItemsLoader, Page, Router and RouteCaller which follows more the SOLID principle as Nick Butcher\u0026rsquo;s DataManager implementation.\nAs always, there are better ways to implement such an app. Especially, the ItemsLoader can be done entirely different. My first intention was to create an unlimited Observable for load older pages by using RxJava\u0026rsquo;s switchOnNext() or merge operators as described by Matthias Käppler, but I came to the conclusion that some things regarding UI and error handling are slightly easier to implement if I can split the single observable into two observables (one for first page, one for older page).\nAs always, feedback and suggestions are very welcome!\nIn the next (second) part of this series of blog posts about refactoring the Plaid app we will go \u0026ldquo;truly reactive\u0026rdquo; by using the real power of RxJava. Stay tuned.\nThis is a post in the Refactoring Plaid App series. Other posts in this series:\n  Refactoring Plaid App - A reactive MVP Approach (Part 1)   Refactoring Plaid App - A reactive MVP Approach (Part 2)    ","permalink":"https://hannesdorfmann.com/android/plaid-refactored-1/","tags":["android","software-architecture"],"title":"Refactoring Plaid App - A reactive MVP Approach (Part 1)"},{"categories":["Android"],"contents":"I finally found some time last weekend to work on FragmentArgs and to release a new major version 3.0. Here is an overview of new features and bug fixes.\nMigration The good news first: FragmentArgs 3.0 is completely backward compatible to all previous versions (down to 1.0). So basically you have to do nothing. However, I recommend to add the @FragmentWithArgs annotations to your Fragments that contain @Arg annotations. Why? See What\u0026rsquo;s new section and Bugfixes sections.\nWhat\u0026rsquo;s new?  I have added @FragmentWithArgs and you should annotate all Fragment classes with this annotation. For backward compatibility reasons @FragmentWithArgs is not mandatory. However, I strongly recommend to use @FragmentWithArgs because in further versions of FragmentArgs this could become mandatory to support more features. @FragmentArgsInherited is deprecated now. Use @FragmentWithArgs(inherited = true or false) instead. The generated Builder classes are now annotated with @NonNull from android support annotations library. This allows LINT to check your builders as well. You can disable that (see \u0026ldquo;Annotation Processor Options\u0026rdquo; below) Setter methods: You still have to annotate fields with @Arg (not the setter method itself). FragmentArgs detects the corresponding setter method automatically. This allows you to annotate private or protected fields with @Arg. However, I still recommend to use package (default) visibility for your argument fields:  @FragmentWithArgs public class MyFragment extends Fragment { @Arg int id; @Arg private String mTitle; // private fields requires a setter method  // Setter method for private field.  // The name must be the \u0026#34;set\u0026#34; prefix concatenated with field name  public void setTitle(String title){ this.title = title; } } FragmentArgs supports hungarian notation for detecting fields (even if your setter method would be called setMTitle() or setmTitle()). Nevertheless, I\u0026rsquo;m not a fan of the hungarian notation. We are not old school C++ developers living in the 1990\u0026rsquo;s. We should stop using the hungarian notation on android.\nKotlin support The kotlin programming language is supported (use kapt instead of apt). Since FragmentArgs 3.0 now supports setter methods kotlin backing fields are supported out of the box (because backing fields simply generate getter and setters).\n@FragmentWithArgs class KotlinFragment : Fragment() { @Arg var foo: String = \u0026#34;foo\u0026#34; @Arg(required = false) lateinit var bar: String // works also with lateinit for non primitives  override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) FragmentArgs.inject(this) } override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { val view = inflater.inflate(R.layout.fragment_kotlin, container, false) val tv = view.findViewById(R.id.textView) as TextView tv.text = \u0026#34;Foo = ${foo} , bar = ${bar}\u0026#34; return view; } } Annotation Processor Options The FragmentArgs annotation processor supports some options for customization.\n// Hugo Visser\u0026#39;s APT plugin apt { arguments { fragmentArgsLib true fragmentArgsSupportAnnotations false fragmentArgsBuilderAnnotations \u0026#34;hugo.weaving.DebugLog com.foo.OtherAnnotation\u0026#34; } } // Kotlin Annotation processor kapt { generateStubs = true arguments { arg(\u0026#34;fragmentArgsLib\u0026#34;, true) arg(\u0026#34;fragmentArgsSupportAnnotations\u0026#34;, false) arg(\u0026#34;fragmentArgsBuilderAnnotations\u0026#34;, \u0026#34;hugo.weaving.DebugLog com.foo.OtherAnnotation\u0026#34;) } }  fragmentArgsLib: If you want to use FragmentArgs in android library projects. See github readme for more informtation. fragmentArgsSupportAnnotations: As default the methods of the generated Builder are annotated with the annotations from support library like @NonNull etc. You can disable that feature by passing false. fragmentArgsBuilderAnnotations: You can add additional annotations to the generated Builder classes. For example you can add @DebugLog annotation to the Builder classes to use Jake Wharton\u0026rsquo;s Hugo for logging in debug builds. You have to pass a string of a full qualified annotation class name. You can supply multiple annotations by using a white space between each one. The sample show above would generate a builder class like this:  @hugo.weaving.DebugLog @com.foo.OtherAnnotation public final class MyFragmentBuilder { ... } Bugfixes:  #30: There was a bug when having a Fragment with optional arguments only (@Arg(required = false)). This has been fixed. #32: It wasn\u0026rsquo;t possible to generate a builder for a Fragment without any @Arg annotation. TL;DR: Use @FragmentWithArgs also on Fragments with no arguments and the corresponding generated Builder to instantiate an instance. The long story: So why would should you use the FragmentArgs Builder if you don\u0026rsquo;t have arguments anyway? Imagine you have a Fragment called MyFragment. If it doesn\u0026rsquo;t have any argument then it\u0026rsquo;s safe to instantiate the Fragment directly via new MyFragment(). However, you should always use a FragmentArgs builder: Why? The reason is consistency and compile time verification. Imagine that one day in the future MyFragment needs an argument. So now you would have to scan all of your code for new MyFragment() calls and replace them with the new MyFragmentBuilder(argument).build(). What if you overlook one new MyFragment() statement. So your code will still compile, but will crash at runtime because the argument is missing. If you would have used new MyFragmentBuilder() instead even for fragments without arguments from the beginning you won\u0026rsquo;t run into this kind of issue because as soon as you add an argument by using @Arg to MyFragment class the Builder will throw an compile error because the argument is required as constructor parameter in new MyFragmentBuilder(argument).  ","permalink":"https://hannesdorfmann.com/android/fragmentargs3/","tags":["android","library"],"title":"FragmentArgs 3.0"},{"categories":["Android"],"contents":"Lately I was looking for a way to display some app internal information to an external staff that is not a developer. I haven\u0026rsquo;t found a library that fit my needs. Hence I have written my own tiny library called DebugOverlay to do this job.\nUsually we as developers would log app internal things by using logcat Log.d(). But what if we have to provide app internal logs to non developers? Can they access logcat? Do they have to install android studio and enable developer options on their android device? Wouldn\u0026rsquo;t it be nice if non developers could just see these logging information directly in the app somehow? In my concrete use case I was looking for a way to display tracking information on screen to allow external staff (not developers) to validate that the app was tracking the right information as the string to be tracked is computed dynamically for each screen (plenty of parameters and conditions).\nObviously, we can and should write unit tests for that (Robolectric powered unit tests could do that job much faster as instrumentation tests). However, there is a lot of money depending on the correctness of the tracking (advertisement contracts are negated on the reach of the app) and therefore an external staff has to verify manually that the tracking works correctly. As already said this external staff is not a developer. Hence he need a comfortable way to get displayed this information directly in the app. So how could we display the tracking information? The simplest way is to display a Toast, but that doesn\u0026rsquo;t work well when navigating fast in the app like swiping in a ViewPager. An alternative could be to add a TextView dynamically on each Activity and Fragment\u0026rsquo;s root layout. The problem with that approach is that this leads to fragile code.\nWhat I really want is having an independent window just for displaying tracking information in a logcat alike fashion, something like this:\nWhy an independent window? Because I want avoid side effects on my production code. How to implement such a window? It\u0026rsquo;s easier than you might have thought before. I guess you have already heard or already used facebook\u0026rsquo;s chat heads. I\u0026rsquo;m sure there are plenty tutorials and blog post out there describing how to implement something like that. In a nutshell: Implement your own android Service and use the WindowManager to add a View. Yes, services can have Views:\nclass DebugOverlayService extends Service { @Override public void onCreate(){ FrameLayout rootLayout = new FrameLayout(); rootLayout.addView(listView); rootLayout.addView(closeButton); WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); WindowManager.LayoutParams windowParams = new WindowManager.LayoutParams( LayoutParams.MATCH_PARENT, LayoutParams. WRAP_CONTENT, WindowManager.LayoutParams.TYPE_PHONE, WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE, PixelFormat.TRANSLUCENT); windowManager.addView(rootLayout, windowParams); } } As you see, I use the chat heads idea to put a FrameLayout containing a ListView and a close button in an dedicated window. By clicking on the close button the service will be stopped and the dedicated window removed:\n// called when the close button has been clicked windowManager.removeView(rootLayout) service.stopSelf(); At the end I put this simple service in a library and have created a facade class called DebugOverlay as public API. This class is also responsible to start and bind the service and to submit new log message to this service. So we can use the DebugOverlay like this:\nDebugOverlay.with(context).log(\u0026#34;Hello World\u0026#34;); Next you may ask how do I ensure that this debug overlay window is just added to debug builds and not to the release builds. I have created a second library artifact with the same DebugOverlay facade API but does nothing on method calls.\ndebugCompile(\u0026#39;com.hannesdorfmann:debugoverlay:0.2.0\u0026#39;) // Starts the service and displays the overlay releaseCompile(\u0026#39;com.hannesdorfmann:debugoverlay-noop:0.2.0\u0026#39;) // Does nothing I use gralde build types to include the debugoverlay dependency that do display the debug overlay window in debug builds and use the other debugoverlay-noop dependency for release builds.\nThe debugoverlay-noop adds 1 class and 3 methods to your release dex file, which from my point of view is an acceptable compromise.\nPlease note that com.hannesdorfmann:debugoverlay:0.2.0 will add android.permission.SYSTEM_ALERT_WINDOW permission to your apk. Hence you should avoid to use that dependency in your release .apk\nYou can find this tiny library on github and is available on maven central.\nUpdate It seems that I have missed some already existing libraries that could do the same job as DebugOverlay:\n GhostLog by Jeff Gilfelt Galgo by Inaka Lynx by Pedro Vicente Gómez Sánchez  Thanks to everyone for reporting these libraries.\n","permalink":"https://hannesdorfmann.com/android/debugoverlay/","tags":["android","library"],"title":"Debug Overlay"},{"categories":["Android"],"contents":"From my point of view user experience is a very important topic but sometimes doesn\u0026rsquo;t get the attention it deserves. In this blog post I want to show you how to use RecyclerView to build an user experience that is not interrupting the user\u0026rsquo;s flow.\nI\u0026rsquo;m very lucky to work in a very talented team at Tickaroo where we are building and maintaining the android and iOS apps for kicker, one of the most important football magazine in Europe (even though the main language is German). The app basically displays news about football (but also about other sports), live scores \u0026amp; live updates (push notifications), statistics, videos, photo galleries and so on and so forth. A few days ago we published an update for the kicker android app where we integrated a new interactive feature: tip game (betting game, footy tipping, tip guessing or whatever the name for that is in your local area). So the idea is that the users of the kicker app try to guess the results of football games and get points when the guessed results are correct.\nWhen starting the kicker app you see a RecyclerView displaying different items, amongst others news articles, game results and upcoming games. The first question is how do we integrate the new tip game feature? Next, how does the user can submit \u0026ldquo;tips\u0026rdquo; (try to guess the result) for a game? We could have made our life easy (from developers point of view) and simply start a new Activity to display a list of games the user can submit \u0026ldquo;tips\u0026rdquo; for (try to guess the result). But we decided to implement two \u0026ldquo;modes\u0026rdquo; because we already display the last results and upcoming games in the RecyclerView: The \u0026ldquo;normal\u0026rdquo; mode where our users see the upcoming games or results of the last games and the \u0026ldquo;tip\u0026rdquo; mode where users can submit a tip (guess the result) and see if their guess was correct after the game is finished. So the final result looks like this:\n  Instead of interrupting the users flow by starting a new Activity we decided to switch between both modes with a flip animation by pressing the \u0026ldquo;tippen\u0026rdquo; (german for \u0026ldquo;guessing results\u0026rdquo;) and \u0026ldquo;schließen\u0026rdquo; (german for \u0026ldquo;close\u0026rdquo;) button.\nHow did we implement that? Obviously I can\u0026rsquo;t share the whole source code, but I will give you some insights and pitfalls we have faced.\nFlip items As you have seen in the video shown above we are animating the items of the RecyclerView. We started by using a layout file containing both child layouts for normal mode and tip mode, like this:\n\u0026lt;FrameLayout\u0026gt; \u0026lt;LinearLayout android:id=\u0026#34;normalMode\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; ... \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:id=\u0026#34;tipMode\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:visibility=\u0026#34;invisible\u0026#34;\u0026gt; ... \u0026lt;/LinearLayout\u0026gt; \u0026lt;/FrameLayout\u0026gt; Then the ViewHolder in the RecyclerView will have a reference to \u0026ldquo;normalMode\u0026rdquo; and \u0026ldquo;tipMode\u0026rdquo; layout. Flipping the views is simply a rotationX() animation as shown below (don\u0026rsquo;t forget to set the visibility from \u0026ldquo;visible\u0026rdquo; to \u0026ldquo;invisible\u0026rdquo; and vice versa):\npublic void animateToTipMode(TipViewHolder holder, int delay){ int duration = 100; // Flip the \u0026#34;normalMode\u0026#34; View \u0026#34;out\u0026#34;  ViewCompat.animate(viewHolder.normalMode) .rotationX(90) // Animate from 0 to 90  .setDuration(duration) .setStartDelay(delay) .setListener(new ViewPropertyAnimatorListenerAdapter(){ @Override public void onAnimationEnd(View view) { viewHolder.normalMode.setVisibility(View.INVISIBLE); } }) .start(); // Flip the \u0026#34;topMode\u0026#34; View \u0026#34;in\u0026#34;  ViewCompat.setRotationX(holder.tipMode, -90); ViewCompat.animate(viewHolder.tipMode) .rotationX(0) // Animate from -90 to 0  .setDuration(duration) .setStartDelay(delay) .setListener(new ViewPropertyAnimatorListenerAdapter(){ @Override public void onAnimationEnd(View view) { viewHolder.normalMode.setVisibility(View.VISIBLE); } }) .start(); } So basically the animation runs from 0 to 90 for animating view out and from -90 to 0 for animating the view in. The wave alike execution of the flip animation is done by adding a start delay and increase that delay for each item. So all we have to do is to collect those items above the button that triggers the switch between both modes. TipViewHolder is the ViewHolder for the xml layout containing normalMode and tipMode child layouts. In the old days of ListView we would have done that simply by iterating over its children with ListView.getChildAt(index), but RecyclerView internally handles its children different (with a LayoutManager). Hence, RecyclerView.getChildAt(index) doesn\u0026rsquo;t return the views in the expected order as the ListView does. When working with RecyclerView you have to work with ViewHolder as well. ViewHolder is not just a plain old class to hold references to the child views and to reduce findViewById() operations, no, ViewHolder knows more about how it is used internally in the parent RecyclerView. So you can query the current adapter position of a ViewHolder with ViewHolder.getAdapterPosition(). We use that to get the adapter position of the button that starts the flip animation (have a look at the video shown above: there is a button to start the flip animation to switch between \u0026ldquo;normal mode\u0026rdquo; and \u0026ldquo;tip mode\u0026rdquo;). In our app we know that all games (TipViewHolder) are above the clicked button, so we just have to iterate from button position up in adapters dataset. We also can assume that between two groups of games / tips is at least one other type of ViewHolder, hence we can use instanceof TipViewHolder to dertermine where the wave animation should stop:\npublic void onSwitchToTipModeClicked(ViewHolder buttonViewHolder){ int adapterPosition = buttonViewHolder.getAdapterPosition(); int index = adapterPosition - 1; int delay = 70; while (index \u0026gt;= 0){ ViewHolder vh = recyclerView.findViewHolderForAdapterPosition(index); if (! (vh instanceof TipViewHolder) ){ break; } animateToTipMode((TipViewHolder) vh, delay * (adapterPosition - index)); index --; } } We use to viewHolder.getAdapterPosition() to determine the start position and then we step up in the adapter and check if the ViewHolder at the given index is of type TipViewHolder. We can get the ViewHolder at the given adapter position by using RecyclerView.findViewHolderForAdapterPosition(index). Note that this returns null if there is no ViewHolder for that adapter index because the item with the given adapter index is not visible on screen (item is above or below the visible rectangle of RecyclerView, the user have to scroll to bring that item into RecyclerViews visible rectangle). Please note also that null instanceof Something returns false.\nAnother thing developers should take more care of when building their UI is that animations can be used to \u0026ldquo;hide\u0026rdquo; that the app is loading data. In our app when the user switches from \u0026ldquo;normal mode\u0026rdquo; to \u0026ldquo;tip mode\u0026rdquo; we execute a http request to load the previously guessed results (if there are any) in background. Usually, our users don\u0026rsquo;t notice that data has been loaded because we don\u0026rsquo;t show a loading indicator. We use the time the wave alike animation takes to load the data. This gives the user of our app the impression that our app works lightning fast because there is no visual interruption by displaying a loading indicator. What if the user has a slow internet connection? Then yes, we display a loading indicator after the wave animation is finished.\nThe downside What is the downside of this approach? The layout file contains a huge view hierarchy since it displays both \u0026ldquo;normalMode\u0026rdquo; and \u0026ldquo;tipMode\u0026rdquo;. That wouldn\u0026rsquo;t be a problem if the majority of our users would use high level devices like a Galaxy S6 or even devices comparable with Nexus 4. Unfortunately it turns out that decent devices like the Samsung Galaxy S3 Mini are the most used devices of our users. What does that mean? Huge view hierarchy leads to bad scroll performance, especially noticeable on low-end devices. The tip game is an optional feature of our app mainly used by power users. I, personally, expect that about 30% of our users will participate in the tip game. That would mean that 70% of the users may face scroll performance issues because of the tip game even if they don\u0026rsquo;t participate in the tip game at all. Hence, we decided to implement the flip animation in a different way: Instead of having one single xml layout for both modes (normal and tip mode) we decided to split them into two layout files and define two view types in our adapter.\nDisclaimer: This might be an overkill if your layout files are already flat enough then the solution described above should just work. However, for us it was necessary to work with different view types to guarantee acceptable scroll performance even on decent devices.\nLet me explain you how we have implement the same wave alike animation as described in the previous solution: Fortunately, RecyclerView is really powerful and open for extensions. We have implemented a custom ItemAnimator that executes the flip animation (still the same rotationX animation as shown before, from 0 to 90 and -90 to 0). Writing a custom ItemAnimator is not rocket science but it takes some time to dive into the methods you have to implement to make the ItemAnimator work properly. You may be confused why we need an ItemAnimator. An ItemAnimator allows you do define animations to run when new items are inserted, moved or removed from RecyclerViews Adapter. So what we do is we modify the adapters dataset. The idea is the same as shown in the previous solution: we iterate over the adapters dataset, but this time instead of checking for the ViewHolder and starting the flip animation manually we remove the Game items (displaying items in \u0026ldquo;normal mode\u0026rdquo;) from adapters dataset and replace them with Tip items (displaying items in \u0026ldquo;tip mode\u0026rdquo;). How is it related to ItemAnimator? If you haven\u0026rsquo;t noticed yet, RecyclerView offers two methods notifyItemRangeRemoved() and notifyItemRangeInserted():\npublic void onSwitchToTipModeClicked(ViewHolder buttonViewHolder, List dataset){ int MIN_DEVICE_YEAR = 2012; int adapterPosition = buttonViewHolder.getAdapterPosition(); int index = adapterPosition - 1; int bottomIndex = index; int invisibleStartIndex = - 1; List\u0026lt;Tip\u0026gt; tipsToInsert = new ArrayList\u0026lt;\u0026gt;(); while (index \u0026gt;= 0){ Object item = dataset.get(index); if (! (item instanceof Game) ){ break; } Game game = (Game) item; RecyclerView.ViewHolder viewHolder = recyclerView.findViewHolderForAdapterPosition(index); if (viewHolder == null){ // Element not visible on screen, so we can replace the item directly  dataset.set(index, game.getTip()); if (invisibleStartIndex == -1){ invisibleStartIndex = index; } } else { // Element is visible on screen  viewHolder.itemView.setTag(R.id.adapterIndexWorkaround, adapterPosition); // Workaround  tipsToInsert.add(0, game.getTip()); // Keep the order  } index--; } int topIndex = invisibleStartIndex \u0026gt;= 0 ? invisibleStartIndex : index + 1 ; // Remove old visible \u0026#34;Game\u0026#34; items  for (int i = bottomIndex; i \u0026gt;= topIndex; i--) { dataset.removeItem(i); // Reason for workaround  } if (deviceYear \u0026gt;= MIN_DEVICE_YEAR){ adapter.notifyItemRangeRemoved(topIndex, tipsToInsert.size()); // Triggers remove flip animation  } // Insert visible \u0026#34;Tip\u0026#34; items  dataset.addAll(topIndex, tipsToInsert); if (deviceYear \u0026gt;= MIN_DEVICE_YEAR){ adapter.notifyItemRangeInserted(topIndex, tipsToInsert.size()); // Triggers insert flip animation  } else { // Without animations because of low-end device  adapter.notifyDataSetChanged(); } } Let\u0026rsquo;s discuss the code shown above: Similar to the first discussed solution we start at the adapter position of the button to switch between the normal and tip mode. Since we can assume that the button is visible in the RecyclerView (otherwise it couldn\u0026rsquo;t be clicked right?) and all Games of this group are above the button we just have to iterate from bottom to top in adapters dataset. We use the check item instanceof Game to determine where the group of games finishes (in our app we always have at least one different item between a group of games). Next we check if viewHolder == null which means that the item is not visible in RecyclerView. In that case we can directly replace the Game item with the corresponding Tip item. We also note the index where the first not visible item begins by storing the list position into invisibleStartIndex. If the item is visible then we add the corresponding tip into tipsToInsert. We also have to implement a little workaround to keep the original adapter\u0026rsquo;s position by using setTag() which allows to store data in an internally Map\u0026lt;Integer, Object\u0026gt; every android.view.View has (it\u0026rsquo;s recommended to use R.id.something as key). Why do we need this workaround? Well, we want that our ItemAnimator flips the items in a wave alike manner. To schedule the single animations for each item correctly it\u0026rsquo;s important to know the index. Every ViewHolder knows it\u0026rsquo;s index by using viewHolder.getAdapterPosition(), but that method will return -1 as we have removed the item from adapters dataset. Usually ItemAnimator could use viewHolder.getOldPosition() which would return the previous position (before removing item from adapters dataset). But the problem is that in our concrete use case all viewHolder.getOldPosition() return the same value. Why? Because we are removing every item manually in a for loop (because List lacks a method to remove a multiple items at once similar to list.addAll()). Hence, our ItemAnimator have to use that workaround to schedule the flip animation properly. Last, you may have noticed MIN_DEVICE_YEAR. I can\u0026rsquo;t remember what the problem exactly was (I should note down such things), but on very old devices you can run into the problem that the RecyclerView reaches an insane internal state (which can lead to crashes) if the item animation takes to long because of low-end hardware. To avoid that we use Facebook\u0026rsquo;s Device Year Class library to detect old devices and simply don\u0026rsquo;t run the flip animation on those devices by directly calling adapter.notifyDataSetChanged().\nSubmit a tip Next you may be wondering how you can submit a tip. We started by implementing a dialog with number pickers. But the problem was that you have to open the dialog for a game to submit a tip, close the dialog and open the next tip dialog for the next tip. This was definitely not the user experience we wanted. So we improved that by passing a list of games the user can guess results for to a single dialog to avoid opening and closing the dialog for each game:\n  Guessing in a rush However, a Dialog is still interrupting the user\u0026rsquo;s experience. So we came up with the idea to use swipe gestures. This allows the user to guess results on the fly without interrupting the user\u0026rsquo;s flow by displaying a Dialog. Have a look at the final result:\n  By swiping the item to the right the user can increase the score of the home team while swiping the item left increases the away team score. Implementing that is straight forward if you have ever worked with MotionEvents on android before. In a nutshell: every android ViewGroup offers two methods that are called during dispatching MotionEvents: In boolean onInterceptTouchEvent() you get some MotionEvents to decide if that ViewGroup should intercept and consume all following MotionEvents afterwards in void onTouchEvent(). It\u0026rsquo;s like ordering a good bottle of wine in a restaurant. The waiter brings you the bottle and a wine glass and offers you a sip of the ordered wine. After taking a small sniff, inspecting the color, swirling the wine in the glass you decide whether to keep the wine or not (returning true or false in onInterceptTouchEvent()). If yes, you consume the wine (onTouchEvent()). Working with RecyclerView is no different. Fortunately, you don\u0026rsquo;t have to subclass RecyclerView and override that methods because those methods are already used to detect scroll and fling events. RecyclerView offers you to add an OnItemTouchListener to intercept MotionEvents on the displayed itmes in the RecyclerView.\npublic abstract class TipSwipeListener implements RecyclerView.OnItemTouchListener { private final int threshold; private float xStart = 0; private float yStart = 0; private TipViewHolder startViewHolder; private int increaseMaxSwipeDistance; @Override public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) { final int action = MotionEventCompat.getActionMasked(e); // Touching somewhere in the RecyclerView  if (action == MotionEvent.ACTION_DOWN) { xStart = e.getX(); yStart = e.getY(); // Determine the View we touch  View startTouchedView = rv.findChildViewUnder(e.getX(), e.getY()); if (startTouchedView == null) { return false; } // Determine the ViewHolder that has been touched  RecyclerView.ViewHolder vh = rv.getChildViewHolder(startTouchedView); if (vh != null \u0026amp;\u0026amp; vh instanceof TipViewHolder) { startViewHolder = (TipViewHolder) vh; } return false; } // Move the finger on the screen (not released finger from screen yet)  if (action == MotionEvent.ACTION_MOVE \u0026amp;\u0026amp; startViewHolder != null) { float xDif = Math.abs(xStart - e.getX()); float yDif = Math.abs(yStart - e.getY()); if (xDif \u0026gt;= threshold \u0026amp;\u0026amp; xDif \u0026gt; yDif) { // finger is moving horizontally  return true; } // finger is moving vertically  return false; } // releasing finger from screen  if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) { reset(); } return false; } @Override public void onTouchEvent(RecyclerView rv, MotionEvent e) { final int action = MotionEventCompat.getActionMasked(e); float xDif = e.getX() - xStart; if (action == MotionEvent.ACTION_MOVE) { if (startViewHolder.getTippView() != null) { if (xDif \u0026lt; 0) { startViewHolder.translateXAwayTeam(0); startViewHolder.translateXHomeTeam(Math.max(xDif, -increaseMaxSwipeDistance)); } else if (xDif \u0026gt; 0) { startViewHolder.translateXHomeTeam(0); startViewHolder.translateXAwayTeam(Math.min(xDif, increaseMaxSwipeDistance)); } else { startViewHolder.getTippView().translateXHomeTeam(0); startViewHolder.getTippView().translateXAwayTeam(0); } } } else // Released or Canceled swipe gesture  if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) { if (xDif \u0026lt; -increaseMaxSwipeDistance) { onIncreaseAwayScoreSwipe(); // Swiped far enough  } else if (xDif \u0026gt; increaseMaxSwipeDistance) { onIncreaseHomeScoreSwipe(); // Swiped far enough  } else { animateToStartState(xDif); } } } private void onIncreaseAwayScoreSwipe() { // Increment away team\u0026#39;s score  ... reset(); } private void onIncreaseHomeScoreSwipe() { // Increment home team\u0026#39;s score  ... reset(); } private void animateToStartState(float xDif) { // animate the X translation back to 0  ... reset(); } private void reset() { xStart = 0; yStart = 0; startViewHolder = null; } } Most of the code should be self explaining. We simply start in onInterceptTouchEvent() by checking if the user is touching on a Tip item by querying the touched view recyclerView.findChildViewUnder(x, y) and then check if the corresponding ViewHolder is a TipViewHolder by using recyclerView.getChildViewHolder(view). Next we check if the user is moving his finger to left or right. Please note that onInterceptTouchEvent() is called multiple times and we need to inspect more than one passed MotionEvent (parameter) to determine if the user is moving his finger to left or right (wine tasting). If the finger has been moved on x-achsis beyond a threshold, we return true to claim that we want continue to consume this gesture in onTouchEvent().\nIn onTouchEvent() we simply set translationX property according the distance and direction the user has moved his finger. increaseMaxSwipeDistance is the max distance the user can translate the views, which is half of the width of the box displaying the guessed result. And where does the +1 comes from while swiping? This is just a TextView which always was there hidden behind the box displaying the guessed result. By translating the view on x-achsis this TextView becomes visible. Actually, in our app we have overridden onDraw() to draw the +1 directly on the canvas of a custom parent layout to keep the layout hierarchy flat.\nAdding an ItemTouchListener to a RecyclerView is quite easy: recyclerView.addOnItemTouchListener(). Last, you may be wondering if this horizontal swipe listener can be used in a ViewPager. It turns out that this is easier than expected. ViewPager, like any other ViewGroup, allows it\u0026rsquo;s children to claim that they don\u0026rsquo;t want that the parent intercepts touch events by calling ViewPager.requestDisallowInterceptTouchEvent(boolean). So a good place to set requestDisallowInterceptTouchEvent() to true would be in onInterceptTouchEvent() right before returning true and release it in reset(), called when finger has been moved up. By the way, if you don\u0026rsquo;t know if you have a ViewPager in your view hierarchy you can iterate recursively from bottom to top in your view hierarchy by using view.getParent() (do it only once and not every time you move your finger).\nA disadvantage of our swipe approach is that the user can not decrease the guessed score since both x-achsis directions are already used. So we decided to keep the Dialog for that use case and for those not nimble-fingered users.\nSide note: By using AdapterDelegates (favor composition over inheritance) we were able to bring the flip animation to switch between normal and tip mode to almost all RecyclerViews in our whole app without having code clones.\nConclusion The less the user\u0026rsquo;s flow is interrupted, the better the experience. Other great examples following this principle are the Google Photos and Inbox. With some gestures and animation those apps are able to give their users an outstanding user experience. Whether or not you like our flip animation approach I hope you get an idea how ItemAnimator and OnTouchListener could be used together with RecyclerView to create an user experience that tries to interrupt the user\u0026rsquo;s flow as less as possible. By the way, the kicker app looks much better on a real device than on a youtube video.\nPS: The credit for the described user experience in this blog post goes to the whole Tickaroo team and not only to me. We have developed this user experience together. Our designer had some initial thoughts and ideas, the iOS developers put some things into and we android developers as well during prototyping phase.\nAdditional Resources  RecyclerView Animations Part1 Part2 Some inspiration how to write a custom ItemAnimator on Github Managing Touch Events in a ViewGroup  ","permalink":"https://hannesdorfmann.com/android/dont-interrupt-user-flow/","tags":["android","ui","ux"],"title":"Don't interrupt the user's flow"},{"categories":["Android"],"contents":"Let me tell you a story about Joe Somebody an android developer at MyLittleZoo Inc. and how he walked through the hell while trying to create reusable RecyclerView Adapters with different view types and how he finally managed to implement reusable Adapters painlessly.\nOnce upon a time Joe Somebody, an android developer, was working for a young startup called MyLittleZoo Inc. This startup was selling stuff for pets online. Joe\u0026rsquo;s job was to build and maintain a native android app which basically offers the same functionality as the online shop (website). So 90% of the android app he had to develop just displays a list of items in a RecyclerView. The first version 1.0 should just display a list of Accessories. Joe implemented an AccessoiresAdapter which displays a list of accessories, but special offers for accessories are displayed by using item_accessory_offer.xml while the item_accessory.xml is used to display any normal accessories item. So the Adapter has two view types. A view type allows you to inflate different xml layouts for different items in the adapter. Internally a view type is just a unique id, an integer. So Joe\u0026rsquo;s AccessoiresAdapter implementation looks like this:\npublic class AccessoiresAdapter extends RecyclerView.Adapter { final int VIEW_TYPE_ACCESSORY = 0; final int VIEW_TYPE_ACCESSORY_SPECIAL_OFFER = 1; List\u0026lt;Accessory\u0026gt; items; @Override public int getItemViewType(int position) { Accessory accessory = items.get(postion); if (accessory.hasSpecialOffer()){ return VIEW_TYPE_ACCESSORY_SPECIAL_OFFER; } else { return VIEW_TYPE_ACCESSORY; } } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (VIEW_TYPE_ACCESSORY_SPECIAL_OFFER == viewType){ return new SpecialOfferAccessoryViewHolder(inflater.inflate(R.layout.item_accessory_offer, parent)); } else { return new AccessoryViewHolder (inflater.inflate(R.layout.item_accessory)): } } ... } So far so good, MyLittelZoo android app 1.0 was published on Play Store. Everything was cool.\nThen MyLittelZoo grew, so did the app. Joe had to implement a new starting Activity where different items could be displayed: NewsTeaser should now be displayed together with Accessories. Since HomeAdapter should display Accessories as well he decided to reuse AccessoriesAdapter by inheriting from that one:\npublic class HomeAdapter extends AccessoriesAdapter { final int VIEW_TYP_NEWS_TEASER = 2; @Override public int getItemViewType(int position) { if (items.get(position) instanceof NewsTeaser){ return VIEW_TYP_NEWS_TEASER; } else { // accessories and special offers  return super.getItemViewType(position); } } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (VIEW_TYP_NEWS_TEASER == viewType){ return new NewsTeaserItem( inflater.inflate(R.layout.item_news_teaser, parent)); } else { // accessories and special offers  return super.onCreateViewHolder(parent, viewType); } } ... } Also a new Activity just displaying some short tips about pet food should be implemented. Hence Joe implemented PetFoodTipAdapter:\npublic class PetFoodTipAdapter extends RecyclerView.Adapter { final int VIEW_TYP_FOOD_TIP = 0; @Override public int getItemViewType(int position) { return VIEW_TYP_FOOD_TIP; } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { return new PetFoodViewHolder(inflater.inflate(R.layout.item_pet_food, parent)) } ... } His project manager was happy since he was able to deliver in time. MyLittelZoo 2.0 was released on Play Store successfully.\nA few weeks later product manager came to Joe and told him that business hadn\u0026rsquo;t developed as expected. To earn money the company decided to sign a contract with a big advertisement company. The advertisement company could display banners in MyLittleZoo android app. In other words: they sold their soul to the devil. Joe\u0026rsquo;s job was to include advertisement banner in the app by using a provided advertisement sdk. The clock ticked, the company needed money (revenue from advertisement). The app update had to be published as soon as possible. Since advertisement banner should be displayed along with other items in a RecyclerView Joe decided to create a new base adapter class called AdvertismentAdapter:\npublic class AdvertismentAdapter extends RecyclerView.Adapter { final int VIEW_TYP_ADVERTISEMENT = 0; @Override public int getItemViewType(int position) { return VIEW_TYP_ADVERTISEMENT; } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { return new AdvertismentViewHolder(inflater.inflate(R.layout.item_advertisment, parent)) } ... } From then on, every other Adapter extends from AdvertisementAdapter:\n AccessoiresAdapter extends AdvertisementAdapter HomeAdapter extends AccessoiresAdapter extends AdvertisementAdapter PetFoodTipAdapter extends AdvertisementAdapter  Version 3.0 was published on Play Store with advertisement banner everywhere. Once more product manager was happy with Joe\u0026rsquo;s work.\nA half year later again the product manager knocked on Joe\u0026rsquo;s door to tell him that things had changed. Surprisingly it turned out that the user of MyLittleZoo android app didn\u0026rsquo;t liked the blinking advertisement banner introduced in version 3.0 and the app got huge negative reviews on play store. User sessions dropped dramatically and company didn\u0026rsquo;t earn money anymore. But MyLittleZoo couldn\u0026rsquo;t simply remove advertisement from the app since they have signed a valid longterm contract with the devil, ehm I mean the advertisement company of course.\nThen the smart marketing guy at MyLittleZoo had the brilliant idea to launch a second app with just displaying NewsTeaser and PetFoodTip in a RecyclerView. No advertisement, no offers. The plan was to regain the confidence of the users. Furthermore, product manager told Joe that the app had to be published within next two days because at the upcoming weekend was a big pet fair where the app should be presented. Joe thought it was doable. He already had the xml layouts for NewsTeaser and PetFoodTip and the adapter were already implemented. So all Joe had to do is to move that into an android library to share them between original MyLittleZoo app and the new advertisement free app.\nJoe was about to start moving things into the library when he realized the mess he was facing: Do you remember the inheritance hierarchy of the adapters?\n Every Adapter extends from AdvertisementAdapter. But no advertisement should be displayed in the new app. Moreover, the provided advertisement sdk to display banners is really buggy, causes memory leaks and crashes quite often. Even if no advertisement banner was displayed the advertisement sdk did a lot of crap in the background. Therefore, including the advertisement sdk in the new app was not acceptable. There is no adapter that he can reuse that can display NewsTeaser (part of HomeAdapter) and PetFoodTip (part of PetFoodTipAdapter). What should Joe do? He could create a new Adapter called NewsTipAdapter that extends from HomeAdapter and then he would had to add the PetFoodTip as new view type. But that would mean that he would had two Adapters to maintain for the same view type PetFoodTip.  Welcome to the adapter hell Joe! Oh boy, Joe was depressed. Then panic followed depression. How should he fix that? How should he fix that without having to fix it again a month later when a new feature (a new view type) must be implemented?\nSo Joe started to write down his requirements on a whiteboard. But not a single good idea came out. He was so sad, he thought back to the days when he was a little child. How easy was life during childhood. The only thing he had to worry those days was to clean up his room after he had finished to play Lego. Lego? Wait, wait, wait! Joe had a brilliant idea: What he really needs is to built adapter like building a Lego house: Take an empty fundament and then stick together that Lego pieces you really need. If you need a window in your Lego house, take a window piece. If you need a roof slope take the corresponding Lego piece. If your Lego house needs a backyard, take a Lego flower.\nDamn, and then he gets the overall picture:\n Favor composition over inheritance\n So many times he had agreed on \u0026ldquo;Favor composition over inheritance\u0026rdquo; while discussing with other developers. Until now it was just a good slogan but he never really have build something according this principle. So an empty Adapter is the fundament. ViewTypes are the reusable components (Lego pieces).\nSo Joe started to define the reusable Lego pieces like NewsTeaserAdapterDelegate and PetFoodTipAdapterDelegate:\npublic class NewsTeaserAdapterDelegate { private int viewType; public NewsTeaserAdapterDelegate(int viewType){ this.viewType = viewType; } public int getViewType(){ return viewType; } public boolean isForViewType(List items, int position) { return items.get(position) instanceof NewsTeaser; } public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent) { return new NewsTeaserViewHolder(inflater.inflate(R.layout.item_news_teaser, parent, false)); } public void onBindViewHolder(List items, int position, RecyclerView.ViewHolder holder) { NewsTeaser teaser = (NewsTeaser) items.get(position); NewsTeaserViewHolder vh = (NewsTeaserViewHolder) vh; vh.title.setText(teaser.getTitle()); vh.text.setText(teaser.getText()); } } public class PetFoodTipAdapterDelegate { private int viewType; public PetFoodTipAdapterDelegate(int viewType){ this.viewType = viewType; } public int getViewType(){ return viewType; } public boolean isForViewType(List items, int position) { return items.get(position) instanceof PetFoodTip; } public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent) { return new PetFoodTipViewHolder(inflater.inflate(R.layout.item_pet_food, parent, false)); } public void onBindViewHolder(List items, int position, RecyclerView.ViewHolder holder) { PetFoodTip tip = (PetFoodTip) items.get(position); PetFoodTipViewHolder vh = (PetFoodTipViewHolder) vh; vh.image.setImageRes(tip.getImage()); vh.text.setText(tip.getText()); } } And then he took the fundament, an empty adapter, and put the Lego pieces on top of it to create the NewsTipAdapter which will be used in the new app:\npublic class NewsTipAdapter extends RecyclerView.Adapter{ final int VIEW_TYP_NEWS_TEASER = 0; final int VIEW_TYP_FOOD_TIP = 1; NewsTeaserAdapterDelegate newsTeaserDelegate; PetFoodTipAdapterDelegate foodTipDelegate; List items; public NewsTipAdapter(){ newsTeaserDelegate = new NewsTeaserAdapterDelegate(VIEW_TYP_NEWS_TEASER); foodTipDelegate = new PetFoodTipAdapterDelegate(VIEW_TYP_FOOD_TIP); } @Override public int getItemViewType(int position) { if (newsTeaserDelegate.isForViewType(items, position)){ return newsTeaserDelegate.getViewType(); } else if (foodTipDelegate.isForViewType(items, position)){ return foodTipDelegate.getViewType(); } throw new IllegalArgumentException(\u0026#34;No delegate found\u0026#34;); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (newsTeaserDelegate.getViewType() == viewType){ return newsTeaserDelegate.onCreateViewHolder(parent); } else if (foodTipDelegate.getViewType() == viewType){ return foodTipDelegate.onCreateViewHolder(parent); } throw new IllegalArgumentException(\u0026#34;No delegate found\u0026#34;); } @Override public void onBindViewHolder(VH holder, int position){ int viewType = holder.getViewType(); if (newsTeaserDelegate.getViewType() == viewType){ newsTeaserDelegate.onBindViewHolder(items, position, holder); } else if (foodTipDelegate.getViewType == viewType){ foodTipDelegate.onBindViewHolder(items, position, holder); } } } I guess you get the point. Instead of inheriting Joe had defined a delegate for each view type. Each delegate was responsible for creating and binding a view holder. As you have noticed in the code snipped above, there is a lot of boilerplate code to write. Joe found a smart plugin solution for that:\n/** * @param \u0026lt;T\u0026gt; the type of adapters data source i.e. List\u0026lt;Accessory\u0026gt; */ public interface AdapterDelegate\u0026lt;T\u0026gt; { /** * Called to determine whether this AdapterDelegate is the responsible for the given data * element. * * @param items The data source of the Adapter * @param position The position in the datasource * @return true, if this item is responsible, otherwise false */ public boolean isForViewType(@NonNull T items, int position); /** * Creates the {@link RecyclerView.ViewHolder} for the given data source item * * @param parent The ViewGroup parent of the given datasource * @return The new instantiated {@link RecyclerView.ViewHolder} */ @NonNull public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent); /** * Called to bind the {@link RecyclerView.ViewHolder} to the item of the datas source set * * @param items The data source * @param position The position in the datasource * @param holder The {@link RecyclerView.ViewHolder} to bind */ public void onBindViewHolder(@NonNull T items, int position, @NonNull RecyclerView.ViewHolder holder); } public class AdapterDelegatesManager\u0026lt;T\u0026gt; { public AdapterDelegatesManager\u0026lt;T\u0026gt; addDelegate(@NonNull AdapterDelegate\u0026lt;T\u0026gt; delegate) { ... } public int getItemViewType(@NonNull T items, int position) { ... } public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { ... } public void onBindViewHolder(@NonNull T items, int position, @NonNull RecyclerView.ViewHolder viewHolder) { ... } } The idea is to register AdapterDelegates to an AdapterDelegatesManager. The AdapterDelegatesManager internally has the logic to determine the right AdapterDelegate for the given view type and to call the corresponding delegate methods. So applying that to NewsTipAdapter the code looks like this:\npublic class NewsTipAdapter extends RecyclerView.Adapter{ final int VIEW_TYP_NEWS_TEASER = 0; final int VIEW_TYP_FOOD_TIP = 1; List items; AdapterDelegatesManager delegates = new AdapterDelegatesManager(); public NewsTipAdapter(){ delegates.add(new NewsTeaserAdapterDelegate()); // Assigns internally ViewType integer  delegates.add(new PetFoodTipAdapterDelegate()); } @Override public int getItemViewType(int position) { return delegates.getItemViewType(items, position); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { return delegates.onCreateViewHolder(parent, viewType); } @Override public void onBindViewHolder(VH holder, int position){ delegates.onBindViewHolder(items, position, holder); } } I guess you can imagine how other adapters of MyLittleZoo app looks now. There is an AdvertisementAdapterDelegate, NewsTeaserAdapterDelegate, PetFoodTipAdapterDelegate and AccessoryAdapterDelegate. From now on adapters can be composed with that view types (AdapterDelegates) that are really needed. Another advantage is that you also have moved out the functionality of inflating layout, creating view holder and binding view holder from one huge adapter class (spaghetti code? god object anti pattern?) into separated, modular and reusable AdapterDelegates. Have you noticed how slim adapters code looks now and that you have a separation of concerns that makes things more extendable and more decoupled? Another nice side effect is that more team members can work in parallel together on the same \u0026ldquo;adapter\u0026rdquo; without fearing complex merge conflicts because not everybody is touching the huge adapter file but rather team members can work on dedicated AdapterDelegate files simultaneously.\nJoe was happy, the product manager was happy and the users of the app were happy. Everybody was happy. Actually, Joe was so happy that he had decided to put AdapterDelegates in an own library and open source it. All\u0026rsquo;s well that ends well.\nYou can find AdapterDelegates on Github and is available in maven central.\nP.S. The AdapterDelegates library also provides a base class ListDelegationAdapter that already puts together RecyclerView.Adapter methods with AdapterDelegatesManager methods so that you can reduce the amount of writing boilerplate code even more:\npublic class NewsTipAdapter extends ListDelegationAdapter { public NewsTipAdapter(){ // delegatesManager is a field defined in super class  // ViewType integer is assigned internally by delegatesManager  delegatesManager.add(new NewsTeaserAdapterDelegate()); delegatesManager.add(new PetFoodTipAdapterDelegate()); } } Check out the library on Github for more details.\nDisclaimer: Joe is not a real person nor is MyLittleZoo Inc. a real company. Both are creatures of my imagination. Please note also that the code snippets shown in this blog post may not compile. It\u0026rsquo;s kind of java alike pseudo code to give you an idea of how real code could look like.\n","permalink":"https://hannesdorfmann.com/android/adapter-delegates/","tags":["android","software-architecture","design-patterns","library"],"title":"Joe's great adapter hell escape"},{"categories":["Android"],"contents":"Earlier this year, one day before Valentine\u0026rsquo;s Day to be precise, I had the glorious idea (ironie) to surprise my lovely girlfriend with a special android app on Valentine\u0026rsquo;s Day. Who said computer science can\u0026rsquo;t be romantic?\nThe idea was simple: I wanted to build an android app that imitates and looks like Tinder but instead of displaying real people nearby, I faked everything so that only my profile gets displayed so she only can choose me. Nearly everything was hard coded except the messaging part. To save time and effort I didn\u0026rsquo;t want to build my own backend to store messages and provide a REST api. Instead I decided to use GCM to send and deliver chat messages form my girlfriend\u0026rsquo;s phone to my phone and vice versa. That required to store the received chat messages on a local SQLite database on the users device. Therefore a database library was needed.\nDatabase To cut a long story short - I didn\u0026rsquo;t managed to implement that fake Tinder app in time. One of the reasons was that I hadn\u0026rsquo;t found a good and simple database abstraction layer library. I could pick just a popular one to get the job done, but that wasn\u0026rsquo;t what I wanted to do. Moreover, I was looking for a library that matched the following criteria:\n Native SQL: I don\u0026rsquo;t like ORM libraries because usually they require to learn their own query language and declarative table schemas. To build efficient queries I have to learn how to use that ORM library (I look at you Hibernate!). If I change ORM library one day, I have to learn how to write efficient queries again for the new ORM library. Moreover, ORM libraries has their own implementations how to save and resolve relations. Sometimes, you have to adjust your model (pojo) classes to make efficient queries possible just because of an ORM implementation detail. I\u0026rsquo;m very familiar with SQL which is universal useable (obviously also outside of the android world). I already know how to build efficient queries in SQL. Therefore, I want to write my queries in pure native SQL. Finally, I came to the conclusion that hiding SQL is not the best idea. Based on RxJava: Many developers are excited about Rx programming, because Rx programming offers functional alike operators like flatMap() etc. Many of them don\u0026rsquo;t understand that by using RxJava they are observing data. Therefore, they don\u0026rsquo;t understand Rx programming at all. It is not only about transforming data. Rx implements the observer pattern. You are subscribing to an observable to get updates. That may be a one time consumable data stream like a http response, but the real power of the observer pattern and RxJava can be seen and used by making a data source observable that can emit more than once items, like a database does: Whenever the data in your database has been changed, all subscribers can be informed about the change by emitting items (so that onNext() gets called again). Immutability: Almost every ORM based library misses that point. I\u0026rsquo;m not going to explain the advantages and disadvantages of immutability. I recommend to read Effective Java by Joshua Bloch or have a look at javapracties.com which sums up the most important things.  I know that this may sounds like an overkill for such a simple app like the fake Tinder app is. It just stores chat messages into a database. Whenever I build an app, I want to ensure that it\u0026rsquo;s build the best way and even more important, with every new app (even with such a little app like the fake Tinder app) I improve my skills and learn new things.\nSQLBrite Don\u0026rsquo;t finishing the app in time also had its advantages: A few days after Valentine\u0026rsquo;s Day the guys over at square (who else?) open sourced SQLBrite which seems to be the database layer I am dreaming of: It\u0026rsquo;s a lightweight wrapper around SQLiteOpenHelper and ContentResolver, it doesn\u0026rsquo;t hide SQLite or SQL API, supports transactions and multithreading and last but not least it introduces reactive stream semantics to queries. Especially, the latter one is worth mentioning: Whenever a row of a sql database table gets updated, inserted or removed SQLBrite triggers a notification to inform queries, which are subscribed for table dataset changes. So I decided to use SQLBrite in the fake Tinder app.\nIn this fake Tinder app you can open ChatActivity which displays a List\u0026lt;ChatMessage\u0026gt; queried from the local SQLite database. As already mentioned before I use GCM to send and receive chat messages. Whenever the app receives a GCM Push notification containing a chat message, the app stores the ChatMessage into the local database. The big advantage of using SQLBrite is that by inserting a new ChatMessage into the local database ChatActivity gets updated automatically because as long as ChatActivity is not destroyed the original query executed in ChatActivity.onCreate() to retrieve List\u0026lt;ChatMessage\u0026gt; is still subscribed (query is Rx Subscriber) to the underlying database table (database table is Rx Observable). But the really cool thing is that you get that update mechanism for free. You don\u0026rsquo;t have to add a single line of code. SQLBrite and RxJava \u0026ldquo;magically\u0026rdquo; do that. No EventBus to start a re-query manually, pure reactive programming power. So whenever the app receives a GCM push notification containing a ChatMessage it stores this ChatMessage into the local SQLite database. If ChatActivity is open while receiving the GCM push notification SQLBrite will automatically deliver the database changes to ChatActivity. It\u0026rsquo;s that easy to keep ChatActivity up to date. This Activity don\u0026rsquo;t even have a pull-to-refresh mechanism like a SwipeRefreshLayout because updates are pushed from SQLBrite automatically. Therefore, there is no reason to implement a pull mechanism.\nSQLBrite Dao SQLBrite is still in it\u0026rsquo;s early days (Version 0.1.0 while writing this blog post). As already said the main focus of SQLBrite is set on providing a wrapper arround SQLite. No ORM and no type-safe query mechanism are provided. So by using SQLBrite you have to work with Cursor and ContentValues. That was a little bit annoying while developing the fake Tinder app. Therefore, I decided to write an annotation processor for \u0026ldquo;very simple\u0026rdquo; object mapping and DAO (Data Access Object) on top of SQLBrite. SQLBrite Dao can be found on Github.\nObject mapping Please note that this is not an ORM. The only thing it does is take a Cursor and read the column into the model class pojo. Only primitives are allowed, no relations like 1:n (1 Chat has many ChatMessages) can\u0026rsquo;t be modeled and resolved. It\u0026rsquo;s more like deserializing data than object mapping. You have to annotate your model class with @ObjectMappable and the desired fields with @Column with the table column name (String) as parameter:\n@ObjectMappable public class ChatMessage { //  // Define Table name and column names as constants  //  public static final String TABLE_NAME = \u0026#34;ChatMessage\u0026#34;; public static final String COL_ID = \u0026#34;id\u0026#34;; public static final String COL_SENDER_NAME = \u0026#34;sender\u0026#34;; public static final String COL_MESSAGE = \u0026#34;lastname\u0026#34;; public static final String COL_TIMESTAMP = \u0026#34;received\u0026#34; public static final String COL_CHAT_ID = \u0026#34;chat_id\u0026#34; //  // Fields mapped to database columns  //  @Column(COL_ID) String id; @Column(COL_SENDER_NAME) String sender; @Column(COL_MESSAGE) String message; @Column(COL_TIMESTAMP) long timestamp; @Column(COL_CHAT_ID) String chatId; public ChatMessage() { } public String getId(){ return id; } public String getSender(){ return sender; } public String getMessage(){ return message; } public long getTimestamp(){ return timestamp; } public String getChatId(){ return chatId; } } An annotation processor (not reflections) then generates ChatMessageMapper class. That generated class (original @ObjectMappable annotated class name + \u0026ldquo;Mapper\u0026rdquo; suffix) looks like this:\npublic final class ChatMessageMapper { private ChatMessageMapper() { } // A RxJava Func1 that maps a row from Cursor to c ChatMessage  public static final Func1\u0026lt;Cursor, ChatMessage\u0026gt; MAPPER = new Func1\u0026lt;\u0026gt;() { ... } /** * Get a type-safe ContentValues Builder * @return The ContentValues Builder */ public static ContentValuesBuilder contentValues() { ... } } As you see a Func1\u0026lt;Cursor, ChatMessage\u0026gt; MAPPER will be generated. You will see in a minute how this MAPPER is used to create ChatMessage** instances from a **Cursor**. You may have also noticed that there is a **ContentValuesBuilder** that can be used as type-safe builder for **ContentValues** like this:\nContentValues cv = ChatMessageMapper.contentValues() .id(\u0026#34;1\u0026#34;) .sender(\u0026#34;Hannes\u0026#34;) .message(\u0026#34;Will you be my Valentine?\u0026#34;) .timestamp(1108389600) .chatId(\u0026#34;chat1\u0026#34;) .build(); ChatMessageMapper is just a generated helper class that makes working with Cursor or ContentValues more convenient.\nDAO Create your own Data Access Object (DAO) where you define methods to manipulate or query your database table. Dao provides SQL grammar so you don\u0026rsquo;t have to deal that much with String concatenation and can use IDE\u0026rsquo;s auto completion to build your sql statements. Usually a DAO represents a database table as following:\npublic class ChatMessageDao extends Dao { @Override public void createTable(SQLiteDatabase database) { CREATE_TABLE(ChatMessage.TABLE_NAME, ChatMessage.COL_ID + \u0026#34; TEXT PRIMARY KEY NOT NULL\u0026#34;, ChatMessage.COL_SENDER_NAME + \u0026#34; TEXT\u0026#34;, ChatMessage.COL_MESSAGE + \u0026#34; TEXT\u0026#34;, ChatMessage.COL_TIMESTAMP + \u0026#34; INTEGER\u0026#34;, ChatMessage.COL_CHAT_ID+\u0026#34; TEXT\u0026#34; ) .execute(database); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { if (oldVersion == 1 \u0026amp;\u0026amp; newVersion == 2){ ALTER_TABLE(ChatMessage.TABLE_NAME) .ADD_COLUMN(ChatMessage.COL_FOO +\u0026#34; TEXT\u0026#34;) .execute(db); } } public Observable\u0026lt;List\u0026lt;ChatMessage\u0026gt;\u0026gt; getMessages(String chatId) { return query( SELECT( ChatMessage.COL_ID, ChatMessage.COL_SENDER_NAME, ChatMessage.COL_MESSAGE, ChatMessage.COL_TIMESTAMP ) .FROM(ChatMessage.TABLE_NAME) .WHERE(ChatMessage.COL_CHAT_ID + \u0026#34; = ? \u0026#34;) ) .args(chatId) // Argument that replaces \u0026#34;?\u0026#34; in WHERE  .run() // Executes query, return Rx Observable  .mapToList(ChatMessage.MAPPER); // The generated Rx Func1  } public Observable\u0026lt;Long\u0026gt; addMessage(String id, String sender, String msg, long ts, String chatId ) { ContentValues values = ChatMessageMapper.contentValues() .id(id) .sender(sender) .message(msg) .timestamp(ts) .chatId(chatId) .build(); return insert(ChatMessage.TABLE_NAME, values); } } As you see we use mapToList() (RxJava operator provided by SQLBrite) and the MAPPER generated by the annotation processor to \u0026ldquo;map\u0026rdquo; a cursor to a List of ChatMessages.\nTo register your Dao classes to SQLBrite you have to create a DaoManager. While a Dao represents a table of a database DaoManager represents the whole database file. DaoManager internally creates a SQLiteOpenHelper and instantiates a SqlBrite instance. All DAO\u0026rsquo;s registered to the same DaoManager share the same SqlBrite instance.\nChatDao chatDao = new ChatDao(); DaoManager.with(context) .databaseName(\u0026#34;Chat.db\u0026#34;) .version(1) .add(chatDao) .logging(true) .build(); Please note that adding DAO\u0026rsquo;s dynamically (later) at runtime is not possible. You have to instantiate a DaoManager and pass all your DAO\u0026rsquo;s in the constructor as seen above. DaoManager calls Dao.createTable() and Dao.onUpgrade() once the internal SQLiteOpenHelper has been opened.\nSummary SQLBrite Dao provides an additional layer on top of SQLBrite:\n A DaoManager is representing the whole database file and basically is a SQLiteOpenHelper and manages SqlBrite instance for you. A Dao is representing a table of a database. You define a public API for other software components of your App like getMessages() or addMessage() to query and manipulate the data of the underlying table.  I have build this \u0026ldquo;DAO\u0026rdquo; and \u0026ldquo;ObjectMapper\u0026rdquo; to make things easier while working with SQLBrite by providing a little bit more high level APIs around SQLBrite. As already said SQLBrite is still under development and I think (and hope) that some of this things like \u0026ldquo;simple\u0026rdquo; object mapping or SQL grammar will be part of SQLBrite 1.0. So why do I have built this additional library? Working with Cursor and ContentValues was annoying and also writing SQL statements by using String concatenation isn\u0026rsquo;t really ahead of time. I really like SQLBrite but until now (end of June 2015) such things are not provided (yet) by SQLBrite. The annotation processor based ObjectMapper should definitely be improved to support AutoValue (I\u0026rsquo;m a big fan of AutoValue) to support real immutability.\nSQLBrite Dao can be found on Github\nTo finish the story about the fake Tinder app: As already said I haven\u0026rsquo;t made it to implement this app in time, but SQLBrite Dao was one of the out-coming artifacts. Actually, this happens quite often to me: I start a new app project and end up writing a library that would be nice to have for this already started app project. Usually, I end up with having build a library and the app itself never gets finished. However, this time I finished the app itself (the fake Tinder app) as well, unfortunately after Valentine\u0026rsquo;s Day. Therefore, I had to go the classic way for Valentine\u0026rsquo;s Day 2015 and I bought my girlfriend red roses and went to romantic dinner with her. I can\u0026rsquo;t wait for Valentine\u0026rsquo;s Day next year when I will install the fake Tinder app over night on her smartphone and wait for \u0026ldquo;having a match\u0026rdquo; on Valentine\u0026rsquo;s Day.\nP.S: Don\u0026rsquo;t worry, my girlfriend is not a computer scientist nor internet addicted (that\u0026rsquo;s why I love her). Actually, she don\u0026rsquo;t even know that I have a blog. As long as you don\u0026rsquo;t tell her directly about the fake Tinder app, it will still be a surprise on Valentine\u0026rsquo;s Day 2016. Keep your lips sealed ;-)\n","permalink":"https://hannesdorfmann.com/android/sqlbrite-dao/","tags":["android","library","database"],"title":"SQLBrite DAO"},{"categories":["Android"],"contents":"In my previous blog post I introduced Mosby, a Model-View-Presenter library for android. This time I\u0026rsquo;m going to discuss some more details about MVP in general and Mosby. I have implemented a mail client sample which can be found on Github which is used in this blog entry to describe how to use Mosby and to answer some of the common questions I have been asked after having released Mosby.\nWhile I have written the sample app I have improved Mosby as well. I\u0026rsquo;m very happy to announce that I have released Mosby 1.1.0. Like you already know (or have suggested) the name Mosby comes from one of my favorite tv shows: How I met your Mother. In this blog post I will give you some tips about MVP and Mosby in Barney Stinson\u0026rsquo;s legen \u0026hellip; wait for it \u0026hellip; dary playbook style.\nAs already mentioned I have written a sample app which mimics a mail client. It\u0026rsquo;s not a real mail client, it\u0026rsquo;s not connected to a real POP3 or IMAP Server. All the data is randomly generated on app start. There is no persistent layer like local sqlite database. The APK file can be downloaded from here. If you like me are to lazy to install the APK file on your phone then this video is for you:\n  Of course the whole app is based on Mosby and as you see in the video above everything keeps it\u0026rsquo;s state during orientation changes. Regarding the data structure: A Mail is linked to a Person as sender and another Person as receiver. Every mail is associated to exactly one Label. A Label is just something like a \u0026ldquo;folder\u0026rdquo;. A mail can be assigned to one Label. One Label has arbitrary many mails assigned. A Label is basically just a String. In this sample app there are four labels: \u0026ldquo;Inbox\u0026rdquo;, \u0026ldquo;Sent\u0026rdquo;, \u0026ldquo;Spam\u0026rdquo; and \u0026ldquo;Trash\u0026rdquo;. So deleting a mail form inbox is just reassigning the label of the mail from \u0026ldquo;Inbox\u0026rdquo; to \u0026ldquo;Trash\u0026rdquo;. MailProvider is the central business logic element where we can query list of mails and so on. Furthermore, an AccountManager exists who is responsible to authenticate a user. As you see in the video on first app start you have to sign in to see the mails. Internally for the business logic (MailProvider and AccountManager) I use RxJava. If you are not familiar with RxJava, don\u0026rsquo;t worry. All you have to know is, that RxJava offers an Observable to do some kind of query and as callback the methods onData(), onCompleted() or onError() gets called. If you are familiar with RxJava, please DON\u0026rsquo;T look at the code! It\u0026rsquo;s pretty ugly as I changed mind several times during development and didn\u0026rsquo;t refactored everything as I would do for a real app. Please note that this sample app is about Mosby and not how to write a clean business logic with RxJava. Note also that even if I have used Dagger2 for dependency injection this is not a reference app for Dagger2 nor for material design. For sure there is room for improvements and I would gladly accept pull requests for this sample app.\nAs you see in the video I\u0026rsquo;m simulating network traffic by adding a delay of two seconds to every request (like loading a list of mails). I also simulate network problems: Every fifth request will fail (that\u0026rsquo;s why you see the error view quite often in the video). Furthermore, I simulate authentication problems: After 15 requests the user has to sign in again (a login button will be dipslayed).\nThe first Tips in this blog post are related on software architecture and MVP in general while the last ones are about Mosby.\nTip 1: Don\u0026rsquo;t \u0026ldquo;over-architect\u0026rdquo; Take your time to make the right decision. A clean software architecture is necessary. However, at some point you have to start coding. Planning is important but in a real world project you always have to refactor code, even after many hours of analyzing every aspect of your app. In fact refactoring is a vital part of development, you simply can\u0026rsquo;t avoid it (but you can try to minimize the number of refactoring). Don\u0026rsquo;t fall into the Analysis Paralysis anti pattern. We java developer also tend to run into a similar \u0026ldquo;problem\u0026rdquo;: Don\u0026rsquo;t over-generalize everything. From my personal experience I think that comparing with iOS developer we android developer tend to write more clean but also over generalized code and that\u0026rsquo;s one reason why developing an android app usually takes longer then developing the same app for iOS. Don\u0026rsquo;t get me wrong I really appreciate clean code and design patterns. I can give you a concrete example from my experience: In one of our apps we use a kind of ImageProxy. The idea is simple: Given an url to a image we know that our server provides different versions of this image. Depending on the device, ImageView size, internet connection and speed the correct version for this image should be loaded. So basically we just \u0026ldquo;rewrite\u0026rdquo; the url from _http://www.example.com/foo.jpg_ to _http://www.example.com/foo.jpg?quality=high\u0026amp;width=400_. Sounds simple, doesn\u0026rsquo;t it? So I have started to implement this ImageProxy library. Internally I use Picasso for loading and caching images. However, I decided to keep it very abstract and to make components of the library modular and changeable, i.e you could replace Picasso with any other http image loading library like Glide. I also implemented the Strategy Pattern for dynamically picking the right version of the image to load and to make it more extensible. The idea was that you can add more strategy implementations preconfigured or configureable dynamically at runtime. Guess what, we have never changed the internal core for image loading (Picasso) nor have we added more strategies since we have added the ImageProxy to our app about 3 years ago (app still gets regularly major updates every month). It took me 2 days to implement this ImageProxy library, I have written 10 classes/interfaces. My coworker implementing the same thing for iOS spend about 6 hours and has written 3 classes which mainly contains some if-else statements. You may ask yourself how this tip is related to Mosby. Take it as a general advice. Start with doing the simple thing and afterwards refactor and make it more extensible as app and requirements grow. The same is valid while using Mosby. Try to keep your Presenters simple. Don\u0026rsquo;t think about too long \u0026ldquo;how could the presenter be extended if we add feature XY in one year?\u0026rdquo;.\nTip 2: Use inheritance wisely To say it from the very beginning: I\u0026rsquo;m not the biggest fan of inheritance. Why? Inheritance is good to add properties and functionality. Unfortunately I see many developers using it wrong. For instance you are working in a team on a certain app. You have written a MVP View that implements pull-to-refresh on a ListView. This is the base MVP View you use or extend from in almost every screen in your app. It\u0026rsquo;s super handy, all you have to do to implement a new screen is to subclass from that base class and to kick in a custom adapter and you are ready to go. One day one of your teammates has to implement a ListView without pull-to-refresh. So instead of writing a completely new class many developers make the wrong decision and extend from your pull-to-refresh ListView and try to find a hacky workaround to \u0026ldquo;remove\u0026rdquo; the pull-to-refresh feature. This may lead to unmaintainable code, you may see methods overridden with empty implementation and last but not least you introduce some kind of tight coupling from pull-to-refresh ListView to the new class since you can\u0026rsquo;t change the base pull-to-refresh ListView implementation without having to fear that you break the non pull-to-refresh ListView class. A better solution would be to refactor the original pull-to-refresh ListView class and pull out a ListView class without pull-to-refresh and make the pull-to-refresh ListView class extend from the non pull-to-refresh ListView class. However, if you decide to going this way you may end up having a large inheritance hierarchy, because every subclass adds a little feature like B extends A (adds feature X), C extends B (adds feature Y), D extends C (adds feature Z) and so on. You see pretty the same in the sample mail app:\n AuthFragment: an LCE (Loading-Content-Error) Fragment with an additional state to display a \u0026ldquo;not authenticated - sign in\u0026rdquo; button. AuthRefreshFragment: An extension of AuthFragment that uses SwipeRefreshLayout as main content view. So one could say: \u0026ldquo;It\u0026rsquo;s a AuthFragment with pull-to-refresh support\u0026rdquo;. AuthRefreshRecyclerFragment: Puts a RecyclerView into the SwipeRefreshLayout. BaseMailsFragment: An abstract class to displays a list of mails (List) by using the RecyclerView There are some concrete classes that extend from BaseMailsFragment like MailsFragment, SearchFragment and ProfileMailsFragment  The inheritance hierarchy might be correct, but do you really think that someone who recently joined your team would pick the right base class to implement a new feature XY? In java it\u0026rsquo;s all about interfaces and so it should be on android. I, personally, prefer interfaces and delegation over inheritance.\nTip 3: Don\u0026rsquo;t see MVP as an MVC variant Some people find it hard to understand what the Presenter exactly is if you try to explain that MVP is a variant or enhancement of MVC (Model-View-Controller). Especially iOS developer having a hard time to understand the difference of Controller and Presenter because they \u0026ldquo;grew up\u0026rdquo; with the fixed idea and definition of an iOS alike UIViewController. From my point of view MVP is not a variant or enhancement of MVC because that would mean that the Controller gets replaced by the Presenter. In my opinion MVP wraps around MVC. Take a look at your MVC powered app. Typically you have your View and a Controller (i.e. a Fragment on Android or UIViewController on iOS) which handles click events, binds data and observers ListView (or implements a UITableViewDelegate for UITableView on iOS) and so on. If you have this picture in mind now take a step back and try to imagine that the controller is part of the view and not connected directly to your model (business logic). The presenter sits in the middle between controller and model like this:\nI want to explain that with an example I already used in my previous blog post. In this example you want to display a list of users queried from a database. The action starts when the user clicks on the \u0026ldquo;load button\u0026rdquo;. While querying the database (async) a ProgressBar is displayed and a ListView with the queried items afterwards. The workflow looks like this:\nIn my opinion the Presenter does not replace the Controller. Rather the Presenter \u0026ldquo;coordinates\u0026rdquo; the View which the Controller is part of. The Controller is the component that handles the click events and calls the corresponding Presenter methods. The Controller is the responsible component to control animations like hiding ProgressBar and displaying ListView instead. The Controller is listening for scroll events on the ListView i.e. to do some parallax item animations or scroll the toolbar in and out while scrolling the ListView. So all that UI related stuff still gets controlled by a Controller and not by a Presenter (i.e. Presenter should not be a OnClickListener). The presenter is responsible to coordinate the overall state of the view layer (composed of UI widgets and Controller). So it\u0026rsquo;s the job of the presenter to tell the view layer that the loading animation should be displayed now or that the ListView should be displayed now because the data is ready to be displayed. A good example can be seen in the workflow image above: After the user has clicked on the “load user button” (step 1) the view doesn’t show the loading animation (ProgressBar) directly. It’s the presenter (step 2) who explicitly tells the view to show the loading animation.\nBy the way: Yes, I think that MVP suits quite well on iOS too!\nTip 4: Take separation of Model, View and Presenter serious That might be obvious but to achieve a clean, modular, reusable and maintainable codebase you should really look over your code and ask yourself what that line of code is doing. Is that line of code related to View (UI component or UI controller like OnClickListener) or doing presenters job (coordinating the views state) or business logic (i.e. loading data). The following (pseudo) code snipped shows a BLOB Fragment (all things in one huge class) that displays a form to sign in (similar to the mail sample login):\npublic class LoginFragment extends Fragment { @InjectView(R.id.username) EditText username; @InjectView(R.id.password) EditText password; @InjectView(R.id.loginButton) ActionProcessButton loginButton; @InjectView(R.id.errorView) TextView errorView; @InjectView(R.id.loginForm) ViewGroup loginForm; AsyncTask loginTask; AccountManager accountManager; public void onCreateView(LayoutInflater inflater, ViewGroup root, Bundle b){ return inflater.inflate(R.layout.fragment_login, root, false); } @OnClick(R.id.loginButton) public void onLoginClicked() { // Controll UI components --\u0026gt; Controllers job  errorView.setVisibility(View.GONE); loginForm.clearAnimation(); doLogin(); } private void doLogin(){ // Coordinates the state of the view --\u0026gt; Presenters job  showLoading(); loginTask = new AsyncTask(){ // returns true if login successful, otherwise false  protected boolean doInBackground(){ // Interacts with Business logic --\u0026gt; Presenters job  User user = accountManager.login(username, password); return user != null; } protected void onPostExecute(Boolean successful) { // Coordinates the state of the view --\u0026gt; Presenters job  if (successful){ loginSuccessful(); } else { showError(); } } }.execute(); } private void showError(){ // Manipulate the UI --\u0026gt; Controllers job  loginForm.clearAnimation(); Animation shake = AnimationUtils.loadAnimation(getActivity(), R.anim.shake); loginForm.startAnimation(shake); loginButton.showLoading(false); errorView.setVisibility(View.VISIBLE); } @Override public void showLoading() { errorView.setVisibility(View.GONE); loginButton.showLoading(true); } @Override public void loginSuccessful() { getActivity().finish(); } } I already have added comments with pointing out responsibilities in MVP. Lets refactor that single huge class and apply the Model-View-Presenter pattern. The Model is the AccountManager. The view should have no knowledge of the Model, so pull that out. Everything that coordinates the Views state should be moved into a Presenter. So AsyncTask is moved to the Presenter. The Presenter must be able to coordinate the view. Therefore we introduce an interface for the view LoginView where we define the methods showError(), loginSuccessful() and showLoading(). By defining an interface we keep the Presenter as platform independent as possible (Presenter has no Android SDK related code). Furthermore it makes writing unit test more easy (read more about that in my previous blog post). As we have discussed in the previous tip the Fragment is a Controller and therefore part of the View. So the fragment at the end should only contain code controlling UI components. The refactored code (with Mosby View State support) looks like this:\npublic class LoginFragment extends MvpViewStateFragment\u0026lt;LoginView, LoginPresenter\u0026gt; implements LoginView { @InjectView(R.id.username) EditText username; @InjectView(R.id.password) EditText password; @InjectView(R.id.loginButton) ActionProcessButton loginButton; @InjectView(R.id.errorView) TextView errorView; @InjectView(R.id.loginForm) ViewGroup loginForm; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setRetainInstance(true); } @Override protected int getLayoutRes() { return R.layout.fragment_login; } @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); int startDelay = getResources().getInteger(android.R.integer.config_mediumAnimTime) + 100; LayoutTransition transition = new LayoutTransition(); transition.enableTransitionType(LayoutTransition.CHANGING); transition.setStartDelay(LayoutTransition.APPEARING, startDelay); transition.setStartDelay(LayoutTransition.CHANGE_APPEARING, startDelay); loginForm.setLayoutTransition(transition); } @Override public ViewState createViewState() { return new LoginViewState(); } @Override public LoginPresenter createPresenter() { return new LoginPresenter(); } @OnClick(R.id.loginButton) public void onLoginClicked() { // Check for empty fields  String uname = username.getText().toString(); String pass = password.getText().toString(); loginForm.clearAnimation(); // Start login  presenter.doLogin(new AuthCredentials(uname, pass)); } @Override public void onNewViewStateInstance() { showLoginForm(); } @Override public void showLoginForm() { LoginViewState vs = (LoginViewState) viewState; vs.setShowLoginForm(); errorView.setVisibility(View.GONE); setFormEnabled(true); loginButton.setLoading(false); } @Override public void showError() { LoginViewState vs = (LoginViewState) viewState; vs.setShowError(); loginButton.setLoading(false); if (!isRestoringViewState()) { // Enable animations only if not restoring view state  loginForm.clearAnimation(); Animation shake = AnimationUtils.loadAnimation(getActivity(), R.anim.shake); loginForm.startAnimation(shake); } errorView.setVisibility(View.VISIBLE); } @Override public void showLoading() { LoginViewState vs = (LoginViewState) viewState; vs.setShowLoading(); errorView.setVisibility(View.GONE); setFormEnabled(false); loginButton.setLoading(true); } private void setFormEnabled(boolean enabled) { username.setEnabled(enabled); password.setEnabled(enabled); loginButton.setEnabled(enabled); } @Override public void loginSuccessful() { getActivity().finish(); } } As you can see LoginFragment now contains only code related to UI components.\nThe presenter looks like this (using RxJava instead of AsyncTask):\npublic class LoginPresenter extends MvpBasePresenter\u0026lt;LoginView\u0026gt; { private AccountManager accountManager; private Subscriber\u0026lt;Account\u0026gt; subscriber; @Inject public LoginPresenter(AccountManager accountManager) { this.accountManager = accountManager; } public void doLogin(AuthCredentials credentials) { if (isViewAttached()) { getView().showLoading(); } // Kind of \u0026#34;callback\u0026#34;  subscriber = new Subscriber\u0026lt;Account\u0026gt;() { @Override public void onCompleted() { if(isViewAttached()){ getView().loginSuccessful(); } } @Override public void onError(Throwable e) { if (isViewAttached()){ getView().showError(); } } @Override public void onNext(Account account) { } }; // do the login  accountManager.doLogin(credentials).subscribe(subscriber); } } So instead of having one huge Fragment with over 300 lines of code now we have two classes with about 100 lines of code each. Moreover, now we have reusable, maintainable code and a clear separation of responsibilities.\nTip 5: Presentation Model In a perfect world we would get the data (Model) exactly the way optimized for displaying it in our GUI (View). Quite often you retrieve data from a backend over a public API that can\u0026rsquo;t be changed to fit the needs of your UI. In fact, it\u0026rsquo;s not a good idea that the backend provides an API depending on your UI because if you change your UI you may also have to change the backend. Therefore you have to transform the model into something your GUI can display easily. A typically example is to load a list of Items, let\u0026rsquo;s say a List of Users, from a REST json API and display them in a ListView. In a perfect world with MVP this works like this:\nNothing new here. List\u0026lt;User\u0026gt; gets loaded and the GUI displays the Users in a ListView by using UserAdapter. I\u0026rsquo;m pretty sure that you have used ListView and Adapter million times before, but have you ever thought about the idea behind Adapter? Adapter makes your model displayable through android UI widgets. This is the adapter design pattern, hence the name. What if we want to support phones and tablets but both display items in a different way? We implement two adapters: PhoneUserAdapter and TabletUserAdapter and we pick the right one at runtime.\nThat is the \u0026ldquo;perfect world\u0026rdquo; scenario. What if we have to sort the user list or display some things that has to be calculated in a more complex (and CPU intensive) way? We can\u0026rsquo;t do that in the UserAdapter because you will notice scroll performance issues because the hard work is done on the main UI thread. Therefore, we do that in a separated thread. There are two questions: The first is how do we transform the data? Do we take our User class and add some additional fields to User class? Do we override values of the User class?\npublic class User { String firstname; String lastname; } Let\u0026rsquo;s assume that our UserView wants to display the full name and calculates a ranking the list get sorted accordingly:\npublic class User { String firstname; String lastname; int ranking; public String getFullname(){ return firstname +\u0026#34; \u0026#34;+lastname; } } While introducing a method getFullname() is ok adding a field ranking may cause problems, because we assume that User is retrieved from backend and has no ranking in it\u0026rsquo;s json representation. So first it may cause confusion if you look at your json api feed and compare that to our User class and last but not least ranking will be zero as default value because we haven\u0026rsquo;t computed the ranking yet. If we would have used an object instead of an integer then the default value would be null and it\u0026rsquo;s likely that we run into NullPointerException.\nThe solution is to introduce a Presentation Model. This model is just a class optimized for our GUI:\npublic class UserPresentationModel { String fullname; int ranking; public UserPresentationModel(String fullname, int ranking) { ... } } By doing so we are sure that ranking is always set to a concrete value and that fullname doesn\u0026rsquo;t get computed while scrolling the ListView (PresentationModel gets instantiated in separated thread). UserView now displays List\u0026lt;UserPresentationModel\u0026gt; instead of List\u0026lt;User\u0026gt;.\nThe second question is: Where to do that async transformation? View, Model or Presenter? It would be obvious that the View does that transformation because the View knows best how things get displayed on screen.\nPresentationModelTransformer is the component that takes a List\u0026lt;User\u0026gt; and \u0026ldquo;transforms\u0026rdquo; that to List\u0026lt;UserPresentationModel\u0026gt; (adapter pattern, so we have two adapters: one to convert to presentation model and UserAdapter to display them in ListView). The advantage on integrating PresentationModelTransformer in the view is that the view knows how to display things and could easily internally change between phone and tablet optimized presentation models (maybe the tablet UI has other requirements then the phone UI). However, the big disadvantage is that now the view has to control the async thread and the view state (displaying ProgressBar while transformation is in progress?!?) which clearly is the job of the Presenter. Therefore, it\u0026rsquo;s not a good idea to let the transformation be part of the View. Including the transformation in the Presenter is the way to go:\nAs we have already discussed before, the Presenter is responsible to coordinate the View and therefore the Presenter tells the view to display the ListView after UserPresentationModel transformation is finished. Also the presenter has control of all async threads (transformation runs async) and cancels them if needed. By the way: With RxJava you can use operations like map() or flatMap() to do this transformation painless (regarding threading). If we want to support phones and tablets we could define two Presenters PhoneUserPresenter and TabletUserPresenter with different PresentationModelTransformer implementations. In Mosby the View creates the Presenter. Since the View knows at runtime if the View is a phone or tablet it can choose at runtime Presenter to instantiate (PhoneUserPresenter or TabletUserPresenter). Alternatively you could use a single UserPresenter for phone and tablet and just replace PresentationModelTransformer implementation i.e. by using dependency injection.\nTip 6: Navigation is a UI thing In other MVP libraries or platforms like single page html sites (javascript) it\u0026rsquo;s the presenter who gets instantiated as first component and the Presenter creates the View. In that case it makes sense to navigate from Presenter to Presenter. However, this is not the case on Android (or at least not if you use Mosby) since the Android Framework defines Activity as entry point and Activity is seen as part of the View layer. So it doesn\u0026rsquo;t make sense to let the Presenter start the Intent for launching a new Activity.\nTip 7: onActivityResult() and MVP There are situations where you have to use onActivityResult() for instance if you want to communicate with other apps like the camera app. Should you forward the result to the Presenter? It depends: If you just want to display the photo as it is in an ImageView then there is no need to forward that to the Presenter. Remember, the presenter is responsible to coordinate the state. So displaying just that Image in a ImageView most of the time doesn\u0026rsquo;t change the state and can be done directly.\n@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (requestCode == REQUEST_IMAGE_CAPTURE \u0026amp;\u0026amp; resultCode == RESULT_OK) { Bundle extras = data.getExtras(); Bitmap imageBitmap = (Bitmap) extras.get(\u0026#34;data\u0026#34;); imageView.setImageBitmap(imageBitmap); } } If you have to do some additional image processing then you would do that async. In that case you should use the presenter and let the presenter control the view (like showing a loading view while processing image) like this:\n@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (requestCode == REQUEST_IMAGE_CAPTURE \u0026amp;\u0026amp; resultCode == RESULT_OK) { Bundle extras = data.getExtras(); Bitmap imageBitmap = (Bitmap) extras.get(\u0026#34;data\u0026#34;); presenter.makeThumbnail(imageBitmap); } } Tip 8: MVP and EventBus An EventBus allows you to communicate between decoupled components by posting and receiving events. I assume that you are already familiar with the concept of an EventBus. EventBus is not MVP related but it fits to MVP like a hand in a glove. I came in touch with EventBus and MVP for the first time while developing something with GWT in late 2009 and it was mind blowing. From now on I always used MVP with EventBus, so I do on android. With RxJava some things done by an EventBus can be replaced with RxJava\u0026rsquo;s observer \u0026ldquo;push updates mechanism\u0026rdquo; (have a look at SqlBrite for a concrete use case). The difference between RxJava\u0026rsquo;s push mechanism and EventBus is that in RxJava you explicitly have to subscribe on an concrete observable whereas an EventBus is a little bit more loosely coupled since you just have to know the event you are listening for. So when I\u0026rsquo;m talking here about an EventBus you can think of every other push based update mechanism as well (like RxJava).\nI see two use cases for EventBus:\n EventBus for business logic events: The Events related to the business logic are posted to the EventBus. As we have discussed previously the View shouldn\u0026rsquo;t have any knowledge of the business logic. Therefore, the presenter is the component that listens for business logic events through the EventBus. In Mosby you should register and unregister the presenter from EventBus in attachView() and detachView() respectively. Why not registering in the constructor of the Presenter? Because if you have retaining Views (like retaining Fragment) the Presenter gets created only once, but the View can be attached and detached from the Presenter multiple times during orientation changes. In the mail sample I use EventBus quite a lot. The first thing you may have noticed in the video is that after the login was successful all views automatically begin to load data. You can see this even better if you start the mail app on a tablet.    That is not implemented by automatically do a refresh in Activity.onResume(). The LoginPresenter fires a LoginSuccessfulEvent to inform all other presenters that the user has been logged in successfully. The Presenters will then trigger a reload and update their Views.\n EventBus for UI Events: Another use case is to use the EventBus in your UI or to communicate between Fragments and Activities. The official docs recommandation to implement communication between fragments and the host activity is to define a listener interface and cast the Activity in fragments onAttach() method to the listener:  @Override public void onAttach(Activity activity) { super.onAttach(activity); // This makes sure that the container activity has implemented  // the callback interface. If not, it throws an exception  try { mCallback = (OnHeadlineSelectedListener) activity; } catch (ClassCastException e) { throw new ClassCastException(activity.toString() + \u0026#34; must implement OnHeadlineSelectedListener\u0026#34;); } } I don\u0026rsquo;t like that (casting an object to an interface). Every other java developer, i.e. in the J2EE world, would throw his hands up in horror if he sees something like this in his code. So why should it be the recommended way (btw. on iOS you are doing pretty the same)? I usually use an EventBus for doing that. The fragment fires an Event on the EventBus and the parent Activity is subscribed for that Event on the EventBus. The advantage of an EventBus is even bigger, if you have a split-pane layout displaying Fragment A on the left and Fragment B on the right. If Fragment A wants to communicate with Fragment B the docs recommend that Fragment A should talk to the parent Activity and then the Activity forwards the information to Fragment B. With an EventBus Fragment A can fire an Event and Fragment B, who is registered for that Event on the EventBus, gets notified immediately without having the Activity as middle man. In that way all 3 components (Activity, Fragment A and Fragment B) are decoupled (no one has a reference to each other).\nA common use case where EventBus is useful is when implementing navigation drawer. If you click on a menu item the Activity should replace the current main fragment with a fragment associated with the clicked menu item. It turns out that Android itself already offers an EventBus you already use: Intents. Instead of using an external EventBus you could use Intent like I did in the mail sample. I set MainActivity to android:launchMode=\u0026quot;singleTop\u0026rdquo; and check in onNewIntent() for the navigation events. The advantage with Intents is that this kind of Navigation can be used system wide (and not only app wide like EventBus). For instance when a new Mail is received a Notification will be shown in the StatusBar. Clicking on the Notification opens the Mail. There could be a Button in the Notification that opens the Inbox by clicking on it. Moreover, if you use an EventBus for navigation in your app then you might face the problem that you have to deal with Intents and with Events from EventBus to navigate in your app. You should think about that scenario and only use EventBus for navigation if your app can not run into this kind of problem.\nTip 9: Optimistic propagation Let\u0026rsquo;s have a look at the mail app. When you star or unstar a Mail the star icon changes immediately. However, saving that a mail has changed takes two seconds and can fail. For a better user experience we assume that changing the stared mail will be successful. It gives the user of your app an immediately feedback and the feeling that your app works lightning fast.\n  At first glance you may think that this is too complex to implement for your simple app you are currently working on. It seems that you have to respect so many things for implementing that. Don\u0026rsquo;t worry, with a clean architecture like MVP and an EventBus it\u0026rsquo;s quite easy:\npublic class BaseRxMailPresenter\u0026lt;V extends BaseMailView\u0026lt;M\u0026gt;, M\u0026gt; extends BaseRxAuthPresenter\u0026lt;V, M\u0026gt; { @Inject public BaseRxMailPresenter(MailProvider mailProvider, EventBus eventBus) { super(mailProvider, eventBus); } public void starMail(final Mail mail, final boolean star) { // optimistic propagation  if (star) { eventBus.post(new MailStaredEvent(mail.getId())); } else { eventBus.post(new MailUnstaredEvent(mail.getId())); } mailProvider.starMail(mail.getId(), star) .subscribe(new Subscriber\u0026lt;Mail\u0026gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { // Oops, something went wrong, \u0026#34;undo\u0026#34;  if (star) { eventBus.post(new MailUnstaredEvent(mail.getId())); } else { eventBus.post(new MailStaredEvent(mail.getId())); } if (isViewAttached()) { if (star) { getView().showStaringFailed(mail); } else { getView().showUnstaringFailed(mail); } } } @Override public void onNext(Mail mail) { } }); // Note: that we don\u0026#39;t cancel this operation in detachView().  // We want to ensure that this operation finishes  } ... } If we star a Mail we fire MailStaredEvent and if we unstar a mail we fire a MailUnstaredEvent. As you seen in the video by staring a mail the left pane displaying the list of mails gets updated as well since the presenter is registered on those events. The trick is that we fire the corresponding event before we make the corresponding business logic call and we use the counterpart event to \u0026ldquo;undo\u0026rdquo; it in case that that the business logic call fails. Managing that logic in the Presenter is quite easy as you have seen in the code snipped above. But we also have to update the view. In MVP we have this clear separation between View and business logic, therefore the Presenter is responsible to update the view by calling the corresponding method defined in the view\u0026rsquo;s interface. As you see with a clean MVP architecture and EventBus doing such \u0026ldquo;complex\u0026rdquo; things is extremely easy. Presenter is doing the business logic staff and then the code in your View implementation is just a one-liner. However, if you would do that all in your Fragment (without MVP) then yes, it might be a little bit more complicated to maintain the correct state.\nPlease note that we are not canceling this business logic call in presenter.detachView() because we want to ensure that this call finishes. You may ask yourself now if that doesn\u0026rsquo;t result in memory leaks during orientation changes. The answer is \u0026ldquo;it depends on the definition of memory leak\u0026rdquo;. View gets detached from presenter during screen orientation changes. So the huge memory consuming view objects like Activity or Fragment don\u0026rsquo;t leak memory. However, the Presenter creates a new anonymous Subscriber object. Every anonymous object has a hard reference to the surrounding object. So yes, the Presenter can\u0026rsquo;t be garbage collected as long as Subscriber gets unsubsribed (business logic call has finished). But I wouldn\u0026rsquo;t call this a memory leak. It\u0026rsquo;s kind of a temporarily and wanted memory leak and from my point of view completely fine since presenter is a lightweight object and you know that the presenter can be garbage collected after the business call has finished.\nAnother sample where optimistic propagation improves the user experience of your app is when moving a mail from \u0026ldquo;Inbox\u0026rdquo; to \u0026ldquo;Spam\u0026rdquo;:\n  Tip 10: MVP scales Most of the time you have one View (and Presenter) filling the whole screen. But that doesn\u0026rsquo;t has to be the case. Typically Fragments are a good candidate for splitting your screen into modular decoupled Views with his own Presenter. The sample mail client implements this as well when you open a profile by clicking on the senders image (avatar):\n  In that sample from the mail app shown in the video above the activity itself is a View having a ViewPager as content view. The Presenter loads a List of ProfileScreen. A ProfileScreen is just a POJO.\npublic class ProfileScreen implements Parcelable { public static final int TYPE_MAILS = 0; public static final int TYPE_ABOUT = 1; int type; String name; private ProfileScreen() { } public ProfileScreen(int type, String name) { this.type = type; this.name = name; } public int getType() { return type; } public String getName() { return name; } } public class ProfileScreensAdapter extends FragmentPagerAdapter { @Override public Fragment getItem(int position) { ProfileScreen screen = screens.get(position); if (screen.getType() == ProfileScreen.TYPE_MAILS) { return new ProfileMailsFragmentBuilder(person).build(); } if (screen.getType() == ProfileScreen.TYPE_ABOUT) { return new AboutFragmentBuilder(person).build(); } throw new RuntimeException(\u0026#34;Unknown Profile Screen (no fragment associated with this type\u0026#34;); } @Override public CharSequence getPageTitle(int position) { return screens.get(position).getName(); } } Loading List of ProfileScreen takes 2 seconds (simulates loading the \u0026ldquo;screens displayed as tabs\u0026rdquo; for the ViewPager dynamically from a backend). So basically we have a LCE (Loading-Content-Error) and therfore we can use Mosby\u0026rsquo;s MvpLceViewStateActivity. Next every Fragment in the ViewPager is a MVP View and has it\u0026rsquo;s own presenter. I guess you get the overall picture: A MVP View can contain indipendent MVP Views.\nTip 11: Not every View needs MVP This might be obvious but once you are in the \u0026rdquo; I\u0026rsquo;m a super software architect \u0026ldquo; mode you may forget that there are Views that just display static content. Static content does not need MVP.\nTip 12: Only display one Model per MVP view Mosby assumes that every MVP view displays exactly one model (note that displaying a list of items is still displaying one model, the list). Why? Because dealing with different models in the same view increases complexity dramatically and we clearly want to avoid spaghetti code. In the sample app I faced that problem in the menu. I haven\u0026rsquo;t refactored that yet to give you the possibility to understand the problem with a concrete code sample. Have a look at the screenshot of the menu:\nThe header displays the current authenticated user, represented as Account, while the clickable menu items are a List\u0026lt;Label\u0026gt; (just ignore statistics). So we have two Models displayed in the same MVP View namely MenuFragment. The problem is that it makes your code more complex and harder to maintain if you work with two Models in the same View. Things get even more complex if you decide to use Mosby\u0026rsquo;s ViewState. Because, now you not only have to store the state showing labels, loading labels and error while loading labels, but you also have to store whether the user is authenticate or not.\nThe solution to this problem is to split the one big MVP View into two views with its own Presenter and own ViewState:\nTip 13: Android Services Android Services are a fundamental part of android app development. Services are clearly \u0026ldquo;business logic\u0026rdquo;. Therefore it\u0026rsquo;s obvious that the Presenter is responsible to communicate with the Service. In the mail app I have used an IntentService to send mails. This SendMailService is connected over EventBus to the WritePresenter:\npublic class WritePresenter extends MvpBasePresenter\u0026lt;WriteView\u0026gt; { private EventBus eventBus; private IntentStarter intentStarter; public void writeMail(Context context, Mail mail) { getView().showLoading(); intentStarter.sendMailViaService(context, mail); } public void onEventMainThread(MailSentErrorEvent errorEvent){ if (isViewAttached()){ getView().showError(errorEvent.getException()); } } public void onEventMainThread(MailSentEvent event){ if (isViewAttached()){ getView().finishBecauseSuccessful(); } } } Tip 14: Use LCE only if you have LCE Views LCE stands for Loading-Content-Error. Mosby ships with MvpLceViewStateFragment implements MvpLceView which displays either the content (like a list of mails) or loading (like a progressbar) or an error view (like a TextView displaying an error message). This might be handy, because you don\u0026rsquo;t have to implement the switching of displaying content, displaying error, displaying loading by your own, but you shouldn\u0026rsquo;t use it as base class for everything. Only use it if your view can reach all three view states (showing loading, content and error). Have a look at the sign in view:\npublic interface LoginView extends MvpView { // Shows the login form  public void showLoginForm(); // Called if username / password is incorrect  public void showError(); // Shows a loading animation while checking auth credentials  public void showLoading(); // Called if sign in was successful. Finishes the activity. User is authenticated afterwards.  public void loginSuccessful(); } At first glance you might assume that LoginView is a MvpLceView with just having showContent() renamed to showLoginForm(). Have a closer look at MvpLceView definition:\npublic interface MvpLceView\u0026lt;M\u0026gt; extends MvpView { public void showLoading(boolean pullToRefresh); public void showContent(); public void showError(Throwable e, boolean pullToRefresh); public void setData(M data); public void loadData(boolean pullToRefresh); } Methods like loadData() and setData() are not needed in LoginView nor make it sense to have pull-to-refresh support. You could simply implement that methods with an empty implementation. But that is a bad idea, because defining an interface is like making a contract with other software components: Your interface promises that the method is \u0026ldquo;callable\u0026rdquo; (in the sense of does something useful), but doing nothing on invoking this method is a violation of that contract. Also your code gets harder to understand and maintain if you have plenty of methods that get called from some other components but are doing nothing. Furthermore, if you use MvpLceView ususally you are going to use an already existing MvpLcePresenter implementation as base class for LoginPresenter. The problem is that MvpLcePresenter is \u0026ldquo;optimized\u0026rdquo; for MvpLceView. So you may have to implement some workarounds in your Presenter which extends from MvpLcePresenter to achieve what you want to do. Simply avoid that by not using LCE related classes if your view doesn\u0026rsquo;t have full LCE support.\nTip 15: Writing custom ViewStates Mosby has a mechanism to save and restore the views state which is useful to handle orientation changes. Some ViewState implementations for MvpLceView are already provided by Mosby. However LoginView is not an MvpLceView (discussed in previous tip) and therefore needs its own view state implementation. Writing a custom view state is easy:\npublic class LoginViewState implements ViewState\u0026lt;LoginView\u0026gt; { final int STATE_SHOW_LOGIN_FORM = 0; final int STATE_SHOW_LOADING = 1; final int STATE_SHOW_ERROR = 2; int state = STATE_SHOW_LOGIN_FORM; public void setShowLoginForm() { state = STATE_SHOW_LOGIN_FORM; } public void setShowError() { state = STATE_SHOW_ERROR; } public void setShowLoading() { state = STATE_SHOW_LOADING; } /** * Is called from Mosby to apply the view state to the view. * We do that by calling the methods from the View interface (like the presenter does) */ @Override public void apply(LoginView view, boolean retained) { switch (state) { case STATE_SHOW_LOADING: view.showLoading(); break; case STATE_SHOW_ERROR: view.showError(); break; case STATE_SHOW_LOGIN_FORM: view.showLoginForm(); break; } } } We simply store the current view state internally as an integer state. The method apply() gets called from Mosby internally and this is the point where we restore the view state to the associated view. You may wonder how the ViewState is connected to your Fragment or Activity. MvpViewStateFragment has a method createViewState() called by Mosby internally, which you have to implement. You just have to return a LoginViewState instance. However, you have to set the LoginViewState\u0026rsquo;s\u0026rsquo; internal state by hand. Typically you do that in the methods defined by LoginView interface as shown below:\npublic class LoginFragment extends MvpViewStateFragment\u0026lt;LoginView, LoginPresenter\u0026gt; implements LoginView { @Override public void showLoginForm() { // Set View state  LoginViewState vs = (LoginViewState) viewState; vs.setShowLoginForm(); errorView.setVisibility(View.GONE); ... } @Override public void showError() { // Set the view state  LoginViewState vs = (LoginViewState) viewState; vs.setShowError(); if (!isRestoringViewState()) { // Enable animations only if not restoring view state  loginForm.clearAnimation(); Animation shake = AnimationUtils.loadAnimation(getActivity(), R.anim.shake); loginForm.startAnimation(shake); } errorView.setVisibility(View.VISIBLE); ... } @Override public void showLoading() { // Set the view state  LoginViewState vs = (LoginViewState) viewState; vs.setShowLoading(); errorView.setVisibility(View.GONE); ... } } Sometimes you have to know if the method gets called from presenter or because of restoring view state, typically when working with animations. You can check that with isRestoringViewState() like showError() does (see above).\nTip 16: Testing custom ViewState Since LoginView and LoginViewState are plain old java classes with no dependencies to the android framework, you can simply write plain old java unit test for LoginViewState:\n@Test public void testShowLoginForm(){ final AtomicBoolean loginCalled = new AtomicBoolean(false); LoginView view = new LoginView() { @Override public void showLoginForm() { loginCalled.set(true); } @Override public void showError() { Assert.fail(\u0026#34;showError() instead of showLoginForm()\u0026#34;); } @Override public void showLoading() { Assert.fail(\u0026#34;showLoading() instead of showLoginForm()\u0026#34;); } @Override public void loginSuccessful() { Assert.fail(\u0026#34;loginSuccessful() instead of showLoginForm()\u0026#34;); } }; LoginViewState viewState = new LoginViewState(); viewState.setShowLoginForm(); viewState.apply(view, false); Assert.assertTrue(loginCalled.get()); } The idea is simple: We create a LoginViewState and set the internal state viewState.setShowLoginForm(). Next we create a mock view and call the apply() method on the view state. Then we check if the expected method has been called. You could also mock the LoginView with mocking libraries like Mockito, but I wanted to keep the sample simple and independent from other third party libraries.\nTo test if LoginFragment implements LoginView restores it\u0026rsquo;s state correctly during screen orientation changes it\u0026rsquo;s enough to test the ViewState because you can assume that Mosby\u0026rsquo;s internals are working correct.\nSo far we only have tested if restoring works correctly. We also have to test if we are setting the view state correctly. However, that is done in LoginFragment, so we have to test the Fragment rather than the LoginViewState. Thanks to Robolectric this is also straightforward:\n@Test public void testSettingState(){ LoginFragment fragment = new LoginFragment(); FragmentTestUtil.startFragment(fragment); fragment.showLoginForm(); LoginViewState vs = (LoginViewState) fragment.getViewState(); Assert.assertEquals(vs.state, vs.STATE_SHOW_LOGIN_FORM); } We simply call showLoginForm() and we check if the ViewState is STATE_SHOW_LOGIN_FORM after this call.\nYou could also test if LoginFragment handles screen orientation changes correctly by writing instrumentation test (i.e. with espresso), but the point is that in Mosby you have this clear separation between view and view state. Hence, you can test the view state independently, which usually requires less testing code to be written (compare the code above with an instrumentation test).\nTip 17: ViewState variants Maybe it is still not clear what ViewState exactly is. Probably it\u0026rsquo;s easier to explain the ViewState concept with an example: For instance showing a loading view (ProgressBar) instead of the content view (ListView displaying items). That are clearly two different view states: the view should display either loading view or content view. But what if we add pull-to-refresh support to the content view (SwipeRefreshLayout around ListView). If the user triggers a pull-to-refresh action we show the ListView (content view) and a loading indicator at the same time. The question is: Which state is that? The view always is in exactly one state (that\u0026rsquo;s the definition of view state). So during pull-to-refresh the view\u0026rsquo;s state is not in \u0026ldquo;showing content\u0026rdquo; and \u0026ldquo;showing loading\u0026rdquo; at the same time. Internally the view is still in exactly one state. There are two possibilities:\n Introduce a new state for pull-to-refresh (displaying ListView and ProgressBar at the same time). Extending \u0026ldquo;show loading view state\u0026rdquo;: Additionally we store the information that a pull-to-refresh was triggered (i.e. a boolean flag) and that the ListView should be displayed as well. Using an existing ViewState and extending that one with additional info (i.e. a boolean flag for pull-to-refresh) is called a Variant of ViewState. We extend the \u0026ldquo;show loading view state\u0026rdquo; by adding the boolean pull-to-refresh flag which results in having two variants of the \u0026ldquo;show loading view state\u0026rdquo;. The first variant is where pull-to-refresh flag is true (view should display ListView and pull-to-refresh indicator) and the second variant is where pull-to-refresh flag is false (view should display a ProgressBar only).  It doesn\u0026rsquo;t make any difference which one of this two options you use, it\u0026rsquo;s just an internal implementation detail. The point with ViewState is that there is exactly one view state the view is in. However, one view state can have few variants. Having variants may require multiple information to be stored and multiple view methods to be invoked to restore this view state variant. Mosby\u0026rsquo;s default MvpLceViewState implementation uses approach number 2 which looks like this:\nprivate boolean pullToRefresh; @Override public void apply(V view, boolean retained) { if (currentViewState == STATE_SHOW_LOADING) { if (pullToRefresh) { view.setData(loadedData); view.showContent(); } // view displays pull-to-refresh indicator if pullToRefresh == true,  // otherwise hides content view or error view and displays big ProgressBar instead  view.showLoading(pullToRefresh); } ... } However, I recommend to not having more than two variants of a ViewState and only prefer variants over defining a new view state if a variant is simple and doesn\u0026rsquo;t require complex restoring (in apply()).\nAlright, now you should have an idea what the difference between a view state (i.e. show loading) and a view state variant (i.e. show loading with pull-to-refresh) is.\nLet\u0026rsquo;s have a look at the mail sample app. Here we can find some custom view states that extend from already existing ones. AuthParcelableDataViewState for instance is an extension of LceViewState and has four states:\nAdding an additional state is quite easy. Internally LceViewstate (from which AuthParcelableDataViewState inherits) has a field int state that is used for saving the current state. We simply reuse that field to add a new state for the case the user is not authenticated as shown below:\npublic class AuthParcelableDataViewState\u0026lt;D extends Parcelable, V extends AuthView\u0026lt;D\u0026gt;\u0026gt; extends ParcelableDataLceViewState\u0026lt;D, V\u0026gt; implements AuthViewState\u0026lt;D, V\u0026gt; { public static final int SHOWING_AUTHENTICATION_REQUIRED = 2; @Override public void apply(V view, boolean retained) { if (currentViewState == SHOWING_AUTHENTICATION_REQUIRED) { view.showAuthenticationRequired(); } else { // call super to handle the states showing loading or error or content  super.apply(view, retained); } } @Override public void setShowingAuthenticationRequired() { currentViewState = SHOWING_AUTHENTICATION_REQUIRED; // Delete any previous stored data of other view states  loadedData = null; exception = null; } } The code should be self explaining. An example of how to implement ViewState with Variants can be found in SearchFragment implements SerachView, where I have implemented pagination (displaying a list of mails by loading the whole list in chunks, i.e. display 20 mails and if the user has scrolled to the end of the list then load the next 20 mails). Basically SearchView displays a list of mails, loading and displaying an error view. Therefore we can use a LCE based view state implementation. The question is which ViewState to use to add a Variant to it: \u0026ldquo;show loading\u0026rdquo; or \u0026ldquo;show content\u0026rdquo;? In that case it depends a little bit on your implementation. What I did to display \u0026ldquo;loading more\u0026rdquo; is I added an additional ViewType to SearchResultAdapter which displays the list of mails matching the search criteria in a RecyclerView (content view). So the last item the RecyclerView displays is a row displaying a ProgressBar. Since triggering a \u0026ldquo;load more action\u0026rdquo; requires to scroll the content view (RecyclerView) it feels more natural to me to add the view state variant to \u0026ldquo;showing content\u0026rdquo; instead of \u0026ldquo;showing loading\u0026rdquo;. Also is the \u0026ldquo;load more indicator\u0026rdquo; part of the RecyclerViews (content view) adapter. To implement a Variant of \u0026ldquo;showing content\u0026rdquo; we simply add a boolean flag loadingMore as you can see in SearchViewState:\n// AuthCastedArrayListViewState is a LCE ViewState with an additional \u0026#34;not authenticated\u0026#34; state public class SearchViewState extends AuthCastedArrayListViewState\u0026lt;List\u0026lt;Mail\u0026gt;, SearchView\u0026gt; { boolean loadingMore = false; public void setLoadingMore(boolean loadingMore) { this.loadingMore = loadingMore; } @Override public void apply(SearchView view, boolean retained) { super.apply(view, retained); if (currentViewState == STATE_SHOW_CONTENT) { view.showLoadMore(loadingMore); } } } If you don\u0026rsquo;t feel comfortable with ViewState Variants then simply don\u0026rsquo;t use Variants. Rather define new ViewStates instead. Defining new view states is cleaner, however may requires to write a little bit more code. As I\u0026rsquo;m a lazy guy I wanted to point out that variants can be used too. However, Variants are not a solution for everything and for everybody.\nTip 18: Not every UI representation is a ViewState What if you open the inbox which is empty. Then the sample mail app desplays that:\nIs that another view state? No, it\u0026rsquo;s just the view state \u0026ldquo;showing Content\u0026rdquo; with an empty List as data. In MailsFragment an empty list gets displayed like that. The UI is allowed to represent the same view state in different ways.\nTip 19: Not every View needs a ViewState I\u0026rsquo;m sure that you find Mosby\u0026rsquo;s concept of ViewState as one of the most comfortable features Mosby offers. Handling orientation changes works like a charm out of the box. However, that comes with a price you have to pay. The ViewState is stored into the Bundle used in onSaveInstanceState(). This bundle is limited in size to about 1 MB. If your View displays a huge list of items then you might run over the limit of 1 MB since the list of items is stored in the Bundle as well (as part of ViewState). If you use retaining Fragment you don\u0026rsquo;t run into this kind of problem because the view state is stored in memory and not in the Bundle. Another thing you have to keep in mind is that an Activity can be destroyed by the Android OS and recreated if you navigate back to the Activity. When coming back the ViewState gets restored and the Activity may display old, stale data, because the same data has been edited in another Activity of your app in the meantime. Usually this doesn\u0026rsquo;t happen very often. However, if you display sensitive data you should keep that in mind and in that case it may be better not to use ViewState.\nTip 20: Avoid Fragments on the backstack and child fragments I\u0026rsquo;m sure all of you have heard about how bad Fragment\u0026rsquo;s lifecycle is and that it is hard to work with that kind of lifecycle. Unfortunately many arguments against Fragments are correct and the lifecycle of Fragments gets even more strange if you put Fragments on the backstack or use child Fragments (Fragments in Fragments). Mosby can deal with them though. But in general it\u0026rsquo;s a good idea to avoid problems from the very beginning if you know that there may be trouble. You know that putting Fragments on the backstack may cause problems, then simply avoid putting Fragments on the backstack. Same is valid for child Fragments.\nTip 21: Mosby supports MVP for ViewGroups If you want to avoid Fragments in general you can do that. Mosby offers the same MVP scaffold as for Activities and Fragments for ViewGroups, inclusive ViewState support. The API is the same as for Activity and Fragment. Some default implementation are already available like MvpViewStateFrameLayout, MvpViewStateLinearLayout and MvpViewStateRelativeLayout. This ViewGroup implementation are also useful if you want to have subviews in a fragment (since you should avoid child fragment). The mail sample uses that when you want to reassign the label of a mail:\n  This \u0026ldquo;Button\u0026rdquo; for assigning a Label is a MvpViewStateLinearLayout. It animates the ProgressBar (loadingView) in and out while loading, uses a ListPopupWindow (contentView) to display the list of labels and uses a Toast to inform about errors. By the way: there is no LCE default implementation for ViewGroups (how would you implement that for LinearLayout?).\nTip 22: Mosby provides Delegates You may be wondering how Mosby can provide the same API for all kind of Views (Activity, Fragment and ViewGroup) without having code clones (copy \u0026amp; paste the same code). The answer is delegation. Mosby uses delegation since the very beginning (version 1.0.0). However, this delegation classes were a little bit hidden and hard to understand that they actually are Delegates that can be used and are part of the public API, namely ViewStateSupport and ViewStateManager. To make it easier for developers to use them, this delegate classes has been renamed in Mosby 1.1.0. The methods of the delegates also has been renamed to match the Activities or Fragments lifecycle method names (inspired by the latest AppCompatDelegate from android support library) for better understanding which delegate method should be called from which Activity or Fragment lifecycle method:\n MvpDelegateCallback: Is an interface every MvpView in Mosby has to implement. Basically it just provides some MVP related methods like createPresenter() etc. This methods are internally called by ActivityMvpDelegate or FragmentMvpDelegate. ActivityMvpDelegate: It\u0026rsquo;s an interface. Usually you use ActivityMvpDelegateImpl which is the default implementation. All you have to do to bring Mosby MVP support to your custom Activity is to call the corresponding delegate method from Activities lifecycle method like onCreate(), onPause(), onDestroy() etc. and to implement MvpDelegateCallback:  public abstract class MyActivity extends Activity implements MvpDelegateCallback\u0026lt;\u0026gt; { protected ActivityMvpDelegate mvpDelegate = new ActivityMvpDelegateImpl(this); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mvpDelegate.onCreate(savedInstanceState); } @Override protected void onDestroy() { super.onDestroy(); mvpDelegate.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mvpDelegate.onSaveInstanceState(outState); } ... // other lifecycle methods  }  FragmentMvpDelegate: Same as ActivityMvpDelegate but for Fragments. To bring Mosby MVP support to your custom Fragment all you have to do is the same as shown above for Activities: Create a FragmentMvpDelegate and call the methods from the corresponding Fragment lifecycle method. Your Fragment has to implement MvpDelegateCallback as well. Usually you use the default delegate implementation FragmentMvpDelegateImpl ViewGroupMvpDelegate: This delegate is used for ViewGroup like FrameLayout etc. to bring Mosby MVP support to your custom ViewGroup. The lifecycle methods are simpler compared to Fragments ones: onAttachedToWindow() and onDetachedFromWindow(). The default implementation is ViewGroupMvpDelegateImpl.  Alright so far we have covered how to bring Mosby MVP support to your custom Activity, Fragment or ViewGroup. For supporting ViewState you have to use the following delegates instead of the delegates discussed above (ViewState delegates already include functionality of MVP delegates):\n MvpViewStateDelegateCallback: This interface extends from MvpDelegateCallback and defines the method you have to implement like createViewState(). ActivityMvpViewStateDelegateImpl: This delegate is an extension of ActivityMvpDelegateImpl and works exactly the same way as shown in the previous code snippet: you have to call the delegates method from the corresponding activity lifecycle method. Like shown above your custom activity has to implement MvpViewStateDelegateCallback and use a ActivityMvpViewStateDelegateImpl instead of the non ViewState related ones:  public abstract class MyViewStateActivity extends Activity implements MvpViewStateDelegateCallback\u0026lt;\u0026gt; { protected ActivityMvpDelegate mvpDelegate = new ActivityMvpViewStateDelegateImpl(this); // The rest is still the same as shown above without ViewState support  @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mvpDelegate.onCreate(savedInstanceState); } @Override protected void onDestroy() { super.onDestroy(); mvpDelegate.onDestroy(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); mvpDelegate.onSaveInstanceState(outState); } ... // other lifecycle methods  }  FragmentMvpViewStateDelegateImpl: Extension from FragmentMvpDelegateImpl to add ViewState support. ViewGroupMvpViewStateDelegateImpl: The delegate for ViewGroups like FrameLayout to add ViewState support.  The advantage of delegation is that you can add Mosby MVP and ViewState support to any other Activity, Fragment or ViewGroup not included in the Mosby library like DialogFragment. In the main menu of the mail example you see the \u0026ldquo;statistics\u0026rdquo; menu item. If you click on it a DialogFragment get\u0026rsquo;s displayed. This is implemented like this:\npublic class StatisticsDialog extends DialogFragment implements StatisticsView, MvpViewStateDelegateCallback\u0026lt;StatisticsView, StatisticsPresenter\u0026gt; { @InjectView(R.id.contentView) RecyclerView contentView; @InjectView(R.id.loadingView) View loadingView; @InjectView(R.id.errorView) TextView errorView; @InjectView(R.id.authView) View authView; StatisticsPresenter presenter; ViewState\u0026lt;StatisticsView\u0026gt; viewState; MailStatistics data; StatisticsAdapter adapter; // Delegate  private FragmentMvpDelegate\u0026lt;StatisticsView, StatisticsPresenter\u0026gt; delegate = new FragmentMvpViewStateDelegateImpl\u0026lt;\u0026gt;(this); @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); delegate.onCreate(savedInstanceState); } @Override public void onDestroy() { super.onDestroy(); delegate.onDestroy(); } @Override public void onPause() { super.onPause(); delegate.onPause(); } @Override public void onResume() { super.onResume(); delegate.onResume(); } @Nullable @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { return inflater.inflate(R.layout.fragment_statistics, container, false); } @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); delegate.onViewCreated(view, savedInstanceState); ButterKnife.inject(this, view); adapter = new StatisticsAdapter(getActivity()); contentView.setAdapter(adapter); contentView.setLayoutManager(new LinearLayoutManager(getActivity())); } @Override public void onStart() { super.onStart(); delegate.onStart(); } @Override public void onStop() { super.onStop(); delegate.onStop(); } @Override public void onAttach(Activity activity) { super.onAttach(activity); delegate.onAttach(activity); } @Override public void onDetach() { super.onDetach(); delegate.onDetach(); } @Override public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); delegate.onActivityCreated(savedInstanceState); } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); delegate.onSaveInstanceState(outState); } ... } Delegation allows you to add functionality to any class inclusive third party frameworks like RoboGuice. Mosby\u0026rsquo;s ships with support Fragment (Fragments from support library). With delegation as described above you can use \u0026ldquo;native\u0026rdquo; android.app.Fragment as well.\nAnother advantage of delegation is that you can change Mosby\u0026rsquo;s default behavior by implementing a custom Delegate. For example: Mosby\u0026rsquo;s default implementation of how to handle Presenter during orientation changes is to recreate the presenter and to restart the requests (excepted retaining Fragments where the Presenter survives). You could write another ActivityMvpDelegate or FragmentMvpDelegate that internally uses a HashMap\u0026lt;Integer, MvpPresenter\u0026gt; to store an already existing Presenter and reuse it when the View gets recreated after orientation changes (instead of creating a new one and restart requests):\npublic interface IdBasedMvpView extends MvpView { public void setId(int id); public int getId(); } public class IdBasedActivityMvpDelegate\u0026lt;V extends IdBasedMvpView, P extends MvpPresenter\u0026lt;V\u0026gt;\u0026gt; implements ActivityMvpDelegate { // Every view gets an unique id  private static int lastViewId = 0; // Map to store presenter  private static Map\u0026lt;Integer, MvpPresenter\u0026gt; presenterMap = new HashMap\u0026lt;\u0026gt;(); // The reference to the Activity  private MvpDelegateCallback\u0026lt;V, P\u0026gt; delegateCallback; public ActivityMvpDelegateImpl(MvpDelegateCallback\u0026lt;V, P\u0026gt; delegateCallback) { this.delegateCallback = delegateCallback; } // Called from Activity.onCreate()  @Override public void onCreate(Bundle bundle) { // Returns 0 if no view id is assigned  int viewId = bundle.getInt(\u0026#34;MvpViewId\u0026#34;); MvpPresenter presenter = presenterMap.get(viewId); if (presenter == null){ // No presenter in Map --\u0026gt; View starting first time  // so create a new presenter and put it into presenterMap  presenter = delegateCallback.createPresenter(); viewId = ++lastViewId; presenterMap.put(viewId, presenter); } V view = delegateCallback.getMvpView(); view.setViewId(viewId); view.setPresenter(presenter); presenter.attachView(view); } @Override public void onSaveInstanceState(Bundle outState) { int viewId = delegateCallback.getMvpView().getViewId(); outState.putInt(\u0026#34;MvpViewId\u0026#34;, viewId); } @Override public void onDestroy() { delegateCallback.getPresenter().detachView(true); // true == presenter retains instance state  } } public MyActivity extends MvpActivity implements IdBasedMvpView { ActivityMvpDelegate mvpDelegate; @Override protected ActivityMvpDelegate\u0026lt;V, P\u0026gt; getMvpDelegate() { if (mvpDelegate == null) { mvpDelegate = new IdBasedActivityMvpDelegate(this); } return mvpDelegate; } } We assign each view a unique id. With this id we can find the presenter in presenterMap. If no presenter is available, then we create a new one and put it into the presenterMap. The view\u0026rsquo;s unique id is stored into the views bundle. That way you would be able to have retaining presenters for Activities and non retaining Fragments as well. So why this is not the default implementation of Mosby? The problem with that approach is memory management. When does a Presenter gets removed from this map? If Presenter never gets removed does it cause memory leaks? Usually presenters are lightweight objects but most of the time they are a callback for an async running thread. To avoid memory leaks this is not the default strategy in Mosby. You could also implement an ActivityMvpDelegate that stores the Presenters state in a Bundle (like Mortar does, in combination with dagger scopes). So you see: Mosby offers a flexible scaffold and a default implementation that match the most scenarios. However, Mosby is customizable for edge cases.\nTip 23: Tips are good - experience is better Whenever Barney Stinson leaves MacLaren\u0026rsquo;s pub at midnight with a big smile on his face and a beautiful woman next to him he knows that he has not succeeded because of the playbook. Actually he succeeded because he has a lot of experience in talking to woman (and wears suits!). Of course some tips and advices are helpful but at the end everyone has to make his own experience (including failing). The same is true when writing apps: you learn while developing and with every app you have developed your experience level increase and your next app will benefit from your experience. In this sense: Happy hacking!\nI want to thank Kirill Boyarshinov very much for helping me.\nThe source code of the sample mail app can be found on Github. If you have any question don\u0026rsquo;t hesitate to leave a comment below.\n","permalink":"https://hannesdorfmann.com/android/mosby-playbook/","tags":["android","software-architecture","design-patterns","library"],"title":"Stinson's Playbook for Mosby"},{"categories":["Android"],"contents":"Ted Mosby, architect in How I met your mother (one of my favorite tv shows) was the inspiration for the name of this android library I\u0026rsquo;m going to talk about in this blog post. This library helps you to build good, robust and reusable software by implementing Model-View-Presenter pattern on android along with some nice features like ViewState for handling screen orientation changes easily. This blog post gives you an introduction to Mosby. The next blog post gives you some tips related to Mosby by showing how to implement a mail client on android: Stinson\u0026rsquo;s playbook for Mosby\nModel-View-Presenter (MVP) The Model-View-Presenter design pattern is a modern pattern to separate the view from the underlying model. MVP is a derivative of the model–view–controller (MVC) software pattern, also used mostly for building user interfaces.\n The model is the data that will be displayed in the view (user interface). The view is an interface that displays data (the model) and routes user commands (events) to the presenter to act upon that data. The view usually has a reference to its presenter. The presenter is the \u0026ldquo;middle-man\u0026rdquo; (played by the controller in MVC) and has references to both, view and model. Please note that the word \u0026ldquo;Model\u0026rdquo; is not correct. It should rather be business logic that retrieves or manipulates a Model For instance: If you have a database with User and your View wants to display a list of User, then the Presenter would have a reference to your database business logic (like a DAO) from where the presenter will query a list of Users.  A concrete workflow of querying and displaying a list of users from a database could work like this:\nThe workflow Image shown above should be self-explaining. However here are some additional thoughts:\n The Presenter is not a OnClickListener. The View is responsible for handling user input and invoking the corresponding method of the presenter. Why not eliminating this \u0026ldquo;forwarding\u0026rdquo; process by making the Presenter an OnClickListener? If doing so the presenter needs to have knowledge about views internals. For instance, if a View has two buttons and the view registers the Presenter as OnClickListener on both, how could the Presenter distinguish which button has been clicked on a click event (without knowing views internals like the references to the button)? Model, View and Presenter should be decoupled. Furthermore, by letting Presenter implement OnClickListener the Presenter is bound to the android platform. In theory the presenter and business logic could be plain old java code, which could be shared with a desktop application or any other java application. The View is only doing what the Presenter tells the View to do like you can see in step 1 and step 2: After the user has clicked on the \u0026ldquo;load user button\u0026rdquo; (step 1) the view doesn\u0026rsquo;t show the loading animation directly. It\u0026rsquo;s the presenter (step 2) who explicitly tells the view to show the loading animation. This variant of Model-View-Presenter is called MVP Passive View. The view should be as dumb as possible. Let the presenter control the view in an abstract way. For instance: presenter invokes view.showLoading() but presenter should not control view specific things like animations. So presenter should not invoke methods like view.startAnimation() etc. By implementing MVP Passive View it\u0026rsquo;s much easier to handle concurrency and multithreading. Like you can see in step 3 the database query runs async an the presenter is a Listener / Observer and gets notified when data is ready to display.  MVP on Android So far so good. but how do you apply MVP on your own Android app? The first question is, where should we apply the MVP pattern? On an Activity, Fragment or a ViewGroup like a RelativeLayout? Let\u0026rsquo;s have a look at the at the Gmail Android tablet app:\nFrom my point of view, there are 4 independent MVP candidates on the screen. With MVP candidate I mean UI element(s) displayed on the screen that logically belongs together and therefore can be seen as a single UI unit where we could apply MVP.\nIt seems that Activities and especially Fragments are good candidates. Usually a Fragment is responsible to just display a single content like a ListView. For example InboxView, controlled by an InboxPresenter which uses MailProvider to get a List of Mails. However, MVP is not limited to Fragments or Activities. You can also apply this design Pattern on ViewGroups like shown in SearchView. In the most of my apps I use Fragments as MVP candidates. However it\u0026rsquo;s up to you to find MVP candidates. Just ensure that the view is independent so that one presenter can control that View without getting in conflict with another Presenter.\nWhy should you implement MVP?\nHow would you implement the inbox view in a traditional Fragment without MVP to display a list of emails that needs to be merged from two sources like a local sql database (on your device) and an IMAP mail server connected over internet. How would your code of the fragment looks like? You would start two AsyncTasks and have to implement a \u0026ldquo;wait mechanism\u0026rdquo; (wait until both tasks have finished to merged the loaded data of both tasks to a single list of mails). You also have to take care of displaying a loading animation (ProgressBar) while loading and replace that one with a ListView afterwards. Would you put all that code into the Fragment? What about errors while loading? What about screen orientation changes? Who is responsible to cancel AsyncTasks? This kind of problems can be addressed and solved with MVP. Say goodbye to activities and fragments with 1000+ lines of spaghetti code.\nBut before we dive deeper in how to implement MVP on Android we have to clarify if an Activity or Fragment is a View or a Presenter. Activity and Fragment seems to be both, because they have lifecycle callbacks like onCreate() or onDestroy() as well as responsibilities of View things like switching from one UI widget to another UI widget (like showing a ProgressBar while loading and then displaying a ListView with data). You may say that these sounds like an Activity or Fragment is a Controller and I guess that was the original intention. However, after some years of experience in developing Android apps I came to the conclusion that Activity and Fragment should be treated like a (dumb) View and not a Presenter. You will see why afterwards.\nWith that said, I want to introduce Mosby a library for creating MVP based apps on android.\nMosby Mosby can be found on Github and is available in maven central. Mosby is divided into serval submodules so you can pick that components that you need. Let\u0026rsquo;s review the most important one.\nCore - Module Ted Mosby in How I met your mother wants to create a skyscraper. Building such a impressive building needs a good fundament. Same is valid for Android apps. Basically, the Core Module offers two classes: MosbyActivity and MosbyFragment. These are the base classe (the fundament) for all other activity or fragment subclasses. Both use well known annotation processors to reduce writing boilerplate code. MosbyActivity and MosbyFragment use Butterknife for view \u0026ldquo;injection\u0026rdquo;, Icepick for saving and restoring instance state to a bundle and FragmentArgs for injecting Fragment arguments. You don\u0026rsquo;t have to call the injecting methods like Butterknife.inject(this). This kind of code is already included in MosbyActivity and MosbyFragment. It just works out of the box. The only thing you have to do is to use the corresponding annotations in your subclasses. The Core - Module is not related to MVP. It\u0026rsquo;s just the fundament to build skyscraper apps on it.\nMVP - Module Mosby\u0026rsquo;s MVP module uses generics to ensure type safety. The base class for all views is MvpView. Basically it\u0026rsquo;s just an empty interface. The base class for presenters is MvpPresenter:\npublic interface MvpView { } public interface MvpPresenter\u0026lt;V extends MvpView\u0026gt; { public void attachView(V view); public void detachView(boolean retainInstance); } As already mentioned before we treat Activity and Fragment as Views. Therefore Mobsby\u0026rsquo;s MVP module provides MvpActivity and MvpFragment which are MvpViews as base classes for Activities and Fragments:\npublic abstract class MvpActivity\u0026lt;V extends MvpView, P extends MvpPresenter\u0026gt; extends MosbyActivity implements MvpView { protected P presenter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); presenter = createPresenter(); presenter.attachView(this); } @Override protected void onDestroy() { super.onDestroy(); presenter.detachView(false); } protected abstract P createPresenter(); } public abstract class MvpFragment\u0026lt;V extends MvpView, P extends MvpPresenter\u0026gt; extends MosbyFragment implements MvpView { protected P presenter; @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); // Create the presenter if needed  if (presenter == null) { presenter = createPresenter(); } presenter.attachView(this); } @Override public void onDestroyView() { super.onDestroyView(); presenter.detachView(getRetainInstance()); } protected abstract P createPresenter(); } The idea is that a MvpView (i.e. Fragment or Activity) gets attached to and detached from his MvpPresenter. Mosby takes Activities and Fragments lifecycle for doing so as you have seen in the code snipped above. Usually a presenter is bound to that lifecycle. So initializing and cleaning up things (like canceling async running tasks) should be done in presenter.onAttach() and presenter.onDetach(). We will discuss later how a presenter can \u0026ldquo;escape\u0026rdquo; this lifecycle in Fragments by using setRetainInstanceState(true). You may have noticed that MvpPresenter is an interface. The MVP module provides MvpBasePresenter, a presenter implementation which uses WeakReference to hold the reference to the view (which is a Fragment or Activity) to avoid memory leaks. Therefore when your presenter wants to invoke a method of the view you always have to check if the view is attached to the presenter by checking isViewAttached() and using getView() to get the reference.\nLoading-Content-Error (LCE) Usually a Fragment is doing the same thing over and over again. It loads data in background, display a loading view (i.e ProgressBar) while loading, displays the loaded data on screen or displays an error view if loading failed. Nowadays supporting pull to refresh is easy as SwipeRefreshLayout is part of android\u0026rsquo;s support library. To not reimplementing this workflow again and again Mosby\u0026rsquo;s MVP module provides MvpLceView:\npublic interface MvpLceView\u0026lt;M\u0026gt; extends MvpView { /** * Display a loading view while loading data in background. * \u0026lt;b\u0026gt;The loading view must have the id = R.id.loadingView\u0026lt;/b\u0026gt; * * @param pullToRefresh true, if pull-to-refresh has been invoked loading. */ public void showLoading(boolean pullToRefresh); /** * Show the content view. * * \u0026lt;b\u0026gt;The content view must have the id = R.id.contentView\u0026lt;/b\u0026gt; */ public void showContent(); /** * Show the error view. * \u0026lt;b\u0026gt;The error view must be a TextView with the id = R.id.errorView\u0026lt;/b\u0026gt; * * @param e The Throwable that has caused this error * @param pullToRefresh true, if the exception was thrown during pull-to-refresh, otherwise * false. */ public void showError(Throwable e, boolean pullToRefresh); /** * The data that should be displayed with {@link #showContent()} */ public void setData(M data); } You can use MvpLceActivity implements MvpLceView and MvpLceFragment implements MvpLceView for that kind of view. Both assume that the inflated xml layout contains views with R.id.loadingView, R.id.contentView and R.id.errorView.\nExample In the following example (hosted onGithub ) we are loading a list of Country by using CountriesAsyncLoader and display that in a RecyclerView in a Fragment. You can download the sample APK here.\nLet\u0026rsquo;s start by defining the view interface CountriesView:\npublic interface CountriesView extends MvpLceView\u0026lt;List\u0026lt;Country\u0026gt;\u0026gt; { } Why do I need to define interfaces for the View?\n Since it\u0026rsquo;s an interface you can change the view implementation. You can simple move your code from something that extends Activity to something that extends Fragment. Modularity: You can move the whole business logic, Presenter and View Interface in a standalone library project. Then you can use this library with the containing Presenter in various apps. The following image shows the kicker app on the left which uses an Activity while meinVerein app uses a Fragment embedded in a ViewPager. Both use the same library where View-Interface and Presenter are defined and unit tested.  You can easily write unit tests since you can mock views by implement the view interface. One could also introduce a java interface for the presenter to make unit testing by using mock presenter objects even more easy. Another very nice side effect of defining a interface for the view is that you don\u0026rsquo;t get tempted to call methods of the activity / fragment directly from presenter. You get a clear separation because while implementing the presenter the only methods you see in your IDE\u0026rsquo;s auto completion are those methods of the view interface. From my personal experiences I can say that this is very useful especially if you work in a team.  Please note that we could also use MvpLceView\u0026lt;List\u0026lt;Country\u0026gt;\u0026gt; instead of defining an (empty, because inherits methods) interface CountriesView. But having an dedicated interface CountriesView improves code readability and we are more flexible to define more View related methods in the future.\nNext we define our views xml layout file with the required ids:\n\u0026lt;FrameLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; \u0026gt; \u0026lt;!-- Loading View --\u0026gt; \u0026lt;ProgressBar android:id=\u0026#34;@+id/loadingView\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:indeterminate=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!-- Content View --\u0026gt; \u0026lt;android.support.v4.widget.SwipeRefreshLayout android:id=\u0026#34;@+id/contentView\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; \u0026gt; \u0026lt;android.support.v7.widget.RecyclerView android:id=\u0026#34;@+id/recyclerView\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; /\u0026gt; \u0026lt;/android.support.v4.widget.SwipeRefreshLayout\u0026gt; \u0026lt;!-- Error view --\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/errorView\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; The CountriesPresenter controls CountriesView and starts the CountriesAsyncLoader:\npublic class CountriesPresenter extends MvpBasePresenter\u0026lt;CountriesView\u0026gt; { @Override public void loadCountries(final boolean pullToRefresh) { getView().showLoading(pullToRefresh); CountriesAsyncLoader countriesLoader = new CountriesAsyncLoader( new CountriesAsyncLoader.CountriesLoaderListener() { @Override public void onSuccess(List\u0026lt;Country\u0026gt; countries) { if (isViewAttached()) { getView().setData(countries); getView().showContent(); } } @Override public void onError(Exception e) { if (isViewAttached()) { getView().showError(e, pullToRefresh); } } }); countriesLoader.execute(); } } The CountriesFragment which implements CountriesView looks like this:\npublic class CountriesFragment extends MvpLceFragment\u0026lt;SwipeRefreshLayout, List\u0026lt;Country\u0026gt;, CountriesView, CountriesPresenter\u0026gt; implements CountriesView, SwipeRefreshLayout.OnRefreshListener { @InjectView(R.id.recyclerView) RecyclerView recyclerView; CountriesAdapter adapter; @Override public void onViewCreated(View view, @Nullable Bundle savedInstance) { super.onViewCreated(view, savedInstance); // Setup contentView == SwipeRefreshView  contentView.setOnRefreshListener(this); // Setup recycler view  adapter = new CountriesAdapter(getActivity()); recyclerView.setLayoutManager(new LinearLayoutManager(getActivity())); recyclerView.setAdapter(adapter); loadData(false); } public void loadData(boolean pullToRefresh) { presenter.loadCountries(pullToRefresh); } @Override protected CountriesPresenter createPresenter() { return new SimpleCountriesPresenter(); } // Just a shorthand that will be called in onCreateView()  @Override protected int getLayoutRes() { return R.layout.countries_list; } @Override public void setData(List\u0026lt;Country\u0026gt; data) { adapter.setCountries(data); adapter.notifyDataSetChanged(); } @Override public void onRefresh() { loadData(true); } } Not that much code to write, right? It\u0026rsquo;s because the base class MvpLceFragment already implements the switching from loading view to content view or error view for us. At first glance the list of generics parameter of MvpLceFragment may discourage you. Let me explain that: The first generics parameter is the type of the content view. The second is the Model that is displayed with this fragment. The third one is the View interface and the last one is the type of the Presenter. To summarize: MvpLceFragment\u0026lt;AndroidView, Model, View, Presenter\u0026gt;\nAnother thing you may have noticed is getLayoutRes(), which is a shorthand introduced in MosbyFragment for inflating a xml view layout:\n@Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState){ return inflater.inflate(getLayoutRes(), container, false); } So instead of overriding onCreateView() you can override getLayoutRes(). In general onCreateView() should only create the view while onViewCreated() should be overridden to init things like Adapter for RecyclerView. Important: don\u0026rsquo;t forget to call super.onViewCreated()\nViewState - Module Now you should have an idea of how to use Mosby. Mosby\u0026rsquo;s ViewState module helps you to solve on of the annoying things in android development: Handling screen orientation changes.\nQuestion: What happens if we rotate our device from portrait to landscape that runs our countries example app and already displays a list of countries?\nAnswer: A new CountriesFragment gets instantiated and the app starts by showing the ProgressBar (and loads list of countries again) rather than displaying the list of countries in the RecyclerView (as it was before the screen rotation) as you can see in the video below:\n  Mosby introduces ViewState to solve this problem. The idea is, that we track the methods the presenter invokes on the attached View. For instance the presenter calls view.showContent(). Once showContent() gets called the view knows that it\u0026rsquo;s state is \u0026ldquo;showing content\u0026rdquo; and hence the view stores this information into a ViewState. If the view gets destroyed during orientation changes, the ViewState gets stored into a bundle in Activity.onSaveInstanceState(Bundle) or Fragment.onSaveInstanceState(Bundle) and will be restored in Activity.onCreate(Bundle) or Fragment.onActivityCreated(Bundle).\nSince not every kind of data (I\u0026rsquo;m talking about the data type passed as parameter in view.setData() ) can be stored in a Bundle, different ViewState implementations are provided like ArrayListLceViewState for data of type ArrayList\u0026lt;Parcelable\u0026gt;, ParcelableDataLceViewState - for data of type Parcelable or SerializeableLceViewState - for data of type Serializeable. If you use a retaining Fragment (more about retaining Fragments below) then the ViewState is not destroyed during screen orientation changes and doesn\u0026rsquo;t need to be saved into a Bundle. Hence it can store any type of data. In that case you should use RetainingFragmentLceViewState. Restoring a ViewState is easy. Since we have a clean architecture and an interface for our View, ViewState can restore the associated view by calling the same interface methods as the presenter does. For example MvpLceView basically has 3 states: it can display showContent(), showLoading() and showError() and hence the ViewState himself calls the corresponding method to restore the views state.\nThat are just internals. You only need to know about that if you want to write your own custom ViewStates. Using ViewStates is pretty easy. Actually, to migrate an MvpLceFragment to an MvpLceViewStateFragment you only additionally have to implement createViewState() and getData(). Let\u0026rsquo;s do that for our CountriesFragment:\npublic class CountriesFragment extends MvpLceViewStateFragment\u0026lt;SwipeRefreshLayout, List\u0026lt;Country\u0026gt;, CountriesView, CountriesPresenter\u0026gt; implements CountriesView, SwipeRefreshLayout.OnRefreshListener { @InjectView(R.id.recyclerView) RecyclerView recyclerView; CountriesAdapter adapter; @Override public LceViewState\u0026lt;List\u0026lt;Country\u0026gt;, CountriesView\u0026gt; createViewState() { return new RetainingFragmentLceViewState\u0026lt;List\u0026lt;Country\u0026gt;, CountriesView\u0026gt;(this); } @Override public List\u0026lt;Country\u0026gt; getData() { return adapter == null ? null : adapter.getCountries(); } // The code below is the same as before  @Override public void onViewCreated(View view, @Nullable Bundle savedInstance) { super.onViewCreated(view, savedInstance); // Setup contentView == SwipeRefreshView  contentView.setOnRefreshListener(this); // Setup recycler view  adapter = new CountriesAdapter(getActivity()); recyclerView.setLayoutManager(new LinearLayoutManager(getActivity())); recyclerView.setAdapter(adapter); loadData(false); } public void loadData(boolean pullToRefresh) { presenter.loadCountries(pullToRefresh); } @Override protected CountriesPresenter createPresenter() { return new SimpleCountriesPresenter(); } // Just a shorthand that will be called in onCreateView()  @Override protected int getLayoutRes() { return R.layout.countries_list; } @Override public void setData(List\u0026lt;Country\u0026gt; data) { adapter.setCountries(data); adapter.notifyDataSetChanged(); } @Override public void onRefresh() { loadData(true); } } That\u0026rsquo;s all. You don\u0026rsquo;t have to change code of your presenter or something else. Here is a video of our CountriesFragment with ViewState support where you can see that now the view is still in the same \u0026ldquo;state\u0026rdquo; after orientation changes, i.e. the view shows the list of Countries in portrait, then it also shows the list of Countries in landscape. The view shows the pull to refresh indicator in landscape and shows the pull to refresh indicator after changing to portrait as well.\n  Writing your own ViewState ViewState is a really powerful and flexible concept. So far you learned how easy it is to use one of the provided LCE (Loading-Content-Error) ViewsStates. Now lets write our own custom View and ViewState. Our View should only display two different kind of data objects A and B. The result should look like this:\n  I know, it\u0026rsquo;s not that impressive. It should just give you an idea of how easy it is to create your own ViewState.\nThe View interface and the data objects (model) looks like this:\npublic class A implements Parcelable { String name; public A(String name) { this.name = name; } public String getName() { return name; } } public class B implements Parcelable { String foo; public B(String foo) { this.foo = foo; } public String getFoo() { return foo; } } public interface MyCustomView extends MvpView { public void showA(A a); public void showB(B b); } We don\u0026rsquo;t have any business logic in this simple sample. Let\u0026rsquo;s assume that in a real world app there would be a complex operation in our business logic to generate A or B. Our presenter looks like this:\npublic class MyCustomPresenter extends MvpBasePresenter\u0026lt;MyCustomView\u0026gt; { Random random = new Random(); public void doA() { A a = new A(\u0026#34;My name is A \u0026#34;+random.nextInt(10)); if (isViewAttached()) { getView().showA(a); } } public void doB() { B b = new B(\u0026#34;I am B \u0026#34;+random.nextInt(10)); if (isViewAttached()) { getView().showB(b); } } } We define MyCustomActivity which implements MyCustomView\npublic class MyCustomActivity extends MvpViewStateActivity\u0026lt;MyCustomView, MyCustomPresenter\u0026gt; implements MyCustomView { @InjectView(R.id.textViewA) TextView aView; @InjectView(R.id.textViewB) TextView bView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.my_custom_view); } @Override public RestoreableViewState createViewState() { return new MyCustomViewState(); // Our ViewState implementation  } // Will be called when no view state exist yet,  // which is the case the first time MyCustomActivity starts  @Override public void onNewViewStateInstance() { presenter.doA(); } @Override protected MyCustomPresenter createPresenter() { return new MyCustomPresenter(); } @Override public void showA(A a) { MyCustomViewState vs = ((MyCustomViewState) viewState); vs.setShowingA(true); vs.setData(a); aView.setText(a.getName()); aView.setVisibility(View.VISIBLE); bView.setVisibility(View.GONE); } @Override public void showB(B b) { MyCustomViewState vs = ((MyCustomViewState) viewState); vs.setShowingA(false); vs.setData(b); bView.setText(b.getFoo()); aView.setVisibility(View.GONE); bView.setVisibility(View.VISIBLE); } @OnClick(R.id.loadA) public void onLoadAClicked() { presenter.doA(); } @OnClick(R.id.loadB) public void onLoadBClicked() { presenter.doB(); } } Since we are not having LCE (Loading-Content-Error) we are not using MvpLceActivity as base class. We use MvpViewStateActivity as base class which is the most general Activity implementation that supports ViewState. Basically our View simply displays aView or bView. In **onNewViewStateInstance() ** we have to specify what to do on first Activity start, because no previous ViewState instance exists to restore. In showA(A a) and showB(B b) we have to save the information that we are displays A or B into our ViewState. We are almost done, only MyCustomViewState implementation is missing:\npublic class MyCustomViewState implements RestoreableViewState\u0026lt;MyCustomView\u0026gt; { private final String KEY_STATE = \u0026#34;MyCustomViewState-flag\u0026#34;; private final String KEY_DATA = \u0026#34;MyCustomViewState-data\u0026#34;; public boolean showingA = true; // if false, then show B  public Parcelable data; // Can be A or B  @Override public void saveInstanceState(Bundle out) { out.putBoolean(KEY_STATE, showingA); out.putParcelable(KEY_DATA, data); } @Override public boolean restoreInstanceState(Bundle in) { if (in == null) { return false; } showingA = in.getBoolean(KEY_STATE, true); data = in.getParcelable(KEY_DATA); return true; } @Override public void apply(MyCustomView view, boolean retained) { if (showingA) { view.showA((A) data); } else { view.showB((B) data); } } /** * @param a true if showing a, false if showing b */ public void setShowingA(boolean a) { this.showingA = a; } public void setData(Parcelable data){ this.data = data; } } As you can see we have to save our ViewState in saveInstanceState() which will be called from Activity.onSaveInstanceState() and restore the viewstate\u0026rsquo;s data in restoreInstanceState() which will be called from Activity.onCreate(). The apply() method will be called from Activity to restore the view state. We do that by calling the same View interface methods showA() or showB() like the presenter does.\nThis external ViewState class pulls the complexity and responsibility of restoring the view\u0026rsquo;s state out from the Activity code into this separated class. It\u0026rsquo;s also easier to write unit tests for a ViewState class than for an Activity class.\nHow to handle background threads? Usually background threads are observed by the Presenter. There are two scenario how presenter can handle background threads depending on the the surrounding Activity or Fragment:\n  Retaining Fragment: If you set Fragment.setRetainInstanceState(true) then the Fragment will not be destroyed during screen rotations. Only the Fragment\u0026rsquo;s GUI (the android.view.View returned from onCreateView()) get\u0026rsquo;s destroyed an newly created. That means all of your fragment class member variables are still there after screen rotation and so is the presenter still there after screen orientation has been changed. In that case we just detach the old view from presenter and attach the new view to presenter. Hence the presenter doesn\u0026rsquo;t have to cancel any running background task, because the view gets reattached. Example:\n We start our app in portrait. The retaining fragment gets instantiated and calls onCreate(), onCreateView(), createPresenter() and attach the view (the fragment himself) to the presenter by calling presenter.attachView(). Next we rotate our device from portrait to landscape. onDestroyView() gets called which calls presenter.detachView(true). Note that the parameter true, informs the presenter that the fragment is a retaining fragment (otherwise the parameter would be set to false). Therefore the presenter knows that he doesn\u0026rsquo;t have to cancel running background threads. App is in landscape now. onCreateView() gets called, but not createPresenter() because presenter != null since presenter variable has survived orientation changes because of setRetainInstanceState(true). View gets reattached to presenter by presenter.attachView(). ViewState gets restored. Since no background thread has been canceled restarting background threads is not needed.    Activity and NOT Retaining Fragments: In that case the workflow is quite simple. Everything gets destroyed (presenter instance too), hence the presenter should cancel running background tasks. Example:\n We start our app in portrait with an NOT retaining fragment The fragment gets instantiated and calls onCreate(), onCreateView(), createPresenter() and attach the view (the fragment) to the presenter by calling presenter.attachView(). Next we rotate our device from portrait to landscape. onDestroyView() gets called which calls presenter.detachView(false). Presenter cancels background tasks. onSaveInstanceState(Bundle) gets called where the ViewState gets saved into the Bundle. App is in landscape now. A new Fragment gets instantiated and calls onCreate(), onCreateView(), createPresenter(), which creates a new presenter instance and attaches the new view to the new presenter by calling presenter.attachView(). ViewState gets restored from Bundle and restores the views state. If the ViewState was showLoading then the presenter restarts new background threads to load data.    To sum it up here is a lifecycle diagram for Activities with ViewState support: and here is the lifecycle diagram for Fragments with ViewState support:\nRetrofit - Module Mosby provides LceRetrofitPresenter and LceCallback. Writing an Presenter for Retrofit with support for LCE methods showLoading(), showContent() and showError() can be done in few lines of code.\npublic class MembersPresenter extends LceRetrofitPresenter\u0026lt;MembersView, List\u0026lt;User\u0026gt;\u0026gt; { private GithubApi githubApi; public MembersPresenter(GithubApi githubApi){ this.githubApi = githubApi; } public void loadSquareMembers(boolean pullToRefresh){ githubApi.getMembers(\u0026#34;square\u0026#34;, new LceCallback(pullToRefresh)); } } Dagger - Module Building an app without dependency injection? Ted Mosby would kick you in the ass! Dagger is one of the most used dependency injection frameworks for java and very popular by android developers. Mosby supports Dagger1. Mosby provides an Injector interface with a method called getObjectGraph(). Usually, you have an application wide module. To share this module easily you have to subclass android.app.Application and make it implement Injector. Then all Activities and Fragments can access that ObjectGraph by calling getObjectGraph() since DaggerActivity and DaggerFragment are Injector as well. You can also call plus(Module) to add modules by overriding getObjcetGraph() in Activity or Fragment. I personally have migrated to Dagger2, which works also with Mosby. You can find samples for both Dagger1 and Dagger2 on Github. The Dagger1 sample apk can be downloaded here and Dagger2 sample apk can be downloaded here\nRx - Module Observables ftw! Nowadays all the cool kids use RxJava and you know what? RxJava is pretty cool! Therefore Mosby offers MvpLceRxPresenter which internally is a Subscriber and handles for you automatically onNext(), onCompleted() and onError() as well as invoking the corresponding LCE method like showLoading(), shwoContent() and showError(). It also ships with RxAndroid to observerOn() Androids Main UI Thread. You may think that you don\u0026rsquo;t need Model View Presenter anymore by using RxJava. Well, that\u0026rsquo;s your decision. In my opinion a clear separation between View and Model is essential. I also think that some nice features like ViewState is not as easy to implement without MVP. And last but not least, do you really wanna step back where Activities and Fragments containing more than 1000+ lines of code? Welcome back to the spaghetti code hell. Ok, let\u0026rsquo;s be fair, it\u0026rsquo;s not spaghetti code because Observables introduce a nice structured workflow, but you are one step closer to make your Activity or Fragment to a BLOB\nTesting - Module You may have noticed that a testing module exists. This module is used internally to test mosby library. However it can also be used for your own app. It offers unit testing templates for your LCE Presenter, Activities and Fragments by using Robolectric. Basically, it checks if the Presenter under test is working correctly: Does the presenter calls showLoading(), showContent() and showError(). You can also verify the data from setData(). So you could write kind of black box tests for Presenter and underlying layers. Mosby\u0026rsquo;s testing module also provides the possibility to test your MvpLceFragment or MvpLceActivity. It\u0026rsquo;s kind of an \u0026ldquo;lite\u0026rdquo; UI test. These tests only check if the Fragment or Activity is working properly without crashing, by checking if the xml layout contains the required ids like R.id.loadingView, R.id.contentView and R.id.errorView or checks if the loadingView is visible, while loading data, is the error view visible, does the content view can handle the loaded data submitted by setData(). It\u0026rsquo;s not an UI test like you could do with Espresso. I don\u0026rsquo;t see the need to write UI tests for LCE Views. Concluding here are Ted Mosby\u0026rsquo;s testing tips:\n Write traditional unit tests for testing your business logic and models. Use MvpLcePresenterTest to test your presenters, Use MvpLceFragmentTest and MvpLceActivityTest to test your MvpLceFragment / Activity. If you want, you can write UI Tests by using Espresso.  The Testing - Module is not complete yet. You can see this module as beta software, because Robolectric 3.0 is not finished yet, nor has android gradle plugin full support for traditional unit tests. This should be much better with android gradle plugin 1.2. I will write another blog post about unit testing with Mosby, Dagger, Retrofit and RxJava once Robolectric and androids gradle plugin are ready to be used.\nUpdate: A new Blog post with some tips related to Mosby by showing how to implement a mail client on android is online: Stinson\u0026rsquo;s playbook for Mosby\n","permalink":"https://hannesdorfmann.com/android/mosby/","tags":["android","software-architecture","design-patterns","library"],"title":"Ted Mosby - Software Architect"},{"categories":["Annotation Processor"],"contents":"In this blog entry I would like to explain how to write an annotation processor. First, I am going to explain to you what annotation processing is, what you can do with that powerful tool and finally what you cannot do with it. In a second step we will implement a simple annotation processor step by step.\nThe Basics To clarify a very important thing from the very beginning: we are not talking about evaluating annotations by using reflections at runtime (run time = the time when the application runs). Annotation processing takes place at compile time (compile time = the time when the java compiler compiles your java source code).\nAnnotation processing is a tool build in javac for scanning and processing annotations at compile time. You can register your own annotation processor for certain annotations. At this point I assume that you already know what an annotation is and how to declare an annotation type. If you are not familar with annotations you can find more information in the official java documentation. Annotation processing is already available since Java 5 but a useable API is available since Java 6 (released in December 2006). It took some time until the java world realized the power of annotation processing. So it has become popular in the last few years.\nAn annotation processor for a certain annotation takes java code (or compiled byte code) as input and generate files (usually .java files) as output. What does that exactly means? You can generate java code! The generated java code is in a generated .java file. So you can not manipulate an existing java class for instance adding a method. The generated java file will be compiled by javac as any other hand written java source file.\nAbstractProcessor Let\u0026rsquo;s have a look at the Processor API. Every Processor extends from AbstractProcessor as follows:\npackage com.example; public class MyProcessor extends AbstractProcessor { @Override public synchronized void init(ProcessingEnvironment env){ } @Override public boolean process(Set\u0026lt;? extends TypeElement\u0026gt; annoations, RoundEnvironment env) { } @Override public Set\u0026lt;String\u0026gt; getSupportedAnnotationTypes() { } @Override public SourceVersion getSupportedSourceVersion() { } }  init(ProcessingEnvironment env): Every annotation processor class must have an empty constructor. However, there is a special init() method which is invoked by the annotation processing tool with the ProcessingEnviroment as parameter. The ProcessingEnviroment provides some useful util classes Elements, Types and Filer. We will use them later. process(Set\u0026lt;? extends TypeElement\u0026gt; annotations, RoundEnvironment env): This is kind of main() method of each processor. Here you write your code for scanning, evaluating and processing annotations and generating java files. With RoundEnviroment passed as parameter you can query for elements annotated with a certain annotation as we will see later. getSupportedAnnotationTypes(): Here you have to specify for which annotations this annotation processor should be registered for. Note that the return type is a set of strings containing full qualified names for your annotation types you want to process with this annotation processor. In other words, you define here for which annotations you register your annotation processor. getSupportedSourceVersion(): Used to specify which java version you use. Usually you will return SourceVersion.latestSupported(). However, you could also return SourceVersion.RELEASE_6 if you have good reasons for stick with Java 6. I recommend to use SourceVersion.latestSupported();  With Java 7 you could also use annotations instead of overriding getSupportedAnnotationTypes() and getSupportedSourceVersion() like that:\n@SupportedSourceVersion(SourceVersion.latestSupported()) @SupportedAnnotationTypes({ // Set of full qullified annotation type names  }) public class MyProcessor extends AbstractProcessor { @Override public synchronized void init(ProcessingEnvironment env){ } @Override public boolean process(Set\u0026lt;? extends TypeElement\u0026gt; annoations, RoundEnvironment env) { } } For compatibility reasons, especially for android, I recommend to override getSupportedAnnotationTypes() and getSupportedSourceVersion() instead of using @SupportedAnnotationTypes and @SupportedSourceVersion\nThe next thing you have to know is that the annotation processor runs in it\u0026rsquo;s own jvm. Yes you read correctly. javac starts a complete java virtual machine for running annotation processors. So what that means for you? You can use anything you would use in any other java application. Use guava! If you want to you can use dependency injection tools like dagger or any other library you want to. But don\u0026rsquo;t forget. Even if it\u0026rsquo;s just a small processor you should take care about efficient algorithms and design patterns like you would do for any other java application.\nRegister Your Processor You may ask yourself \u0026ldquo;How do I register MyProcessor to javac?\u0026quot;. You have to provide a .jar file. Like any other .jar file you pack your (compiled) annotation processor in that file. Furthermore you also have to pack a special file called javax.annotation.processing.Processor located in META-INF/services in your .jar file. So the content of your .jar file looks like this:\nMyProcessor.jar - com - example - MyProcessor.class - META-INF - services - javax.annotation.processing.Processor The content of the file javax.annotation.processing.Processor (packed in MyProcessor.jar) is a list with full qualified class names to the processors with new line as delimiter:\ncom.example.MyProcessor com.foo.OtherProcessor net.blabla.SpecialProcessor With MyProcessor.jar in your buildpath javac automatically detects and reads the javax.annotation.processing.Processor file and registers MyProcessor as annotation processor.\nExample: Factory Pattern It\u0026rsquo;s time to for a concrete example. We will use maven as our build system and dependency management tool. If you are not familiar with maven, don\u0026rsquo;t worry maven is not necessary. The whole code can be found on github.\nFirst of all I have to say, that it\u0026rsquo;s not so easy to find a simple problem for a tutorial that we can solve with an annotation processor. Here we gonna implement a very simple factory pattern (not abstract factory pattern). It should give you just a brief introduction on the annotation processing API. So the problem statement may be a little bit dump and not a real world one. Once again, you will learn about annotation processing and not about design patterns.\nSo here is the problem: We want to implement a pizza store. The pizza store offers to it\u0026rsquo;s customers 2 Pizzas (\u0026ldquo;Margherita\u0026rdquo; and \u0026ldquo;Calzone\u0026rdquo;) and Tiramisu for dessert.\nHave a look at this code snippets, which should not need any further explanation:\npublic interface Meal { public float getPrice(); } public class MargheritaPizza implements Meal { @Override public float getPrice() { return 6.0f; } } public class CalzonePizza implements Meal { @Override public float getPrice() { return 8.5f; } } public class Tiramisu implements Meal { @Override public float getPrice() { return 4.5f; } } To order in our PizzaStore the customer has to enter the name of the meal:\npublic class PizzaStore { public Meal order(String mealName) { if (mealName == null) { throw new IllegalArgumentException(\u0026#34;Name of the meal is null!\u0026#34;); } if (\u0026#34;Margherita\u0026#34;.equals(mealName)) { return new MargheritaPizza(); } if (\u0026#34;Calzone\u0026#34;.equals(mealName)) { return new CalzonePizza(); } if (\u0026#34;Tiramisu\u0026#34;.equals(mealName)) { return new Tiramisu(); } throw new IllegalArgumentException(\u0026#34;Unknown meal \u0026#39;\u0026#34; + mealName + \u0026#34;\u0026#39;\u0026#34;); } public static void main(String[] args) throws IOException { PizzaStore pizzaStore = new PizzaStore(); Meal meal = pizzaStore.order(readConsole()); System.out.println(\u0026#34;Bill: $\u0026#34; + meal.getPrice()); } } As you see, we have a lot of if statements in the order() method and whenever we add a new type of pizza we have to add a new if statement. But wait, with annotation processing and the factory pattern we can let an annotation processor generate this if statements. So what we want to have is something like that:\npublic class PizzaStore { private MealFactory factory = new MealFactory(); public Meal order(String mealName) { return factory.create(mealName); } public static void main(String[] args) throws IOException { PizzaStore pizzaStore = new PizzaStore(); Meal meal = pizzaStore.order(readConsole()); System.out.println(\u0026#34;Bill: $\u0026#34; + meal.getPrice()); } } The MealFactory should look as follows:\npublic class MealFactory { public Meal create(String id) { if (id == null) { throw new IllegalArgumentException(\u0026#34;id is null!\u0026#34;); } if (\u0026#34;Calzone\u0026#34;.equals(id)) { return new CalzonePizza(); } if (\u0026#34;Tiramisu\u0026#34;.equals(id)) { return new Tiramisu(); } if (\u0026#34;Margherita\u0026#34;.equals(id)) { return new MargheritaPizza(); } throw new IllegalArgumentException(\u0026#34;Unknown id = \u0026#34; + id); } } @Factory Annotation Guess what: We want to generate the MealFactory by using annotation processing. To be more general, we want to provide an annotation and a processor for generating factory classes.\nLet\u0026rsquo;s have a look at the @Factory annotation:\n@Target(ElementType.TYPE) @Retention(RetentionPolicy.CLASS) public @interface Factory { /** * The name of the factory */ Class type(); /** * The identifier for determining which item should be instantiated */ String id(); } The idea is that we annotate classes which should belong to the same factory with the same type() and with id() we do the mapping from \u0026quot;Calzone\u0026quot; to CalzonePizza class. Let\u0026rsquo;s apply @Factory to our classes:\n@Factory( id = \u0026#34;Margherita\u0026#34;, type = Meal.class ) public class MargheritaPizza implements Meal { @Override public float getPrice() { return 6f; } } @Factory( id = \u0026#34;Calzone\u0026#34;, type = Meal.class ) public class CalzonePizza implements Meal { @Override public float getPrice() { return 8.5f; } } @Factory( id = \u0026#34;Tiramisu\u0026#34;, type = Meal.class ) public class Tiramisu implements Meal { @Override public float getPrice() { return 4.5f; } } You may ask yourself if we could just apply @Factory on the Meal interface. Annotations are not inherited. Annotating class X with an annotation does not mean that class Y extends X is automatically annotated. Before we start writing the processor code we have to specify some rules:\n Only classes can be annotated with @Factory since interfaces or abstract classes can not be instantiated with the new operator. Classes annotated with @Factory must provide at least one public empty default constructor (parameterless). Otherwise we could not instantiate a new instance. Classes annotated with @Factory must inherit directly or indirectly from the specified type (or implement it if it\u0026rsquo;s an interface). @Factory annotations with the same type are grouped together and one Factory class will be generated. The name of the generated class has \u0026ldquo;Factory\u0026rdquo; as suffix, for example type = Meal.class will generate MealFactory id are limited to Strings and must be unique in it\u0026rsquo;s type group.  The Processor I will guide you step by step by adding line of code followed by an explanation paragraph. Three dots (\u0026hellip;) means that code is omitted either was discussed in the paragraph before or will be added later as next step. Goal is to make the snipped more readable. As already mentioned above the complete code can be found on github. Ok lets start with the skeleton of our FactoryProcessor:\n@AutoService(Processor.class) public class FactoryProcessor extends AbstractProcessor { private Types typeUtils; private Elements elementUtils; private Filer filer; private Messager messager; private Map\u0026lt;String, FactoryGroupedClasses\u0026gt; factoryClasses = new LinkedHashMap\u0026lt;String, FactoryGroupedClasses\u0026gt;(); @Override public synchronized void init(ProcessingEnvironment processingEnv) { super.init(processingEnv); typeUtils = processingEnv.getTypeUtils(); elementUtils = processingEnv.getElementUtils(); filer = processingEnv.getFiler(); messager = processingEnv.getMessager(); } @Override public Set\u0026lt;String\u0026gt; getSupportedAnnotationTypes() { Set\u0026lt;String\u0026gt; annotataions = new LinkedHashSet\u0026lt;String\u0026gt;(); annotataions.add(Factory.class.getCanonicalName()); return annotataions; } @Override public SourceVersion getSupportedSourceVersion() { return SourceVersion.latestSupported(); } @Override public boolean process(Set\u0026lt;? extends TypeElement\u0026gt; annotations, RoundEnvironment roundEnv) { ... } } In the first line you see @AutoService(Processor.class). What\u0026rsquo;s that? It\u0026rsquo;s an annotation from another annotation processor. This AutoService annotation processor has been developed by Google and generates the META-INF/services/javax.annotation.processing.Processor file. Yes, you read correctly. We can use annotation processors in our annotation processor. Handy, isn\u0026rsquo;t it? In getSupportedAnnotationTypes() we specify that @Factory is processed by this processor.\nElements and TypeMirrors In init() we retrieve a reference to\n Elements: A utils class to work with Element classes (more information later). Types: A utils class to work with TypeMirror (more information later) Filer: Like the name suggests with Filer you can create files.  In annotation processing we are scanning java source code files. Every part of the source code is a certain type of Element. In other words: Element represents a program element such as a package, class, or method. Each element represents a static, language-level construct. In the following example I have added comments to clarify that:\npackage com.example;\t// PackageElement  public class Foo {\t// TypeElement  private int a;\t// VariableElement \tprivate Foo other; // VariableElement  public Foo () {} // ExecuteableElement  public void setA ( // ExecuteableElement \tint newA\t// TypeElement \t) {} } You have to change the way you see source code. It\u0026rsquo;s just structured text. It\u0026rsquo;s not executable. You can think of it like a XML file you try to parse (or an abstract syntax tree in compiler construction). Like in XML parsers there is some kind of DOM with elements. You can navigate from Element to it\u0026rsquo;s parent or child Element.\nFor instance if you have a TypeElement representing public class Foo you could iterate over its children like that:\nTypeElement fooClass = ... ; for (Element e : fooClass.getEnclosedElements()){ // iterate over children \tElement parent = e.getEnclosingElement(); // parent == fooClass } As you see Elements are representing source code. TypeElement represent type elements in the source code like classes. However, TypeElement does not contain information about the class itself. From TypeElement you will get the name of the class, but you will not get information about the class like the superclass. This is kind of information are accessible through a TypeMirror. You can access the TypeMirror of an Element by calling element.asType().\nSearching For @Factory So lets implement the process() method step by step. First we start with searching for classes annotated with @Factory:\n@AutoService(Processor.class) public class FactoryProcessor extends AbstractProcessor { private Types typeUtils; private Elements elementUtils; private Filer filer; private Messager messager; private Map\u0026lt;String, FactoryGroupedClasses\u0026gt; factoryClasses = new LinkedHashMap\u0026lt;String, FactoryGroupedClasses\u0026gt;(); ... @Override public boolean process(Set\u0026lt;? extends TypeElement\u0026gt; annotations, RoundEnvironment roundEnv) { // Itearate over all @Factory annotated elements  for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) { ... } } ... } No rocket science here. roundEnv.getElementsAnnotatedWith(Factory.class)) returnes a list of Elements annotated with @Factory. You may have noted that I have avoited saying \u0026ldquo;returns list of classes annotated with @Factory\u0026rdquo;, because it really returns list of Element. Remember: Element can be a class, method, variable etc. So what we have to do next is to check if the Element is a class:\n@Override public boolean process(Set\u0026lt;? extends TypeElement\u0026gt; annotations, RoundEnvironment roundEnv) { for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) { // Check if a class has been annotated with @Factory  if (annotatedElement.getKind() != ElementKind.CLASS) { ... } } ... } What\u0026rsquo;s going on here? We want to ensure that only elements of type class are processed by our processor. Previously we have learned that classes are TypeElements. So why don\u0026rsquo;t we check if (! (annotatedElement instanceof TypeElement) ). That\u0026rsquo;s a wrong assumption because interfaces are TypeElement as well. So in annoation processing you should avoid instanceof but rather us ElementKind or TypeKind with TypeMirror.\nError Handling In init() we also retrieve a reference to Messager. A Messager provides the way for an annotation processor to report error messages, warnings and other notices. It\u0026rsquo;s not a logger for you, the developer of the annotation processor (even thought it can be used for that during development of the processor). Messager is used to write messages to the third party developer who uses your annotation processor in their projects. There are different levels of messages described in the official docs. Very important is Kind.ERROR because this kind of message is used to indicate that our annotation processor has failed processing. Probably the third party developer is misusing our @Factory annotation (i.e. annotated an interface with @Factory). The concept is a little bit different from traditional java application where you would throw an Exception. If you throw an exception in process() then the jvm which runs annotation processing crashs (like any other java application) and the third party developer who is using our FactoryProcessor will get an error from javac with a hardly understandable Exception, because it contains the stacktrace of FactoryProcessor. Therefore Annotation Processor has this Messager class. It prints a pretty error message. Additionaly, you can link to the element who has raised this error. In modern IDEs like IntelliJ the third party developer can click on this error message and the IDE will jump to the source file and line of the third party developers project where the error source is.\nBack to implementing the process() method. We raise a error message if the user has annotated a non class with @Factory:\npublic boolean process(Set\u0026lt;? extends TypeElement\u0026gt; annotations, RoundEnvironment roundEnv) { for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) { // Check if a class has been annotated with @Factory  if (annotatedElement.getKind() != ElementKind.CLASS) { error(annotatedElement, \u0026#34;Only classes can be annotated with @%s\u0026#34;, Factory.class.getSimpleName()); return true; // Exit processing  } ... } private void error(Element e, String msg, Object... args) { messager.printMessage( Diagnostic.Kind.ERROR, String.format(msg, args), e); } } To get the message of the Messager displayed it\u0026rsquo;s important that the annotation processor has to complete without crashing. That\u0026rsquo;s why we return after having called error(). If we don\u0026rsquo;t return here process() will continue running since messager.printMessage( Diagnostic.Kind.ERROR) does not stop the process. So it\u0026rsquo;s very likely that if we don\u0026rsquo;t return after printing the error we will run in an internal NullPointerException etc. if we continue in process(). As said before, the problem is that if an unhandled exception is thrown in process() javac will print the stacktrace of the internal NullPointerException and NOT your error message of Messager.\nDatamodel Before we continue with checking if classes annotated with @Factory observe our five rules (see above) we are going to introduce data structures which makes it easier for us to continue. Sometimes the problem or processor seems to be so simple that programmers tend to write the whole processor in a procedural manner. But you know what? An Annotation Processor is still a java application. So use object oriented programming, interfaces, design patterns and anything else you would use in any other java application!\nOur FactoryProcessor is quite simple but there are some information we want to store as objects. With FactoryAnnotatedClass we store the annotated class data like qualified class name along with the data of the @Factory annotation itself. So we store the TypeElement and evaluate the @Factory annotation:\npublic class FactoryAnnotatedClass { private TypeElement annotatedClassElement; private String qualifiedSuperClassName; private String simpleTypeName; private String id; public FactoryAnnotatedClass(TypeElement classElement) throws IllegalArgumentException { this.annotatedClassElement = classElement; Factory annotation = classElement.getAnnotation(Factory.class); id = annotation.id(); if (StringUtils.isEmpty(id)) { throw new IllegalArgumentException( String.format(\u0026#34;id() in @%s for class %s is null or empty! that\u0026#39;s not allowed\u0026#34;, Factory.class.getSimpleName(), classElement.getQualifiedName().toString())); } // Get the full QualifiedTypeName  try { Class\u0026lt;?\u0026gt; clazz = annotation.type(); qualifiedSuperClassName = clazz.getCanonicalName(); simpleTypeName = clazz.getSimpleName(); } catch (MirroredTypeException mte) { DeclaredType classTypeMirror = (DeclaredType) mte.getTypeMirror(); TypeElement classTypeElement = (TypeElement) classTypeMirror.asElement(); qualifiedSuperClassName = classTypeElement.getQualifiedName().toString(); simpleTypeName = classTypeElement.getSimpleName().toString(); } } /** * Get the id as specified in {@link Factory#id()}. * return the id */ public String getId() { return id; } /** * Get the full qualified name of the type specified in {@link Factory#type()}. * * @return qualified name */ public String getQualifiedFactoryGroupName() { return qualifiedSuperClassName; } /** * Get the simple name of the type specified in {@link Factory#type()}. * * @return qualified name */ public String getSimpleFactoryGroupName() { return simpleTypeName; } /** * The original element that was annotated with @Factory */ public TypeElement getTypeElement() { return annotatedClassElement; } } Lot of code, but the most important thing happens ins the constructor where you find the following lines of code:\nFactory annotation = classElement.getAnnotation(Factory.class); id = annotation.id(); // Read the id value (like \u0026#34;Calzone\u0026#34; or \u0026#34;Tiramisu\u0026#34;)  if (StringUtils.isEmpty(id)) { throw new IllegalArgumentException( String.format(\u0026#34;id() in @%s for class %s is null or empty! that\u0026#39;s not allowed\u0026#34;, Factory.class.getSimpleName(), classElement.getQualifiedName().toString())); } Here we access the @Factory annotation and check if the id is not empty. We will throw an IllegalArgumentException if id is empty. You may be confused now because previously we said that we are not throwing exceptions but rather use Messager. That\u0026rsquo;s still correct. We throw an exception here internally and we will catch that one in process() as you will see later. We do that for two reasons:\n I want to demonstrate that you should still code like in any other java application. Throwing and catching exceptions is considered as good practice in java. If we want to print a message right from FactoryAnnotatedClass we also have to pass the Messager and as already mentioned in \u0026ldquo;Error Handling\u0026rdquo; (scroll up) the processor has to terminate successfully to make Messager print the error message. So if we would write an error message by using Messager how do we \u0026ldquo;notify\u0026rdquo; process() that an error has occurred? The easiest and from my point of view most intuitive way is to throw an Exception and let process() chatch this one.  Next we want to get the type field of the @Factory annotation. We are interessted in the full qualified name.\ntry { Class\u0026lt;?\u0026gt; clazz = annotation.type(); qualifiedGroupClassName = clazz.getCanonicalName(); simpleFactoryGroupName = clazz.getSimpleName(); } catch (MirroredTypeException mte) { DeclaredType classTypeMirror = (DeclaredType) mte.getTypeMirror(); TypeElement classTypeElement = (TypeElement) classTypeMirror.asElement(); qualifiedGroupClassName = classTypeElement.getQualifiedName().toString(); simpleFactoryGroupName = classTypeElement.getSimpleName().toString(); } That\u0026rsquo;s a little bit tricky, because the type is java.lang.Class. That means, that this is a real Class object. Since annotation processing runs before compiling java source code we have to consider two cases:\n The class is already compiled: This is the case if a third party .jar contains compiled .class files with @Factory annotations. In that case we can directly access the Class like we do in the try-block. The class is not compiled yet: This will be the case if we try to compile our source code which has @Factory annotations. Trying to access the Class directly throws a MirroredTypeException. Fortunately MirroredTypeException contains a TypeMirror representation of our not yet compiled class. Since we know that it must be type of class (we have already checked that before) we can cast it to DeclaredType and access TypeElement to read the qualified name.  Alright, now we need one more datastructure named FactoryGroupedClasses which basically groups all FactoryAnnotatedClasses together.\npublic class FactoryGroupedClasses { private String qualifiedClassName; private Map\u0026lt;String, FactoryAnnotatedClass\u0026gt; itemsMap = new LinkedHashMap\u0026lt;String, FactoryAnnotatedClass\u0026gt;(); public FactoryGroupedClasses(String qualifiedClassName) { this.qualifiedClassName = qualifiedClassName; } public void add(FactoryAnnotatedClass toInsert) throws IdAlreadyUsedException { FactoryAnnotatedClass existing = itemsMap.get(toInsert.getId()); if (existing != null) { throw new IdAlreadyUsedException(existing); } itemsMap.put(toInsert.getId(), toInsert); } public void generateCode(Elements elementUtils, Filer filer) throws IOException { ... } } As you see it\u0026rsquo;s basically just a Map\u0026lt;String, FactoryAnnotatedClass\u0026gt;. This map is used to map an @Factory.id() to FactoryAnnotatedClass. We have chosen Map because we want to ensure that each id is unique. That can be easily done with a map lookup. generateCode() will be called to generate the Factory code (discussed later).\nMatching Criteria Let\u0026rsquo;s proceed with the implementation of process(). Next we want to check if the annotated class has at least one public constructor, is not an abstract class, inherits the specified type and is a public class (visibility):\npublic class FactoryProcessor extends AbstractProcessor { @Override public boolean process(Set\u0026lt;? extends TypeElement\u0026gt; annotations, RoundEnvironment roundEnv) { for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) { ... // We can cast it, because we know that it of ElementKind.CLASS  TypeElement typeElement = (TypeElement) annotatedElement; try { FactoryAnnotatedClass annotatedClass = new FactoryAnnotatedClass(typeElement); // throws IllegalArgumentException  if (!isValidClass(annotatedClass)) { return true; // Error message printed, exit processing  } } catch (IllegalArgumentException e) { // @Factory.id() is empty  error(typeElement, e.getMessage()); return true; } ... } private boolean isValidClass(FactoryAnnotatedClass item) { // Cast to TypeElement, has more type specific methods  TypeElement classElement = item.getTypeElement(); if (!classElement.getModifiers().contains(Modifier.PUBLIC)) { error(classElement, \u0026#34;The class %s is not public.\u0026#34;, classElement.getQualifiedName().toString()); return false; } // Check if it\u0026#39;s an abstract class  if (classElement.getModifiers().contains(Modifier.ABSTRACT)) { error(classElement, \u0026#34;The class %s is abstract. You can\u0026#39;t annotate abstract classes with @%\u0026#34;, classElement.getQualifiedName().toString(), Factory.class.getSimpleName()); return false; } // Check inheritance: Class must be childclass as specified in @Factory.type();  TypeElement superClassElement = elementUtils.getTypeElement(item.getQualifiedFactoryGroupName()); if (superClassElement.getKind() == ElementKind.INTERFACE) { // Check interface implemented  if (!classElement.getInterfaces().contains(superClassElement.asType())) { error(classElement, \u0026#34;The class %s annotated with @%s must implement the interface %s\u0026#34;, classElement.getQualifiedName().toString(), Factory.class.getSimpleName(), item.getQualifiedFactoryGroupName()); return false; } } else { // Check subclassing  TypeElement currentClass = classElement; while (true) { TypeMirror superClassType = currentClass.getSuperclass(); if (superClassType.getKind() == TypeKind.NONE) { // Basis class (java.lang.Object) reached, so exit  error(classElement, \u0026#34;The class %s annotated with @%s must inherit from %s\u0026#34;, classElement.getQualifiedName().toString(), Factory.class.getSimpleName(), item.getQualifiedFactoryGroupName()); return false; } if (superClassType.toString().equals(item.getQualifiedFactoryGroupName())) { // Required super class found  break; } // Moving up in inheritance tree  currentClass = (TypeElement) typeUtils.asElement(superClassType); } } // Check if an empty public constructor is given  for (Element enclosed : classElement.getEnclosedElements()) { if (enclosed.getKind() == ElementKind.CONSTRUCTOR) { ExecutableElement constructorElement = (ExecutableElement) enclosed; if (constructorElement.getParameters().size() == 0 \u0026amp;\u0026amp; constructorElement.getModifiers() .contains(Modifier.PUBLIC)) { // Found an empty constructor  return true; } } } // No empty constructor found  error(classElement, \u0026#34;The class %s must provide an public empty default constructor\u0026#34;, classElement.getQualifiedName().toString()); return false; } } We have added a method isValidClass() and it checks if our rules are complied:\n Class must be public: classElement.getModifiers().contains(Modifier.PUBLIC) Class can not be abstract: classElement.getModifiers().contains(Modifier.ABSTRACT) Class must be subclass or implement the Class as specified in @Factoy.type(). First we use elementUtils.getTypeElement(item.getQualifiedFactoryGroupName()) to create a Element of the passed Class (@Factoy.type()). Yes you got it, you can create TypeElement (with TypeMirror) just by knowing the qualified class name. Next we check if it\u0026rsquo;s an interface or a class: superClassElement.getKind() == ElementKind.INTERFACE. So we have two cases: If it\u0026rsquo;s an interfaces then classElement.getInterfaces().contains(superClassElement.asType()). If it\u0026rsquo;s a class, then we have to scan the inheritance hierarchy with calling currentClass.getSuperclass(). Note that this check could also be done with typeUtils.isSubtype(). Class must have a public empty constructor: So we iterate over all enclosed elements classElement.getEnclosedElements() and check for ElementKind.CONSTRUCTOR, Modifier.PUBLIC and constructorElement.getParameters().size() == 0  If these conditions are fulfilled isValidClass() returns true, otherwise it prints a error message and returns false.\nGrouping The Annotated Classes Once we have checked isValidClass() we continue with adding FactoryAnnotatedClass to the corresponding FactoryGroupedClasses as follows:\npublic class FactoryProcessor extends AbstractProcessor { private Map\u0026lt;String, FactoryGroupedClasses\u0026gt; factoryClasses = new LinkedHashMap\u0026lt;String, FactoryGroupedClasses\u0026gt;(); @Override public boolean process(Set\u0026lt;? extends TypeElement\u0026gt; annotations, RoundEnvironment roundEnv) { ... try { FactoryAnnotatedClass annotatedClass = new FactoryAnnotatedClass(typeElement); // throws IllegalArgumentException  if (!isValidClass(annotatedClass)) { return true; // Error message printed, exit processing  } // Everything is fine, so try to add  FactoryGroupedClasses factoryClass = factoryClasses.get(annotatedClass.getQualifiedFactoryGroupName()); if (factoryClass == null) { String qualifiedGroupName = annotatedClass.getQualifiedFactoryGroupName(); factoryClass = new FactoryGroupedClasses(qualifiedGroupName); factoryClasses.put(qualifiedGroupName, factoryClass); } // Throws IdAlreadyUsedException if id is conflicting with  // another @Factory annotated class with the same id  factoryClass.add(annotatedClass); } catch (IllegalArgumentException e) { // @Factory.id() is empty --\u0026gt; printing error message  error(typeElement, e.getMessage()); return true; } catch (IdAlreadyUsedException e) { FactoryAnnotatedClass existing = e.getExisting(); // Already existing  error(annotatedElement, \u0026#34;Conflict: The class %s is annotated with @%s with id =\u0026#39;%s\u0026#39; but %s already uses the same id\u0026#34;, typeElement.getQualifiedName().toString(), Factory.class.getSimpleName(), existing.getTypeElement().getQualifiedName().toString()); return true; } } ... } Code Generation We have collected all classes annotated with @Factory stored as FactoryAnnotatedClass and grouped into FactoryGroupedClasses. Now we are going to generate java files for each Factory:\n@Override public boolean process(Set\u0026lt;? extends TypeElement\u0026gt; annotations, RoundEnvironment roundEnv) { ... try { for (FactoryGroupedClasses factoryClass : factoryClasses.values()) { factoryClass.generateCode(elementUtils, filer); } } catch (IOException e) { error(null, e.getMessage()); } return true; } Writing a java file is pretty the same as writing any other file in java. We use an Writer provided by Filer. We could write our generated code as concatination of Strings. Fortunately, Square Inc. well known for plenty awesome open source projects gives us with JavaWriter a high level library for generating Java Code:\npublic class FactoryGroupedClasses { /** * Will be added to the name of the generated factory class */ private static final String SUFFIX = \u0026#34;Factory\u0026#34;; private String qualifiedClassName; private Map\u0026lt;String, FactoryAnnotatedClass\u0026gt; itemsMap = new LinkedHashMap\u0026lt;String, FactoryAnnotatedClass\u0026gt;(); ... public void generateCode(Elements elementUtils, Filer filer) throws IOException { TypeElement superClassName = elementUtils.getTypeElement(qualifiedClassName); String factoryClassName = superClassName.getSimpleName() + SUFFIX; JavaFileObject jfo = filer.createSourceFile(qualifiedClassName + SUFFIX); Writer writer = jfo.openWriter(); JavaWriter jw = new JavaWriter(writer); // Write package  PackageElement pkg = elementUtils.getPackageOf(superClassName); if (!pkg.isUnnamed()) { jw.emitPackage(pkg.getQualifiedName().toString()); jw.emitEmptyLine(); } else { jw.emitPackage(\u0026#34;\u0026#34;); } jw.beginType(factoryClassName, \u0026#34;class\u0026#34;, EnumSet.of(Modifier.PUBLIC)); jw.emitEmptyLine(); jw.beginMethod(qualifiedClassName, \u0026#34;create\u0026#34;, EnumSet.of(Modifier.PUBLIC), \u0026#34;String\u0026#34;, \u0026#34;id\u0026#34;); jw.beginControlFlow(\u0026#34;if (id == null)\u0026#34;); jw.emitStatement(\u0026#34;throw new IllegalArgumentException(\\\u0026#34;id is null!\\\u0026#34;)\u0026#34;); jw.endControlFlow(); for (FactoryAnnotatedClass item : itemsMap.values()) { jw.beginControlFlow(\u0026#34;if (\\\u0026#34;%s\\\u0026#34;.equals(id))\u0026#34;, item.getId()); jw.emitStatement(\u0026#34;return new %s()\u0026#34;, item.getTypeElement().getQualifiedName().toString()); jw.endControlFlow(); jw.emitEmptyLine(); } jw.emitStatement(\u0026#34;throw new IllegalArgumentException(\\\u0026#34;Unknown id = \\\u0026#34; + id)\u0026#34;); jw.endMethod(); jw.endType(); jw.close(); } }  Tipp: Since JavaWriter is very very popular there are many other processors, libraries and tools depending on JavaWriter. This maybe will cause problems if you use dependency management tools like maven or gradle if one library depends on a newer version of JavaWriter as another one. Therefore I recommend to copy and repackage JavaWriter directly into your annotation processor code base (it\u0026rsquo;s just one java file).\n Update: Use JavaPoet instead of JavaWriter.\nProcessing Rounds Annotation Processing maybe takes more than one processing round. The official javadoc define processing like as follows:\n Annotation processing happens in a sequence of rounds. On each round, a processor may be asked to process a subset of the annotations found on the source and class files produced by a prior round. The inputs to the first round of processing are the initial inputs to a run of the tool; these initial inputs can be regarded as the output of a virtual zeroth round of processing.\n A simpler definition: A processing round is calling process() of an annotation processor. To stick with our factory sample: FactoryProcessor is instantiated once (new Processor object is not created for each round), but process() can be called multiple times, if new source files has been created. Sounds a little bit strange, doesn\u0026rsquo;t it? The reason is that, the generated source code files could contain @Factory annotated classes as well, which would be processed by FactoryProcessor.\nFor example our PizzaStore sample will be processed in 3 rounds:\n   Round Input Output     1 CalzonePizza.java, Tiramisu.java, Meal.java, PizzaStore.java MealFactory.java   2 MealFactory.java none   3 none none    There is another reason why I\u0026rsquo;m explaining processing rounds. If you look at our FactoryProcessor code you see that we collect data and store them in private field Map\u0026lt;String, FactoryGroupedClasses\u0026gt; factoryClasses. In first round we detect MagheritaPizza, CalzonePizza and Tiramisu and we generate a file MealFactory.java. In the second round we take MealFactory as input. Since there is no @Factory annotation in MealFactory no data will be collected, we would not expect to get an error. However we get one:\nAttempt to recreate a file for type com.hannesdorfmann.annotationprocessing101.factory.MealFactory\nThe problem is that we never clear factoryClasses. That means, that in round two process() has still stored data from the first round and wants to generate the same file as round 1 already did which will cause this error. In our case, we know that only in the first round we will detect @Factory annotated classes and therefore we can simply fix it like that:\n@Override public boolean process(Set\u0026lt;? extends TypeElement\u0026gt; annotations, RoundEnvironment roundEnv) { try { for (FactoryGroupedClasses factoryClass : factoryClasses.values()) { factoryClass.generateCode(elementUtils, filer); } // Clear to fix the problem  factoryClasses.clear(); } catch (IOException e) { error(null, e.getMessage()); } ... return true; } I know there are other ways to deal with that problem i.e. we could also set a boolean flag etc. The point is: Keep in mind that annotation processing is done in multiple processing rounds and you can not override or recreate already generated source files.\nSeparation of processor and annotation If you have looked at the git repository of our factory processor you will see that we have organized our repository in two maven modules. We did that, because we want to give the user of our Factory example the possibility to compile just the annotation in his own project and to include the processor module just for compilation. Confused? I.e. if we would have just one single artifact another developer who wants to use our factory processor in his own project would include both the @Factory annotation and the whole FactoryProcessor code (incl. FactoryAnnotatedClass and FactoryGroupedClasses) in his project build. I\u0026rsquo;m pretty sure that the other one won\u0026rsquo;t have the processor class in his compiled project. If you are an android developer maybe you have heard of the 65k method limit (a android .dex file can only address 65.000 methods). If we would have used guava in FactoryProcessor and would provide just a single artifact containing annotation and processor code, then the android apk would not only contain FactoryProcessor code but the whole guava code as well. Guava has about 20.000 methods. Therefore a separation of annotation and processor makes sense.\nInstantiation Of Generated Classes As you have seen in PizzaStore sample the generated class MealFactory is a normal java class as any other handwritten class. Furthermore, you have to instantiate it by hand (like any other java object).\npublic class PizzaStore { private MealFactory factory = new MealFactory(); public Meal order(String mealName) { return factory.create(mealName); } ... } If you are an android developer you should be familiar with a great annotation processors called ButterKnife. In ButterKnife you annotate android Views with @InjectView. The ButterKnifeProcessor generates a class MyActivity$$ViewInjector. But in ButterKnife you don\u0026rsquo;t have to instantiate the ButterKnife injector by hand by calling new MyActivity$$ViewInjector() but you can use Butterknife.inject(activity). ButterKnife internally uses reflections to instantiate MyActivity$$ViewInjector():\ntry { Class\u0026lt;?\u0026gt; injector = Class.forName(clsName + \u0026#34;$$ViewInjector\u0026#34;); } catch (ClassNotFoundException e) { ... } But is reflection not slow and didn\u0026rsquo;t we tried to get rich of reflections performance issues by using annotation processing which generates native code? Yes, reflection brings perfomance issues. However, it speeds up development because the developer has not to instantiate objects by hand. ButterKnife uses a HashMap to \u0026ldquo;cache\u0026rdquo; the instantiated objects. So MyActivity$$ViewInjector is only instantiated once by using reflections. Next time MyActivity$$ViewInjector is needed it will be retrieved from the HashMap.\nFragmentArgs works similar to ButterKnife. It uses reflection to instantiate things that otherwise the developer who uses FragmentArgs has to do manually. FragmentArgs generates a special \u0026ldquo;lookup\u0026rdquo; class while annotation processing which is kind of HashMap. So the whole FragmentArgs library executes only one reflection call at the very first time to instantiate this special HashMap class. Once this class is instantiated with Class.forName() fragment arguments injection runs in native java code.\nAll in all it\u0026rsquo;s up to you (the developer of annotation processor) to find a good compromise between reflection and usability for other users of your annotation processor.\nConclusion I hope you have a deeper understanding of annotation processing now. I have to say it once again: Annotation processing is a very powerful tool and helps reducing writing boiler plate code. I also want to mention that with annotation processors you can do much more complex things than I show in this simple factory sample, for example type erasure on Generics, because annotation processing happens before type erasure. As you have seen there are two common problems you have to deal when writing: First, if you want to use ElementUtils, TypeUtils and Messager in other classes then you have to pass them as parameters somehow. In AnnotatedAdapter, one of my annotation processors for android, I tried to solve that problem with Dagger (Dependency Injection). It feels a little bit to much overhead for such a simple processor, however it has worked well. The second thing you have to deal is you have to make \u0026ldquo;queries\u0026rdquo; for Elements. As I said before, working with elements can be seen as parsing XML or HTML. For HTML you can use jQuery. Something similar to jQuery for annotation processing would be really awesome. Please comment below if you know any similar library.\nPlease note that parts of the code of FactoryProcessor has some edges and pitfalls. These \u0026ldquo;mistakes\u0026rdquo; are placed explicit by me to struggle through them as I explain common mistakes while writing annotation processors (like \u0026ldquo;Attempt to recreate a file\u0026rdquo;). If you start writing your own annotation processor based on FactoryProcessor DON\u0026rsquo;T copy and paste this pitfalls. Instead you should avoid them from the very beginning.\nIn a future blog post (Annotation Processing 102) I will write about unit testing annotation processors. However, my next blog post will be about software architecture in android. Stay tuned.\nUpdate I gave a talk about Annotation Processing at droidcon Germany 2015. The video of my talk can be found at youtube:\n  ","permalink":"https://hannesdorfmann.com/annotation-processing/annotationprocessing101/","tags":null,"title":"Annotation Processing 101"},{"categories":["Android","Annotation Processor"],"contents":"With FragmentArgs and ParcelablePlease I have already shown that Annotation Processor is really helpful to speedup development by reducing writing boilerplate code. Regarding Android I found one scenario where I find myself writing nearly the same code ever and ever again. I\u0026rsquo;m looking at you Adapter with your ViewHolders, layout inflating code and view types. In this blog post I want to announce AnnotatedAdapter\nIn nearly every app you will find a RecyclerView (or ListView or GridView). Under the hood Adapter classes are used to inflate and fill the view cell of RecyclerView and to bind the data to it\u0026rsquo;s graphical representation (view cell) within the RecyclerView. There are serval things you as developer have to implement:\n Inflate xml layout Create a ViewHolder class and write findViewById() for every subview in it Bind the model to the view holder  Furthermore not every view cell should look the same and you probably have multiple layouts for your view cells. So called view types, represented as integer constant in adapters code, are used to distinguish different type of view cells. Fortunately in RecyclerView (unlikely ListView) you don\u0026rsquo;t have to implement the recycling part by hand. However, you have to implement those three steps from above (infalte layout, ViewHolder, bind model) for each view type in your adapter.\nAnnotatedAdapter At this point I started thinking to myself: \u0026ldquo;could that be generated with an annotation processor?\u0026quot; Finally I came to the conclusion: Yes it can and here is how this will be done by using AnnotatedAdapter.\nLets assume we want to display two different view cells in a RecyclerView, one with just a TextView and one with a TextView and an ImageView (icon). I know for such simple layouts we would not need two different view types but could simply change ImageViews visibility. But lets keep this example simple. I just want to give you an idea of how AnnotatedAdapter works. So our model class looks like this;\nclass Item { public String text; public int iconRes = 0; // R.drawable.foo  public boolean hasIcon(){ return iconRes \u0026gt; 0; } } If Item has no icon then the iconRes will be 0. In this case we want to use the view type and layout with just one TextView. Otherwise we use the other layout (TextView and ImageView). The xml layouts look like this:\n\u0026lt;FrameLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;+@id/textView\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;+@id/iconImageView\u0026#34; android:layout_width=\u0026#34;20dp\u0026#34; android:layout_height=\u0026#34;20dp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;+@id/textView\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Every Adapter in AnnotatedAdapter must extend from SupportAnnotatedAdapter (for RecyclerView) or AbsListAnnotatedAdapter (for AbsListView widgets like ListView or GridView). This important because in this base adapters the generated code will be sticked together with your handwritten data-binding code and the internal view cell recycling mechanism.\nLet\u0026rsquo;s have a look at the complete Adapter by using AnnotatedAdapter. Afterwars we will go through the code line by line:\npublic class SampleAdapter extends SupportAnnotatedAdapter implements SampleAdapterBinder { @ViewType( layout = R.layout.cell_simple, views = @ViewField( type = TextView.class, name = \u0026#34;text\u0026#34;, id = R.id.textView ) ) public final int simpleRow = 0; @ViewType( layout = R.layout.cell_with_icon, views = { @ViewField( type = TextView.class, name = \u0026#34;text\u0026#34;, id = R.id.textView ), @ViewField( type = ImageView.class, name = \u0026#34;icon\u0026#34;, id = R.id.iconImageView ) } ) public final int iconRow = 1; private List\u0026lt;Item\u0026gt; items; public SampleAdapter(Context context, List\u0026lt;Item\u0026gt; items) { super(context); this.items = items; } @Override public int getItemCount() { return items == null ? 0 : items.size(); } @Override public int getItemViewType(int position) { if (items.get(postion).hasIcon()) return iconRow else return simpleRow; } } @Override public void bindViewHolder(SampleAdapterHolders.IconRowViewHolder vh, int position) { Item item = items.get(position); vh.text.setText(item.text); vh.icon.setImageResource(item.icon) } @Override public void bindViewHolder(SampleAdapterHolders.SimpleRowViewHolder vh, int position) { Item item = items.get(position); vh.text.setText(item.text); } } At first look you have noticed that there is less code. However AnnotatedAdapter can\u0026rsquo;t read your mind. Therefore we have to give some information by using @ViewType annotation. In short: less code, more annotations. With the @ViewType annotation we specify the view types integer constant, the xml layout we want to inflate for this view type and with @ViewField you define the view holder class. Have a look at the int iconRow = 1:\n@ViewType( layout = R.layout.cell_with_icon, views = { @ViewField( type = TextView.class, name = \u0026#34;text\u0026#34;, id = R.id.textView ), @ViewField( type = ImageView.class, name = \u0026#34;icon\u0026#34;, id = R.id.iconImageView ) } ) public final int iconRow = 1; AnnotatedAdapter will generate a view holder class called IconRowViewHolder that looks like this:\nclass IconRowViewHolder extends RecyclerView.ViewHolder { public TextView text; public ImageView icon; public RowWithPicViewHolder(View view) { super(view); text = (TextView) view.findViewById(R.id.textView); icon = (ImageView) view.findViewById(R.id.iconImageView); } }  @ViewField ( type = \u0026hellip; ) specifies the class of the view in the view holde @ViewField ( name = \u0026hellip; ) specifies the name of the field for this subview in the viewholder @ViewField ( id = \u0026hellip; ) specifies the id of to get the subview instance by using findViewById()  You can also specify non UI related fields (not bound by findViewById() ), for instance a OnClickListener, as part of the generated view holder. You can do that by using @Field like this:\n@ViewType( layout = R.layout.cell_with_icon, views = { @ViewField( type = TextView.class, name = \u0026#34;text\u0026#34;, id = R.id.textView ), @ViewField( type = ImageView.class, name = \u0026#34;icon\u0026#34;, id = R.id.iconImageView ) }, fields = { @Field( type = OnClickListener.class, name = \u0026#34;clickListener\u0026#34; ) } ) public final int iconRow = 1; Then the generated IconRowViewHolder contains this @Field as well:\nclass IconRowViewHolder extends RecyclerView.ViewHolder { public TextView text; public ImageView icon; public OnClickListener clickListener; public RowWithPicViewHolder(View view) { super(view); text = (TextView) view.findViewById(R.id.textView); icon = (ImageView) view.findViewById(R.id.iconImageView); } } Next you see two methods that you already know if you ever have written an Adapter by hand:\n getItemCount(): Returns the total number of items in the data set hold by the adapter getItemViewType(int position): Return the view type of the item at position for the purposes of view recycling  Last you notice that there are bindViewHolder() methods. In this methods you bind the data item to the view cell by using the corresponding ViewHolder. Where does this methods come from? This methods are defined in the interface SampleAdapterBinder. This interface is generated by AnnotatedAdapter by evaluating the @ViewType annotation. Hence SampleAdapter has to implement the interface SampleAdapterBinder.\n That\u0026rsquo;s all? That sounds to good to be true?\n Yes, that\u0026rsquo;s all, but there is one thing you have to know about android studio (I assume the most of you are using Android Studio): Since the interface AdapterBinder is generated at compile time this interface is not available when you start creating a brand new Adapter. The interface is available only after compiling at least once. Hence I would consider the following step as best practice when creating a brand new adpater class using AnnotatedAdapter:\n Create the new java file for your adapter and let the adapter class extends SupportAnnotatedAdapter. Define your view types by using @ViewType and @ViewField In Android Studio: Main Menu Bar -\u0026gt; Build -\u0026gt; Rebuild Project. This will force the compiler to generate the AdapterBinder interface. Let your adapter class implement the binder interface and implement all binder methods  I can guaranty that by following this instructions you will write your next adapter in less than 5 minutes (creating xml layouts excluded). Note that you have to trigger Build -\u0026gt; Rebuild Project only at the very first time you create a brand new adapter class. Once done you can change your adapters code, you can add or remove view types and the interface will be regenerated automatically every time you compile/install your app on your device.\nI need your help From my point of view AnnotatedAdapter reduces writing boilerplate code a lot. However, it\u0026rsquo;s not perfect, since you have to use @ViewField annotations to define the ViewHolder. I want to remove this and make AnnotatedAdapter by parse the xml layout files to retrieve all needed informations to generate the view holder classes. Unfortunately that\u0026rsquo;s not as simple as it sounds, but I\u0026rsquo;m sure that there are smarter people than me out there. If you have an idea of how to solve that problem please use this issue on github to get in touch with me.\nAnnotatedAdapter supports also AbsListView widgets, inheritance and other little features you may find useful. You can find more information about AnnotatedAdapter on github\n","permalink":"https://hannesdorfmann.com/android/annotatedadapter/","tags":["android","library"],"title":"AnnotatedAdapter"},{"categories":["Android","Annotation Processor"],"contents":"In my last blog post I have introduced FragmentArgs an Annotation Processor for Fragments that reduces writing boilerplate code. In this post I want to talk about a similar problem android developer face: Writing boilerplate code for Parcelable\n This post is part of a series of posts about useful annotation processors like FragmentArgs or AnnotatedAdapter\n Parcelable is a extreme fast way to serialize objects on Android. Unfortunately the developer has to implement both the Parcelable interface and the CREATOR for each model class. You may ask yourself: \u0026ldquo;Does not someone else could write that code for me?\u0026rdquo;. Annotation processing can be used to generate java code and it is possible to generate Parcelable code. There are already two good libraries that are doing this job: Parceler and AutoParcel. However I ended up by writing my own annotation processor called ParcelablePlease and I want to explain why.\nParceler Parceler seems to be the easiest way to make classes Parcelable. All you have to do is to annotate your class with @Parcel. However the class itself will not implement the Parcelable interface. The Parceler annotation processor creates a wrapper class for each @Parcel annotated class and this generated class implements Parcelable and is responsible to set the values of the real model class (annotated with @Parcel) and vice versa. Hence the model class itself is not an instance of Parcelable and you have to wrap and unwrap the real model class:\n@Parcel public class Example { String name; int age; public Example(){ /*Required empty bean constructor*/ } } // Write as Parcelable Bundle bundle = new Bundle(); bundle.putParcelable(\u0026#34;example\u0026#34;, Parcels.wrap(example)); // Read as Parcelable Example example = Parcels.unwrap(getIntent().getExtras().get(\u0026#34;example\u0026#34;)) The downside is that Parceler is not compatible with other libraries who require a Parcelable object like FragmentArgs does. That\u0026rsquo;s the reason why in the most of my apps I can\u0026rsquo;t use Parceler.\nAutoParcel AutoParcel is an annotation processor, inspired by Google\u0026rsquo;s AutoValue to generate parcelable classes. The idea of AutoValue is that you declare an abstract class with abstract methods. This abstract methods are detected by an annotation processor at compile time. Furthermore, the annotation processor creates a class that extends from this abstract class and implements the missing abstract methods (and generates the fields). Additionally AutoValue generates null-checks, toString(), hashCode(), equals() and other methods for you. Basically it does something similar like project lombok by using annotation processing instead of magic byte code manipulation (weaving). Like the name already suggests, AutoParcel does pretty the same with the goal to generate the Parcelable code for you. So a class using AutoParcel looks like this:\n@AutoParcel abstract class SomeModel implements Parcelable { abstract String name(); abstract List\u0026lt;SomeSubModel\u0026gt; subModels(); abstract Map\u0026lt;String, OtherSubModel\u0026gt; modelsMap(); static SomeModel create(String name, List\u0026lt;SomeSubModel\u0026gt; subModels, Map\u0026lt;String, OtherSubModel\u0026gt; modelsMap) { return new AutoParcel_SomeModel(name, subModels, modelsMap); } } As you can see SomeModel is an abstract class and the full implementation of this abstract class AutoParcel_SomeModel is generated by the annotation processor. This seems to be a very straightforward solution since SomeModel is a \u0026ldquo;real\u0026rdquo; Parcelable (unlikely Parcelers approach). I have to admit that I\u0026rsquo;m a big AutoValue fan and I use it quite often in backend applications. I was really excited to see this concept for Parcelable on Android. AutoParcel supports a lot of types, generics and inheritance. However there is one big issue with this approach that makes it not useable in my apps: You can\u0026rsquo;t easily use it with other frameworks where you have to annotate fields or methods like many json parsers require. In the most of the android apps I have written so far I parse json (with jackson or gson) and I want to make this classes Parcelable to pass them trough intents or as fragment arguments. There may be some workarounds but they seem to be not very handy. For example there is an ongoing discussion of how to parse with Gson an AutoParcel.The most promising solution is to write your own gson JsonDeserializer for each AutoValue generated class to map between SomeModel and the generated AutoValue_SomeModel. You could automate this step by writing an additional Annotation Processor for generating TypeAdapterFactory for gson. But it isn\u0026rsquo;t a handy solution and what about other third party libraries?\nUpdate: Since AutoValue 1.3 supports extensions AutoParcel is not needed anymore because you can directly use AutoValue with Parcelable extension and Gson extension.\nParcelablePlease At the end I ended up by writing a small Annotation Processor called ParcelablePlease. The goal was to support the most scenarios you face in real world apps. Hence it\u0026rsquo;s not that powerful as AutoValue is (I only spend few hours on this project), but it will directly implement the Parcelable interface on the model class to avoid to run into the same problems as Parceler or AutoParcel. Simply annotate your model class with @ParcelablePlease:\n@ParcelablePlease public class Model implements Parcelable { int id; String name; OtherModel otherModel; @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { ModelParcelablePlease.writeToParcel(this, dest, flags); } public static final Creator\u0026lt;Model\u0026gt; CREATOR = new Creator\u0026lt;Model\u0026gt;() { public Model createFromParcel(Parcel source) { Model target = new Model(); ModelParcelablePlease.readFromParcel(target, source); return target; } public Model[] newArray(int size) { return new Model[size]; } }; } Like you have seen above you have to write the code to connect the generated code (ModelParcelablePlease) with your Model class. I know that\u0026rsquo;s not what we want. So I was searching for a solution for not writing this boilerplate code. One option was to use compile time code weaving like you can do with afterburn. However, I was not convinced that this would be the right direction. I have a bad vibe about byte code manipulation. I don\u0026rsquo;t like this \u0026ldquo;magic\u0026rdquo; things, because it\u0026rsquo;s not easy to debug them. So at the end I came to a unspectacular but efficient solution. I wrote an intellij plugin that generates the CREATOR and Parcelable code where the Model class gets connected to the generated code (Annotation Processor). It\u0026rsquo;s some kind of hybrid solution: you only have to run the IntelliJ plugin to generate the @Parcelable Annotation, the CREATOR and writeToParcel(). The serialization code is generated by the annotation processor. Adding or removing a field does not mean you have to rerun the IntelliJ plugin because the annotation processor is responsible for serializing and deserializing all class fields.\nLike mentioned before ParcelablePlease has been built with the aim to make it work in real applications. Therefore in ParcelabelPlease you can specify which fields you want to make parcelable by using @ParcelableThisPlease and @ParcelableNoThanks as well as setting default configurations. Another feature for edge cases is @Bagger. With @Bagger you provide a implementation of how a field should be serialized.\nFor example:\npublic class DateBagger implements ParcelBagger\u0026lt;Date\u0026gt; { @Override public void write(Date value, Parcel out, int flags) { if (value == null) { out.writeLong(-1); } else { out.writeLong(value.getTime()); } } @Override public Date read(Parcel in) { long timeMillis = in.readLong(); if (timeMillis == -1) { return null; } return new Date(timeMillis); } } @ParcelablePlease public class Person implements Parcelable { int id; String name; @Bagger(DateBagger.class) Date date; } Note that java.util.Date is already supported by ParcelablePlease. The example above is just to give you an idea of how a implementation of @Bagger and ParcelBagger could look like. More inforation can be found at the ParcelablePlease github site\nConclusion Annotation Processor can reduce writing boilerplate code to make a class Parcelable. AutoParcel is a very promising approach. Unfortunately there are issues with other third party libraries. I really would love to use AutoParcel but right now (from my point of view) it\u0026rsquo;s not the best solution for the most of my apps. In the meantime you may find ParcelablePlase useful. However, I will keep an eye on you AutoParcel!\nIn my next post I want to talk about AnnotatedAdapter, an annotation processor for RecyclerView\u0026rsquo;s adapter.\n","permalink":"https://hannesdorfmann.com/android/parcelableplease/","tags":["android","library"],"title":"ParcelablePlease"},{"categories":["Android","Annotation Processor"],"contents":"Developing for Android is sometimes painful. You have to write lot of code to do simple things like setting up a Fragment. Fortunately java supports a powerful tool: Annotation Processors\n This post is part of a series of posts about useful annotation processors like ParcelablePlease or AnnotatedAdapter\n The Problem with Fragments is that you have to set arguments (the parameters) for a fragment to make them work correctly. Many new android developers that write the first fragment do something like this:\npublic class MyFragment extends Fragment { private int id; private String title; public static MyFragment newInstance(int id, String title) { MyFragment f = new MyFragment(); f.id = id; f.title = title; return f; } @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { Toast.makeText(getActivity(), \u0026#34;Hello \u0026#34; + title.substring(0, 3), Toast.LENGTH_SHORT).show(); } }  What\u0026rsquo;s wrong with that? I have tested it on my device and it worked like a charm?\n It may have worked, but did you try to rotate your device from portrait to landscape? Your app will crash with NullPointerException as soon as you try to access id or title .\n It\u0026rsquo;s ok, my app is locked in portrait. So I will never run into this problem.\n You will! Android is a real multitasking operating system. Multiple apps run at the same time and the android os will destroy activities (and the containing fragments) if memory is needed. Probably you will never notice that during daily app development. However, once the app is published in the play store you will get notified that your app is crashing and you may wonder why. Your app users use multiple apps at the same time and it\u0026rsquo;s very likely that your app is going to be destroyed in the background. Example: a user of your app opens your app and MyFrament is displayed on screen. Next the user will press the home button (your app is going in the background) and opens any other app. Your app will be destroyed in the background to free memory. Later on the user comes back to your app, for example by pressing the multitasking button. So what does Android do right now? Android restores the previous app state and restores MyFragment and that\u0026rsquo;s the problem. The fragment tries to access title which is null because it had not been stored persistently.\n I see, so I have to save them in onSaveInstanceState(Bundle)?\n NO. The official docs are a little bit unclear, but onSaveInstanceState(Bundle) should be used exactly the same way you do with Activity.onSaveInstanceState(Bundle): you use this method to save the instance state \u0026ldquo;temporarly\u0026rdquo;, for instance to handle screen orientation changes (from portrait to landscape and vice versa). That means the fragments instance state is not stored persistently which is required when the app is killed in the background and restored when it comes back to the foreground again. It\u0026rsquo;s pretty the same as activities work: Activity.onSaveInstanceState(Bundle) is used for \u0026ldquo;temporarly\u0026rdquo; saving the instance state, whereas the long persistent parameters are passed through the intents extra data.\n So should I save these Fragment arguments in the Activities Intent?\n No, Fragment has it\u0026rsquo;s own mechanism for this. There are two methods: Fragment.setArguments(Bundle) and Fragment.getArguments() and you have to use these methods to ensure that the arguments will be stored persistently, even if the app is destroyed and restored. But that\u0026rsquo;s the painful part I have mentioned above. It\u0026rsquo;s a lot of code you have to write. First, you have to create a Bundle, then you have to set the key / value pairs and finally to call Fragment.setArguments(). Unfortunately you are not done yet but you have to read the values out of the Bundle with Fragment.getArguments(). Something like this:\npublic class MyFragment extends Fragment { private static String KEY_ID =\u0026#34;key.id\u0026#34;; private static String KEY_TITLE = \u0026#34;key.title\u0026#34;; private int id; private String title; public static MyFragment newInstance(int id, String title) { MyFragment f = new MyFragment(); Bundle b = new Bundle(); b.putInt(KEY_ID, id); b.putString(KEY_TITLE, title); f.setArguments(b); return f; } @Override public void onCreate(Bundle savedInstanceState) { // onCreate it\u0026#39;s a good point to read the arguments  Bundle b = getArguments(); this.id = b.getInt(KEY_ID); this.title = b.getString(KEY_TITLE); } @Override public View onCreate(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { // No NullPointer here, because onCreate() is called before this  Toast.makeText(getActivity(), \u0026#34;Hello \u0026#34; + title.substring(0, 3), Toast.LENGTH_SHORT).show(); } } I hope you understand now what I mean with \u0026ldquo;painful\u0026rdquo;. There\u0026rsquo;s a lot of code you have to write for any single fragment in your application. Wouldn\u0026rsquo;t it be nice if someone else could write that code for you? Annotation Processing allows you to generate java code at compile time. Note that we are not talking about evaluating annotations at run time by using reflections.\nFragmentArgs FragmentArgs is a lightweight library that generates exactly this java code for your fragments. Have a look at this code:\nimport com.hannesdorfmann.fragmentargs.FragmentArgs; import com.hannesdorfmann.fragmentargs.annotation.Arg; public class MyFragment extends Fragment { @Arg int id; @Arg String title; @Override public void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); FragmentArgs.inject(this); // read @Arg fields \t} @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { Toast.makeText(getActivity(), \u0026#34;Hello \u0026#34; + title, Toast.LENGTH_SHORT).show(); } } FragmentArgs generates the boilerplate code for you just by annotating fields of your Fragment class. In your Activity you will use the generated Builder class (the name of your fragment with \u0026ldquo;Builder\u0026rdquo; suffix) instead of new MyFragment() or a static MyFragment.newInstance(int id, String title) method.\nFor example:\npublic class MyActivity extends Activity { public void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); int id = 123; String title = \u0026#34;test\u0026#34;; // Using the generated Builder \tFragment fragment = new MyFragmentBuilder(id, title) .build(); // Fragment Transaction \tgetFragmentManager() .beginTransaction() .replace(R.id.container, fragment) .commit(); } } You may have noticed the statement FragmentArgs.inject(this); in Fragment.onCreate(Bundle). In this call your fragment gets connected to the generated code. You may ask yourself: \u0026ldquo;Do I have to override onCreate(Bundle) in every Fragment to add the inject() method call?\u0026quot; . The answer is no. A powerful feature is that FragmentArgs.inject(this); supports inheritance. You simply need to insert this line into your base fragment and extend all your fragments from this base fragment:\npublic class BaseFragment extends Fragment { @Override public void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); FragmentArgs.inject(this); // read @Arg fields  } } public class MyFragment extends BaseFragment { @Arg String title; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { Toast.makeText(getActivity(), \u0026#34;Hello \u0026#34; + title, Toast.LENGTH_SHORT).show(); } } Credits: Parts of the annotation processing code are based on Hugo Visser\u0026rsquo;s Bundles project.\nIn my next blog post I want to compare annotation processors for generating Parcelable\u0026rsquo;s and tell you why I ended up writing my own Annotation Processor called ParcelablePlease\n","permalink":"https://hannesdorfmann.com/android/fragmentargs/","tags":["android","library"],"title":"FragmentArgs"},{"categories":["Android"],"contents":"SwipeBack for Android Activities does pretty the same as the android \u0026ldquo;back-button\u0026rdquo; does, but in a really intuitive way by using a swipe gesture\nThe Samsung Galaxy Nexus was one of the first device without hardware buttons for \u0026ldquo;back\u0026rdquo;, \u0026ldquo;home\u0026rdquo; and \u0026ldquo;app switching (multitasking)\u0026rdquo; but used the androids navigation bar on screen (introduced in Android 4.0). The navigation bar was at least in my opinion a big step forward, especially on screen rotation from landscape to portrait and vice versa. But I asked myself, do we really need a navigation bar? I mean the navigation bar takes ca. 10 % of the whole screen. Even at the home screen the \u0026ldquo;back\u0026rdquo; and \u0026ldquo;home\u0026rdquo; button are useless (because they do nothing). So I thought to myself: Why do we not use swipe gestures instead of a navigation bar? But maybe this idea is to futuristic and not suitable for all kind of android user. A few years later apple introduced the swipe back gesture in iOS 7. Why doesn\u0026rsquo;t Android Apps use swipe gesture as alternative to the back button. Pinterest and Tumblr do so:\n  How Pinterest implement that? They use a single Activity and a ViewPager with custom page transformer. Something like this:\n   The problems with this approach are:\n  You will lost a little bit the ability to jump to any screen by using intents. Take Pinterest as an example: If you get a push notification from Pinterest and you click on it you will see a loading dialog on screen. Internal the navigation stack is generated by adding Fragments to the ViewPager.\n  ActionBar: The ActionBar is as default not part of a fragment, but it\u0026rsquo;s part of the activity. So you can not (by using a ViewPager) use the default ActionBar to swipe back to the previous Fragment, because the ActionBar will remain sticky. So you have to implement you own ActionBar and attach that to the fragments view.\n  SwipeBack My approach can be used for activities. It does pretty the same as the android menu drawers do. It adds an additional layout and slides the content or the window to the side. It\u0026rsquo;s pretty the same as many android navigation drawer libraries do. So we will use overridePendingTransition() to start an activity and we will override onBackPressed() and setting there the reverse animation. For instance we can use a slide-in animation when starting an Activity and a slide-out animation onBackPressed. So far so good. SwipeBack will detect the swipe gesture for you and slide the activity or window content. It will show a \u0026ldquo;hint\u0026rdquo; to give the user feedback that by dropping the finger from screen the Activity will be finished by triggering onBackPressed().\nExamples The kicker app for android uses SwipeBack. Click here to see an example.\nHow to use it You simply have to set it up in you Activities onCreate() method. Instead of Activity.setContentView() call SwipeBack.setContentView(). It\u0026rsquo;s not supported yet to build it from xml.\npublic class SwipeBackActivity extends FragmentActivity { @Override public void onCreate(Bundle saved){ super.onCreate(saved); // Init the swipe back  SwipeBack.attach(this, Position.LEFT) .setContentView(R.layout.activity_simple) .setSwipeBackView(R.layout.swipeback_default); } @Override public void onBackPressed(){ super.onBackPressed(); overridePendingTransition(R.anim.swipeback_stack_to_front, R.anim.swipeback_stack_right_out); } } Library The SwipeBack library is available on Github and on maven central.\n","permalink":"https://hannesdorfmann.com/android/swipeback/","tags":["android","ui","ux","library"],"title":"SwipeBack"}]